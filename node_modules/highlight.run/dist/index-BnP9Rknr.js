var Ic = Object.defineProperty, Sc = Object.defineProperties;
var Vc = Object.getOwnPropertyDescriptors;
var qt = Object.getOwnPropertySymbols;
var yn = Object.prototype.hasOwnProperty, gn = Object.prototype.propertyIsEnumerable;
var gs = (s, e) => (e = Symbol[s]) ? e : Symbol.for("Symbol." + s), Wc = (s) => {
  throw TypeError(s);
};
var Zs = (s, e, t) => e in s ? Ic(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, X = (s, e) => {
  for (var t in e || (e = {}))
    yn.call(e, t) && Zs(s, t, e[t]);
  if (qt)
    for (var t of qt(e))
      gn.call(e, t) && Zs(s, t, e[t]);
  return s;
}, se = (s, e) => Sc(s, Vc(e));
var pe = (s, e) => {
  var t = {};
  for (var i in s)
    yn.call(s, i) && e.indexOf(i) < 0 && (t[i] = s[i]);
  if (s != null && qt)
    for (var i of qt(s))
      e.indexOf(i) < 0 && gn.call(s, i) && (t[i] = s[i]);
  return t;
};
var Y = (s, e, t) => Zs(s, typeof e != "symbol" ? e + "" : e, t);
var ee = (s, e, t) => new Promise((i, r) => {
  var n = (o) => {
    try {
      a(t.next(o));
    } catch (c) {
      r(c);
    }
  }, l = (o) => {
    try {
      a(t.throw(o));
    } catch (c) {
      r(c);
    }
  }, a = (o) => o.done ? i(o.value) : Promise.resolve(o.value).then(n, l);
  a((t = t.apply(s, e)).next());
}), Xc = function(s, e) {
  this[0] = s, this[1] = e;
};
var Gs = (s) => {
  var e = s[gs("asyncIterator")], t = !1, i, r = {};
  return e == null ? (e = s[gs("iterator")](), i = (n) => r[n] = (l) => e[n](l)) : (e = e.call(s), i = (n) => r[n] = (l) => {
    if (t) {
      if (t = !1, n === "throw") throw l;
      return l;
    }
    return t = !0, {
      done: !1,
      value: new Xc(new Promise((a) => {
        var o = e[n](l);
        o instanceof Object || Wc("Object expected"), a(o);
      }), 1)
    };
  }), r[gs("iterator")] = () => r, i("next"), "throw" in e ? i("throw") : r.throw = (n) => {
    throw n;
  }, "return" in e && i("return"), r;
};
import { K as Rc, i as Zn, d as wc, a as Cc, Q as vc, p as xc, b as el, g as Lc, c as Yc, C as Nc, m as kc, e as xe, S as Le, s as Pe, G as Is, f as Gn, r as In, F as je, h as Tc, E as Jc, j as Ss, k as yt, l as Sn, M as Qe, n as Xe, V as Uc, H as Vn, o as Fc, q as Kc, t as Vs, u as Hc, v as Wn, w as Mc, x as zc } from "./index-ZgXLbp3c.js";
import { y as Hy, z as My } from "./index-ZgXLbp3c.js";
function Oc(s, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in s)) {
          const n = Object.getOwnPropertyDescriptor(i, r);
          n && Object.defineProperty(s, r, n.get ? n : {
            enumerable: !0,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }));
}
function Ec(s) {
  return `"${s.replace(Pc, Bc)}"`;
}
const Pc = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function Bc(s) {
  return Dc[s.charCodeAt(0)];
}
const Dc = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], Ac = Object.freeze({});
function jc(s, e, t = vc) {
  const i = /* @__PURE__ */ new Map();
  for (const W of Object.values(Rc))
    i.set(W, Qc(e, W));
  let r, n = Array.isArray(s), l = [s], a = -1, o = [], c = s, u, d;
  const h = [], p = [];
  do {
    a++;
    const W = a === l.length, S = W && o.length !== 0;
    if (W) {
      if (u = p.length === 0 ? void 0 : h[h.length - 1], c = d, d = p.pop(), S)
        if (n) {
          c = c.slice();
          let Z = 0;
          for (const [C, J] of o) {
            const V = C - Z;
            J === null ? (c.splice(V, 1), Z++) : c[V] = J;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [Z, C] of o)
            c[Z] = C;
        }
      a = r.index, l = r.keys, o = r.edits, n = r.inArray, r = r.prev;
    } else if (d) {
      if (u = n ? a : l[a], c = d[u], c == null)
        continue;
      h.push(u);
    }
    let g;
    if (!Array.isArray(c)) {
      var y, f;
      Zn(c) || wc(!1, `Invalid AST Node: ${Cc(c)}.`);
      const Z = W ? (y = i.get(c.kind)) === null || y === void 0 ? void 0 : y.leave : (f = i.get(c.kind)) === null || f === void 0 ? void 0 : f.enter;
      if (g = Z == null ? void 0 : Z.call(e, c, u, d, h, p), g === Ac)
        break;
      if (g === !1) {
        if (!W) {
          h.pop();
          continue;
        }
      } else if (g !== void 0 && (o.push([u, g]), !W))
        if (Zn(g))
          c = g;
        else {
          h.pop();
          continue;
        }
    }
    if (g === void 0 && S && o.push([u, c]), W)
      h.pop();
    else {
      var m;
      r = {
        inArray: n,
        index: a,
        keys: l,
        edits: o,
        prev: r
      }, n = Array.isArray(c), l = n ? c : (m = t[c.kind]) !== null && m !== void 0 ? m : [], a = -1, o = [], d && p.push(d), d = c;
    }
  } while (r !== void 0);
  return o.length !== 0 ? o[o.length - 1][1] : s;
}
function Qc(s, e) {
  const t = s[e];
  return typeof t == "object" ? t : typeof t == "function" ? {
    enter: t,
    leave: void 0
  } : {
    enter: s.enter,
    leave: s.leave
  };
}
function tl(s) {
  return jc(s, $c);
}
const _c = 80, $c = {
  Name: {
    leave: (s) => s.value
  },
  Variable: {
    leave: (s) => "$" + s.name
  },
  // Document
  Document: {
    leave: (s) => w(s.definitions, `

`)
  },
  OperationDefinition: {
    leave(s) {
      const e = K("(", w(s.variableDefinitions, ", "), ")"), t = w(
        [
          s.operation,
          w([s.name, e]),
          w(s.directives, " ")
        ],
        " "
      );
      return (t === "query" ? "" : t + " ") + s.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: s, type: e, defaultValue: t, directives: i }) => s + ": " + e + K(" = ", t) + K(" ", w(i, " "))
  },
  SelectionSet: {
    leave: ({ selections: s }) => Ze(s)
  },
  Field: {
    leave({ alias: s, name: e, arguments: t, directives: i, selectionSet: r }) {
      const n = K("", s, ": ") + e;
      let l = n + K("(", w(t, ", "), ")");
      return l.length > _c && (l = n + K(`(
`, Vi(w(t, `
`)), `
)`)), w([l, w(i, " "), r], " ");
    }
  },
  Argument: {
    leave: ({ name: s, value: e }) => s + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: s, directives: e }) => "..." + s + K(" ", w(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: s, directives: e, selectionSet: t }) => w(
      [
        "...",
        K("on ", s),
        w(e, " "),
        t
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: s, typeCondition: e, variableDefinitions: t, directives: i, selectionSet: r }) => (
      // or removed in the future.
      `fragment ${s}${K("(", w(t, ", "), ")")} on ${e} ${K("", w(i, " "), " ")}` + r
    )
  },
  // Value
  IntValue: {
    leave: ({ value: s }) => s
  },
  FloatValue: {
    leave: ({ value: s }) => s
  },
  StringValue: {
    leave: ({ value: s, block: e }) => e ? xc(s) : Ec(s)
  },
  BooleanValue: {
    leave: ({ value: s }) => s ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: s }) => s
  },
  ListValue: {
    leave: ({ values: s }) => "[" + w(s, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: s }) => "{" + w(s, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: s, value: e }) => s + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: s, arguments: e }) => "@" + s + K("(", w(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: s }) => s
  },
  ListType: {
    leave: ({ type: s }) => "[" + s + "]"
  },
  NonNullType: {
    leave: ({ type: s }) => s + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: s, directives: e, operationTypes: t }) => K("", s, `
`) + w(["schema", w(e, " "), Ze(t)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: s, type: e }) => s + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: s, name: e, directives: t }) => K("", s, `
`) + w(["scalar", e, w(t, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: s, name: e, interfaces: t, directives: i, fields: r }) => K("", s, `
`) + w(
      [
        "type",
        e,
        K("implements ", w(t, " & ")),
        w(i, " "),
        Ze(r)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: s, name: e, arguments: t, type: i, directives: r }) => K("", s, `
`) + e + (Xn(t) ? K(`(
`, Vi(w(t, `
`)), `
)`) : K("(", w(t, ", "), ")")) + ": " + i + K(" ", w(r, " "))
  },
  InputValueDefinition: {
    leave: ({ description: s, name: e, type: t, defaultValue: i, directives: r }) => K("", s, `
`) + w(
      [e + ": " + t, K("= ", i), w(r, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: s, name: e, interfaces: t, directives: i, fields: r }) => K("", s, `
`) + w(
      [
        "interface",
        e,
        K("implements ", w(t, " & ")),
        w(i, " "),
        Ze(r)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: s, name: e, directives: t, types: i }) => K("", s, `
`) + w(
      ["union", e, w(t, " "), K("= ", w(i, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: s, name: e, directives: t, values: i }) => K("", s, `
`) + w(["enum", e, w(t, " "), Ze(i)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: s, name: e, directives: t }) => K("", s, `
`) + w([e, w(t, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: s, name: e, directives: t, fields: i }) => K("", s, `
`) + w(["input", e, w(t, " "), Ze(i)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: s, name: e, arguments: t, repeatable: i, locations: r }) => K("", s, `
`) + "directive @" + e + (Xn(t) ? K(`(
`, Vi(w(t, `
`)), `
)`) : K("(", w(t, ", "), ")")) + (i ? " repeatable" : "") + " on " + w(r, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: s, operationTypes: e }) => w(
      ["extend schema", w(s, " "), Ze(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: s, directives: e }) => w(["extend scalar", s, w(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: s, interfaces: e, directives: t, fields: i }) => w(
      [
        "extend type",
        s,
        K("implements ", w(e, " & ")),
        w(t, " "),
        Ze(i)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: s, interfaces: e, directives: t, fields: i }) => w(
      [
        "extend interface",
        s,
        K("implements ", w(e, " & ")),
        w(t, " "),
        Ze(i)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: s, directives: e, types: t }) => w(
      [
        "extend union",
        s,
        w(e, " "),
        K("= ", w(t, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: s, directives: e, values: t }) => w(["extend enum", s, w(e, " "), Ze(t)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: s, directives: e, fields: t }) => w(["extend input", s, w(e, " "), Ze(t)], " ")
  }
};
function w(s, e = "") {
  var t;
  return (t = s == null ? void 0 : s.filter((i) => i).join(e)) !== null && t !== void 0 ? t : "";
}
function Ze(s) {
  return K(`{
`, Vi(w(s, `
`)), `
}`);
}
function K(s, e, t = "") {
  return e != null && e !== "" ? s + e + t : "";
}
function Vi(s) {
  return K("  ", s.replace(/\n/g, `
  `));
}
function Xn(s) {
  var e;
  return (e = s == null ? void 0 : s.some((t) => t.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const Nr = JSON, qc = (s) => s.toUpperCase(), eu = (s) => {
  const e = {};
  return s.forEach((t, i) => {
    e[i] = t;
  }), e;
}, tu = (s, e, t) => s.document ? s : {
  document: s,
  variables: e,
  requestHeaders: t,
  signal: void 0
}, iu = (s, e, t) => s.query ? s : {
  query: s,
  variables: e,
  requestHeaders: t,
  signal: void 0
}, su = (s, e) => s.documents ? s : {
  documents: s,
  requestHeaders: e,
  signal: void 0
}, Rn = (s) => {
  var i, r;
  let e;
  const t = s.definitions.filter((n) => n.kind === "OperationDefinition");
  return t.length === 1 && (e = (r = (i = t[0]) == null ? void 0 : i.name) == null ? void 0 : r.value), e;
}, Ws = (s) => {
  if (typeof s == "string") {
    let t;
    try {
      const i = el(s);
      t = Rn(i);
    } catch (i) {
    }
    return { query: s, operationName: t };
  }
  const e = Rn(s);
  return { query: tl(s), operationName: e };
};
var js = { exports: {} };
(function(s, e) {
  var t = typeof self != "undefined" ? self : Yc, i = function() {
    function n() {
      this.fetch = !1, this.DOMException = t.DOMException;
    }
    return n.prototype = t, new n();
  }();
  (function(n) {
    (function(l) {
      var a = {
        searchParams: "URLSearchParams" in n,
        iterable: "Symbol" in n && "iterator" in Symbol,
        blob: "FileReader" in n && "Blob" in n && function() {
          try {
            return new Blob(), !0;
          } catch (b) {
            return !1;
          }
        }(),
        formData: "FormData" in n,
        arrayBuffer: "ArrayBuffer" in n
      };
      function o(b) {
        return b && DataView.prototype.isPrototypeOf(b);
      }
      if (a.arrayBuffer)
        var c = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], u = ArrayBuffer.isView || function(b) {
          return b && c.indexOf(Object.prototype.toString.call(b)) > -1;
        };
      function d(b) {
        if (typeof b != "string" && (b = String(b)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(b))
          throw new TypeError("Invalid character in header field name");
        return b.toLowerCase();
      }
      function h(b) {
        return typeof b != "string" && (b = String(b)), b;
      }
      function p(b) {
        var G = {
          next: function() {
            var x = b.shift();
            return { done: x === void 0, value: x };
          }
        };
        return a.iterable && (G[Symbol.iterator] = function() {
          return G;
        }), G;
      }
      function y(b) {
        this.map = {}, b instanceof y ? b.forEach(function(G, x) {
          this.append(x, G);
        }, this) : Array.isArray(b) ? b.forEach(function(G) {
          this.append(G[0], G[1]);
        }, this) : b && Object.getOwnPropertyNames(b).forEach(function(G) {
          this.append(G, b[G]);
        }, this);
      }
      y.prototype.append = function(b, G) {
        b = d(b), G = h(G);
        var x = this.map[b];
        this.map[b] = x ? x + ", " + G : G;
      }, y.prototype.delete = function(b) {
        delete this.map[d(b)];
      }, y.prototype.get = function(b) {
        return b = d(b), this.has(b) ? this.map[b] : null;
      }, y.prototype.has = function(b) {
        return this.map.hasOwnProperty(d(b));
      }, y.prototype.set = function(b, G) {
        this.map[d(b)] = h(G);
      }, y.prototype.forEach = function(b, G) {
        for (var x in this.map)
          this.map.hasOwnProperty(x) && b.call(G, this.map[x], x, this);
      }, y.prototype.keys = function() {
        var b = [];
        return this.forEach(function(G, x) {
          b.push(x);
        }), p(b);
      }, y.prototype.values = function() {
        var b = [];
        return this.forEach(function(G) {
          b.push(G);
        }), p(b);
      }, y.prototype.entries = function() {
        var b = [];
        return this.forEach(function(G, x) {
          b.push([x, G]);
        }), p(b);
      }, a.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);
      function f(b) {
        if (b.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        b.bodyUsed = !0;
      }
      function m(b) {
        return new Promise(function(G, x) {
          b.onload = function() {
            G(b.result);
          }, b.onerror = function() {
            x(b.error);
          };
        });
      }
      function W(b) {
        var G = new FileReader(), x = m(G);
        return G.readAsArrayBuffer(b), x;
      }
      function S(b) {
        var G = new FileReader(), x = m(G);
        return G.readAsText(b), x;
      }
      function g(b) {
        for (var G = new Uint8Array(b), x = new Array(G.length), j = 0; j < G.length; j++)
          x[j] = String.fromCharCode(G[j]);
        return x.join("");
      }
      function Z(b) {
        if (b.slice)
          return b.slice(0);
        var G = new Uint8Array(b.byteLength);
        return G.set(new Uint8Array(b)), G.buffer;
      }
      function C() {
        return this.bodyUsed = !1, this._initBody = function(b) {
          this._bodyInit = b, b ? typeof b == "string" ? this._bodyText = b : a.blob && Blob.prototype.isPrototypeOf(b) ? this._bodyBlob = b : a.formData && FormData.prototype.isPrototypeOf(b) ? this._bodyFormData = b : a.searchParams && URLSearchParams.prototype.isPrototypeOf(b) ? this._bodyText = b.toString() : a.arrayBuffer && a.blob && o(b) ? (this._bodyArrayBuffer = Z(b.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(b) || u(b)) ? this._bodyArrayBuffer = Z(b) : this._bodyText = b = Object.prototype.toString.call(b) : this._bodyText = "", this.headers.get("content-type") || (typeof b == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(b) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var b = f(this);
          if (b)
            return b;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? f(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(W);
        }), this.text = function() {
          var b = f(this);
          if (b)
            return b;
          if (this._bodyBlob)
            return S(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(g(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(F);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var J = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function V(b) {
        var G = b.toUpperCase();
        return J.indexOf(G) > -1 ? G : b;
      }
      function R(b, G) {
        G = G || {};
        var x = G.body;
        if (b instanceof R) {
          if (b.bodyUsed)
            throw new TypeError("Already read");
          this.url = b.url, this.credentials = b.credentials, G.headers || (this.headers = new y(b.headers)), this.method = b.method, this.mode = b.mode, this.signal = b.signal, !x && b._bodyInit != null && (x = b._bodyInit, b.bodyUsed = !0);
        } else
          this.url = String(b);
        if (this.credentials = G.credentials || this.credentials || "same-origin", (G.headers || !this.headers) && (this.headers = new y(G.headers)), this.method = V(G.method || this.method || "GET"), this.mode = G.mode || this.mode || null, this.signal = G.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && x)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(x);
      }
      R.prototype.clone = function() {
        return new R(this, { body: this._bodyInit });
      };
      function F(b) {
        var G = new FormData();
        return b.trim().split("&").forEach(function(x) {
          if (x) {
            var j = x.split("="), U = j.shift().replace(/\+/g, " "), L = j.join("=").replace(/\+/g, " ");
            G.append(decodeURIComponent(U), decodeURIComponent(L));
          }
        }), G;
      }
      function v(b) {
        var G = new y(), x = b.replace(/\r?\n[\t ]+/g, " ");
        return x.split(/\r?\n/).forEach(function(j) {
          var U = j.split(":"), L = U.shift().trim();
          if (L) {
            var le = U.join(":").trim();
            G.append(L, le);
          }
        }), G;
      }
      C.call(R.prototype);
      function E(b, G) {
        G || (G = {}), this.type = "default", this.status = G.status === void 0 ? 200 : G.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in G ? G.statusText : "OK", this.headers = new y(G.headers), this.url = G.url || "", this._initBody(b);
      }
      C.call(E.prototype), E.prototype.clone = function() {
        return new E(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new y(this.headers),
          url: this.url
        });
      }, E.error = function() {
        var b = new E(null, { status: 0, statusText: "" });
        return b.type = "error", b;
      };
      var te = [301, 302, 303, 307, 308];
      E.redirect = function(b, G) {
        if (te.indexOf(G) === -1)
          throw new RangeError("Invalid status code");
        return new E(null, { status: G, headers: { location: b } });
      }, l.DOMException = n.DOMException;
      try {
        new l.DOMException();
      } catch (b) {
        l.DOMException = function(G, x) {
          this.message = G, this.name = x;
          var j = Error(G);
          this.stack = j.stack;
        }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException;
      }
      function N(b, G) {
        return new Promise(function(x, j) {
          var U = new R(b, G);
          if (U.signal && U.signal.aborted)
            return j(new l.DOMException("Aborted", "AbortError"));
          var L = new XMLHttpRequest();
          function le() {
            L.abort();
          }
          L.onload = function() {
            var ne = {
              status: L.status,
              statusText: L.statusText,
              headers: v(L.getAllResponseHeaders() || "")
            };
            ne.url = "responseURL" in L ? L.responseURL : ne.headers.get("X-Request-URL");
            var ft = "response" in L ? L.response : L.responseText;
            x(new E(ft, ne));
          }, L.onerror = function() {
            j(new TypeError("Network request failed"));
          }, L.ontimeout = function() {
            j(new TypeError("Network request failed"));
          }, L.onabort = function() {
            j(new l.DOMException("Aborted", "AbortError"));
          }, L.open(U.method, U.url, !0), U.credentials === "include" ? L.withCredentials = !0 : U.credentials === "omit" && (L.withCredentials = !1), "responseType" in L && a.blob && (L.responseType = "blob"), U.headers.forEach(function(ne, ft) {
            L.setRequestHeader(ft, ne);
          }), U.signal && (U.signal.addEventListener("abort", le), L.onreadystatechange = function() {
            L.readyState === 4 && U.signal.removeEventListener("abort", le);
          }), L.send(typeof U._bodyInit == "undefined" ? null : U._bodyInit);
        });
      }
      return N.polyfill = !0, n.fetch || (n.fetch = N, n.Headers = y, n.Request = R, n.Response = E), l.Headers = y, l.Request = R, l.Response = E, l.fetch = N, Object.defineProperty(l, "__esModule", { value: !0 }), l;
    })({});
  })(i), i.fetch.ponyfill = !0, delete i.fetch.polyfill;
  var r = i;
  e = r.fetch, e.default = r.fetch, e.fetch = r.fetch, e.Headers = r.Headers, e.Request = r.Request, e.Response = r.Response, s.exports = e;
})(js, js.exports);
var Yi = js.exports;
const Wi = /* @__PURE__ */ Lc(Yi), ru = /* @__PURE__ */ Oc({
  __proto__: null,
  default: Wi
}, [Yi]), _e = (s) => {
  let e = {};
  return s && (typeof Headers != "undefined" && s instanceof Headers || ru && Yi.Headers && s instanceof Yi.Headers ? e = eu(s) : Array.isArray(s) ? s.forEach(([t, i]) => {
    t && i !== void 0 && (e[t] = i);
  }) : e = s), e;
}, wn = (s) => s.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), nu = (s) => {
  if (!Array.isArray(s.query)) {
    const i = s, r = [`query=${encodeURIComponent(wn(i.query))}`];
    return s.variables && r.push(`variables=${encodeURIComponent(i.jsonSerializer.stringify(i.variables))}`), i.operationName && r.push(`operationName=${encodeURIComponent(i.operationName)}`), r.join("&");
  }
  if (typeof s.variables != "undefined" && !Array.isArray(s.variables))
    throw new Error("Cannot create query with given variable type, array expected");
  const e = s, t = s.query.reduce((i, r, n) => (i.push({
    query: wn(r),
    variables: e.variables ? e.jsonSerializer.stringify(e.variables[n]) : void 0
  }), i), []);
  return `query=${encodeURIComponent(e.jsonSerializer.stringify(t))}`;
}, ou = (s) => (e) => ee(void 0, null, function* () {
  var f;
  const { url: t, query: i, variables: r, operationName: n, fetch: l, fetchOptions: a, middleware: o } = e, c = X({}, e.headers);
  let u = "", d;
  s === "POST" ? (d = au(i, r, n, a.jsonSerializer), typeof d == "string" && (c["Content-Type"] = "application/json")) : u = nu({
    query: i,
    variables: r,
    operationName: n,
    jsonSerializer: (f = a.jsonSerializer) != null ? f : Nr
  });
  const h = X({
    method: s,
    headers: c,
    body: d
  }, a);
  let p = t, y = h;
  if (o) {
    const m = yield Promise.resolve(o(se(X({}, h), { url: t, operationName: n, variables: r }))), { url: S } = m, g = pe(m, ["url"]);
    p = S, y = g;
  }
  return u && (p = `${p}?${u}`), yield l(p, y);
});
class lu {
  constructor(e, t = {}) {
    this.url = e, this.requestConfig = t, this.rawRequest = (...i) => ee(this, null, function* () {
      const [r, n, l] = i, a = iu(r, n, l), m = this.requestConfig, { headers: o, fetch: c = Wi, method: u = "POST", requestMiddleware: d, responseMiddleware: h } = m, p = pe(m, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]), { url: y } = this;
      a.signal !== void 0 && (p.signal = a.signal);
      const { operationName: f } = Ws(a.query);
      return Xs({
        url: y,
        query: a.query,
        variables: a.variables,
        headers: X(X({}, _e(Rs(o))), _e(a.requestHeaders)),
        operationName: f,
        fetch: c,
        method: u,
        fetchOptions: p,
        middleware: d
      }).then((W) => (h && h(W), W)).catch((W) => {
        throw h && h(W), W;
      });
    });
  }
  request(e, ...t) {
    return ee(this, null, function* () {
      const [i, r] = t, n = tu(e, i, r), f = this.requestConfig, { headers: l, fetch: a = Wi, method: o = "POST", requestMiddleware: c, responseMiddleware: u } = f, d = pe(f, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]), { url: h } = this;
      n.signal !== void 0 && (d.signal = n.signal);
      const { query: p, operationName: y } = Ws(n.document);
      return Xs({
        url: h,
        query: p,
        variables: n.variables,
        headers: X(X({}, _e(Rs(l))), _e(n.requestHeaders)),
        operationName: y,
        fetch: a,
        method: o,
        fetchOptions: d,
        middleware: c
      }).then((m) => (u && u(m), m.data)).catch((m) => {
        throw u && u(m), m;
      });
    });
  }
  // prettier-ignore
  batchRequests(e, t) {
    var c;
    const i = su(e, t), o = this.requestConfig, { headers: r } = o, n = pe(o, ["headers"]);
    i.signal !== void 0 && (n.signal = i.signal);
    const l = i.documents.map(({ document: u }) => Ws(u).query), a = i.documents.map(({ variables: u }) => u);
    return Xs({
      url: this.url,
      query: l,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: a,
      headers: X(X({}, _e(Rs(r))), _e(i.requestHeaders)),
      operationName: void 0,
      fetch: (c = this.requestConfig.fetch) != null ? c : Wi,
      method: this.requestConfig.method || "POST",
      fetchOptions: n,
      middleware: this.requestConfig.requestMiddleware
    }).then((u) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u.data)).catch((u) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u;
    });
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, t) {
    const { headers: i } = this.requestConfig;
    return i ? i[e] = t : this.requestConfig.headers = { [e]: t }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const Xs = (s) => ee(void 0, null, function* () {
  var u, d;
  const { query: e, variables: t, fetchOptions: i } = s, r = ou(qc((u = s.method) != null ? u : "post")), n = Array.isArray(s.query), l = yield r(s), a = yield cu(l, (d = i.jsonSerializer) != null ? d : Nr), o = Array.isArray(a) ? !a.some(({ data: p }) => !p) : !!a.data, c = Array.isArray(a) || !a.errors || Array.isArray(a.errors) && !a.errors.length || i.errorPolicy === "all" || i.errorPolicy === "ignore";
  if (l.ok && c && o) {
    const h = (Array.isArray(a), a), { errors: p } = h, y = pe(h, ["errors"]), f = i.errorPolicy === "ignore" ? y : a;
    return se(X({}, n ? { data: f } : f), {
      headers: l.headers,
      status: l.status
    });
  } else {
    const p = typeof a == "string" ? {
      error: a
    } : a;
    throw new Nc(
      // @ts-expect-error TODO
      se(X({}, p), { status: l.status, headers: l.headers }),
      { query: e, variables: t }
    );
  }
}), au = (s, e, t, i) => {
  const r = i != null ? i : Nr;
  if (!Array.isArray(s))
    return r.stringify({ query: s, variables: e, operationName: t });
  if (typeof e != "undefined" && !Array.isArray(e))
    throw new Error("Cannot create request body with given variable type, array expected");
  const n = s.reduce((l, a, o) => (l.push({ query: a, variables: e ? e[o] : void 0 }), l), []);
  return r.stringify(n);
}, cu = (s, e) => ee(void 0, null, function* () {
  let t;
  return s.headers.forEach((i, r) => {
    r.toLowerCase() === "content-type" && (t = i);
  }), t && (t.toLowerCase().startsWith("application/json") || t.toLowerCase().startsWith("application/graphql+json") || t.toLowerCase().startsWith("application/graphql-response+json")) ? e.parse(yield s.text()) : s.text();
}), Rs = (s) => typeof s == "function" ? s() : s, Cn = {
  key: "_sid"
}, uu = "rrweb/sequential-id@1", du = (s) => {
  const e = s ? Object.assign({}, Cn, s) : Cn;
  let t = 0;
  return {
    name: uu,
    eventProcessor(i) {
      return Object.assign(i, {
        [e.key]: ++t
      }), i;
    },
    options: e
  };
};
var hu = Object.defineProperty, pu = (s, e, t) => e in s ? hu(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, I = (s, e, t) => pu(s, typeof e != "symbol" ? e + "" : e, t), vn, mu = Object.defineProperty, fu = (s, e, t) => e in s ? mu(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, xn = (s, e, t) => fu(s, typeof e != "symbol" ? e + "" : e, t), ie = /* @__PURE__ */ ((s) => (s[s.Document = 0] = "Document", s[s.DocumentType = 1] = "DocumentType", s[s.Element = 2] = "Element", s[s.Text = 3] = "Text", s[s.CDATA = 4] = "CDATA", s[s.Comment = 5] = "Comment", s))(ie || {});
const Ln = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, Yn = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, ei = {};
function kr(s) {
  if (ei[s])
    return ei[s];
  const e = globalThis[s], t = e.prototype, i = s in Ln ? Ln[s] : void 0, r = !!(i && // @ts-expect-error 2345
  i.every(
    (a) => {
      var o, c;
      return !!((c = (o = Object.getOwnPropertyDescriptor(t, a)) == null ? void 0 : o.get) != null && c.toString().includes("[native code]"));
    }
  )), n = s in Yn ? Yn[s] : void 0, l = !!(n && n.every(
    // @ts-expect-error 2345
    (a) => {
      var o;
      return typeof t[a] == "function" && ((o = t[a]) == null ? void 0 : o.toString().includes("[native code]"));
    }
  ));
  if (r && l)
    return ei[s] = e.prototype, e.prototype;
  try {
    const a = document.createElement("iframe");
    document.body.appendChild(a);
    const o = a.contentWindow;
    if (!o) return e.prototype;
    const c = o[s].prototype;
    return document.body.removeChild(a), c ? ei[s] = c : t;
  } catch (a) {
    return t;
  }
}
const ws = {};
function He(s, e, t) {
  var i;
  const r = `${s}.${String(t)}`;
  if (ws[r])
    return ws[r].call(
      e
    );
  const n = kr(s), l = (i = Object.getOwnPropertyDescriptor(
    n,
    t
  )) == null ? void 0 : i.get;
  return l ? (ws[r] = l, l.call(e)) : e[t];
}
const Cs = {};
function il(s, e, t) {
  const i = `${s}.${String(t)}`;
  if (Cs[i])
    return Cs[i].bind(
      e
    );
  const n = kr(s)[t];
  return typeof n != "function" ? e[t] : (Cs[i] = n, n.bind(e));
}
function bu(s) {
  return He("Node", s, "childNodes");
}
function yu(s) {
  return He("Node", s, "parentNode");
}
function gu(s) {
  return He("Node", s, "parentElement");
}
function Zu(s) {
  return He("Node", s, "textContent");
}
function Gu(s, e) {
  return il("Node", s, "contains")(e);
}
function Iu(s) {
  return il("Node", s, "getRootNode")();
}
function Su(s) {
  return !s || !("host" in s) ? null : He("ShadowRoot", s, "host");
}
function Vu(s) {
  return s.styleSheets;
}
function Wu(s) {
  return !s || !("shadowRoot" in s) ? null : He("Element", s, "shadowRoot");
}
function Xu(s, e) {
  return He("Element", s, "querySelector")(e);
}
function Ru(s, e) {
  return He("Element", s, "querySelectorAll")(e);
}
function wu() {
  return kr("MutationObserver").constructor;
}
const re = {
  childNodes: bu,
  parentNode: yu,
  parentElement: gu,
  textContent: Zu,
  contains: Gu,
  getRootNode: Iu,
  host: Su,
  styleSheets: Vu,
  shadowRoot: Wu,
  querySelector: Xu,
  querySelectorAll: Ru,
  mutationObserver: wu
};
function sl(s) {
  return s.nodeType === s.ELEMENT_NODE;
}
function wt(s) {
  const e = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    s && "host" in s && "mode" in s && re.host(s) || null
  );
  return !!(e && "shadowRoot" in e && re.shadowRoot(e) === s);
}
function Ct(s) {
  return Object.prototype.toString.call(s) === "[object ShadowRoot]";
}
function Cu(s) {
  return s.includes(" background-clip: text;") && !s.includes(" -webkit-background-clip: text;") && (s = s.replace(
    /\sbackground-clip:\s*text;/g,
    " -webkit-background-clip: text; background-clip: text;"
  )), s;
}
function vu(s) {
  const { cssText: e } = s;
  if (e.split('"').length < 3) return e;
  const t = ["@import", `url(${JSON.stringify(s.href)})`];
  return s.layerName === "" ? t.push("layer") : s.layerName && t.push(`layer(${s.layerName})`), s.supportsText && t.push(`supports(${s.supportsText})`), s.media.length && t.push(s.media.mediaText), t.join(" ") + ";";
}
function Ni(s) {
  try {
    const e = s.rules || s.cssRules;
    if (!e)
      return null;
    const t = Array.from(
      e,
      (i) => rl(i, s.href)
    ).join("");
    return Cu(t);
  } catch (e) {
    return null;
  }
}
function rl(s, e) {
  if (Lu(s)) {
    let t;
    try {
      t = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      Ni(s.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      vu(s);
    } catch (i) {
      t = s.cssText;
    }
    return s.styleSheet.href ? ki(t, s.styleSheet.href) : t;
  } else {
    let t = s.cssText;
    return Yu(s) && s.selectorText.includes(":") && (t = xu(t)), e ? ki(t, e) : t;
  }
}
function xu(s) {
  const e = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return s.replace(e, "$1\\$2");
}
function Lu(s) {
  return "styleSheet" in s;
}
function Yu(s) {
  return "selectorText" in s;
}
class nl {
  constructor() {
    xn(this, "idNodeMap", /* @__PURE__ */ new Map()), xn(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(e) {
    var t;
    if (!e) return -1;
    const i = (t = this.getMeta(e)) == null ? void 0 : t.id;
    return i != null ? i : -1;
  }
  getNode(e) {
    return this.idNodeMap.get(e) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(e) {
    return this.nodeMetaMap.get(e) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(e) {
    const t = this.getId(e);
    this.idNodeMap.delete(t), e.childNodes && e.childNodes.forEach(
      (i) => this.removeNodeFromMap(i)
    );
  }
  has(e) {
    return this.idNodeMap.has(e);
  }
  hasNode(e) {
    return this.nodeMetaMap.has(e);
  }
  add(e, t) {
    const i = t.id;
    this.idNodeMap.set(i, e), this.nodeMetaMap.set(e, t);
  }
  replace(e, t) {
    const i = this.getNode(e);
    if (i) {
      const r = this.nodeMetaMap.get(i);
      r && this.nodeMetaMap.set(t, r);
    }
    this.idNodeMap.set(e, t);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function Nu() {
  return new nl();
}
function Tr({
  element: s,
  maskInputOptions: e,
  tagName: t,
  type: i,
  value: r,
  overwriteRecord: n,
  maskInputFn: l
}) {
  let a = r || "";
  return al({
    maskInputOptions: e,
    tagName: t,
    type: i,
    overwriteRecord: n
  }) && (l ? a = l(a, s) : a = "*".repeat(a.length)), a;
}
function nt(s) {
  return s.toLowerCase();
}
const Nn = "__rrweb_original__";
function ku(s) {
  const e = s.getContext("2d");
  if (!e) return !0;
  const t = 50;
  for (let i = 0; i < s.width; i += t)
    for (let r = 0; r < s.height; r += t) {
      const n = e.getImageData, l = Nn in n ? n[Nn] : n;
      if (new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        l.call(
          e,
          i,
          r,
          Math.min(t, s.width - i),
          Math.min(t, s.height - r)
        ).data.buffer
      ).some((o) => o !== 0)) return !1;
    }
  return !0;
}
function Jr(s) {
  const e = s.type;
  return s.hasAttribute("data-rr-is-password") ? "password" : e ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    nt(e)
  ) : null;
}
function ol(s, e) {
  var n;
  let t;
  try {
    t = new URL(s, window.location.href);
  } catch (l) {
    return null;
  }
  const i = /\.([0-9a-z]+)(?:$)/i, r = t.pathname.match(i);
  return (n = r == null ? void 0 : r[1]) != null ? n : null;
}
function Tu(s) {
  let e = "";
  return s.indexOf("//") > -1 ? e = s.split("/").slice(0, 3).join("/") : e = s.split("/")[0], e = e.split("?")[0], e;
}
const Ju = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, Uu = /^(?:[a-z+]+:)?\/\//i, Fu = /^www\..*/i, Ku = /^(data:)([^,]*),(.*)/i;
function ki(s, e) {
  return (s || "").replace(
    Ju,
    (t, i, r, n, l, a) => {
      const o = r || l || a, c = i || n || "";
      if (!o)
        return t;
      if (Uu.test(o) || Fu.test(o))
        return `url(${c}${o}${c})`;
      if (Ku.test(o))
        return `url(${c}${o}${c})`;
      if (o[0] === "/")
        return `url(${c}${Tu(e) + o}${c})`;
      const u = e.split("/"), d = o.split("/");
      u.pop();
      for (const h of d)
        h !== "." && (h === ".." ? u.pop() : u.push(h));
      return `url(${c}${u.join("/")}${c})`;
    }
  );
}
function Ur(s) {
  return s = s.replace(/[^ -~]+/g, ""), s = (s == null ? void 0 : s.split(" ").map((e) => Math.random().toString(20).substring(2, e.length)).join(" ")) || "", s;
}
function Qs(s) {
  return s === "img" || s === "video" || s === "audio" || s === "source";
}
const Hu = new RegExp(
  /[a-zA-Z0-9.!#$%&'*+=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:.[a-zA-Z0-9-]+)*/
), Mu = new RegExp(/[0-9]{9,16}/), zu = new RegExp(/[0-9]{3}-?[0-9]{2}-?[0-9]{4}/), Ou = new RegExp(
  /[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}/
), Eu = new RegExp(/[0-9]{4}-?[0-9]{4}-?[0-9]{4}-?[0-9]{4}/), Pu = new RegExp(
  /[0-9]{1,5}.?[0-9]{0,3}\s[a-zA-Z]{2,30}\s[a-zA-Z]{2,15}/
), Bu = new RegExp(/(?:[0-9]{1,3}.){3}[0-9]{1,3}/), Du = [
  Hu,
  Mu,
  zu,
  Ou,
  Eu,
  Pu,
  Bu
];
function ll(s) {
  return s ? Du.some((e) => e.test(s)) : !1;
}
const al = ({
  maskInputOptions: s,
  tagName: e,
  type: t,
  overwriteRecord: i
}) => {
  const r = t && t.toLowerCase();
  return i !== "true" && (!!s[e.toLowerCase()] || !!(r && s[r]));
};
let Au = 1;
const ju = new RegExp("[^a-z0-9-_:]"), Yt = -2;
function cl() {
  return Au++;
}
function Qu(s) {
  if (s instanceof HTMLFormElement)
    return "form";
  const e = nt(s.tagName);
  return ju.test(e) ? "div" : e;
}
let $e, kn;
const _u = /^[^ \t\n\r\u000c]+/, $u = /^[, \t\n\r\u000c]+/;
function qu(s, e) {
  if (e.trim() === "")
    return e;
  let t = 0;
  function i(n) {
    let l;
    const a = n.exec(e.substring(t));
    return a ? (l = a[0], t += l.length, l) : "";
  }
  const r = [];
  for (; i($u), !(t >= e.length); ) {
    let n = i(_u);
    if (n.slice(-1) === ",")
      n = tt(s, n.substring(0, n.length - 1)), r.push(n);
    else {
      let l = "";
      n = tt(s, n);
      let a = !1;
      for (; ; ) {
        const o = e.charAt(t);
        if (o === "") {
          r.push((n + l).trim());
          break;
        } else if (a)
          o === ")" && (a = !1);
        else if (o === ",") {
          t += 1, r.push((n + l).trim());
          break;
        } else o === "(" && (a = !0);
        l += o, t += 1;
      }
    }
  }
  return r.join(", ");
}
const Tn = /* @__PURE__ */ new WeakMap();
function tt(s, e) {
  return !e || e.trim() === "" ? e : Fr(s, e);
}
function ed(s) {
  return !!(s.tagName === "svg" || s.ownerSVGElement);
}
function Fr(s, e) {
  let t = Tn.get(s);
  if (t || (t = s.createElement("a"), Tn.set(s, t)), !e)
    e = "";
  else if (e.startsWith("blob:") || e.startsWith("data:"))
    return e;
  return t.setAttribute("href", e), t.href;
}
function ul(s, e, t, i) {
  return i && (t === "src" || t === "href" && !(e === "use" && i[0] === "#") || t === "xlink:href" && i[0] !== "#" || t === "background" && (e === "table" || e === "td" || e === "th") ? tt(s, i) : t === "srcset" ? qu(s, i) : t === "style" ? ki(i, Fr(s)) : e === "object" && t === "data" ? tt(s, i) : i);
}
function dl(s, e, t) {
  return (s === "video" || s === "audio") && e === "autoplay";
}
function Jn(s, e, t) {
  try {
    if (typeof e == "string") {
      if (s.classList.contains(e))
        return !0;
    } else
      for (let i = s.classList.length; i--; ) {
        const r = s.classList[i];
        if (e.test(r))
          return !0;
      }
    if (t)
      return s.matches(t);
  } catch (i) {
  }
  return !1;
}
function Ti(s, e, t) {
  if (!s) return !1;
  if (s.nodeType !== s.ELEMENT_NODE)
    return t ? Ti(re.parentNode(s), e, t) : !1;
  for (let i = s.classList.length; i--; ) {
    const r = s.classList[i];
    if (e.test(r))
      return !0;
  }
  return t ? Ti(re.parentNode(s), e, t) : !1;
}
function hl(s, e, t, i) {
  let r;
  if (sl(s)) {
    if (r = s, !re.childNodes(r).length)
      return !1;
  } else {
    if (re.parentElement(s) === null)
      return !1;
    r = re.parentElement(s);
  }
  try {
    if (typeof e == "string") {
      if (i) {
        if (r.closest(`.${e}`)) return !0;
      } else if (r.classList.contains(e)) return !0;
    } else if (Ti(r, e, i)) return !0;
    if (t) {
      if (i) {
        if (r.closest(t)) return !0;
      } else if (r.matches(t)) return !0;
    }
  } catch (n) {
  }
  return !1;
}
function td(s, e, t) {
  const i = s.contentWindow;
  if (!i)
    return;
  let r = !1, n;
  try {
    n = i.document.readyState;
  } catch (a) {
    return;
  }
  if (n !== "complete") {
    const a = setTimeout(() => {
      r || (e(), r = !0);
    }, t);
    s.addEventListener("load", () => {
      clearTimeout(a), r = !0, e();
    });
    return;
  }
  const l = "about:blank";
  if (i.location.href !== l || s.src === l || s.src === "")
    return setTimeout(e, 0), s.addEventListener("load", e);
  s.addEventListener("load", e);
}
function id(s, e, t) {
  let i = !1, r;
  try {
    r = s.sheet;
  } catch (l) {
    return;
  }
  if (r) return;
  const n = setTimeout(() => {
    i || (e(), i = !0);
  }, t);
  s.addEventListener("load", () => {
    clearTimeout(n), i = !0, e();
  });
}
function sd(s, e) {
  const {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    needsMask: l,
    inlineStylesheet: a,
    maskInputOptions: o = {},
    maskTextClass: c,
    maskTextFn: u,
    maskInputFn: d,
    dataURLOptions: h = {},
    inlineImages: p,
    recordCanvas: y,
    keepIframeSrcFn: f,
    newlyAddedElement: m = !1,
    privacySetting: W
  } = e, S = rd(t, i);
  switch (s.nodeType) {
    case s.DOCUMENT_NODE:
      return s.compatMode !== "CSS1Compat" ? {
        type: ie.Document,
        childNodes: [],
        compatMode: s.compatMode
        // probably "BackCompat"
      } : {
        type: ie.Document,
        childNodes: []
      };
    case s.DOCUMENT_TYPE_NODE:
      return {
        type: ie.DocumentType,
        name: s.name,
        publicId: s.publicId,
        systemId: s.systemId,
        rootId: S
      };
    case s.ELEMENT_NODE:
      return od(s, {
        doc: t,
        blockClass: r,
        blockSelector: n,
        inlineStylesheet: a,
        maskInputOptions: o,
        maskInputFn: d,
        maskTextClass: c,
        dataURLOptions: h,
        inlineImages: p,
        recordCanvas: y,
        keepIframeSrcFn: f,
        newlyAddedElement: m,
        privacySetting: W,
        rootId: S
      });
    case s.TEXT_NODE:
      return nd(s, {
        doc: t,
        needsMask: l,
        maskTextFn: u,
        privacySetting: W,
        rootId: S
      });
    case s.CDATA_SECTION_NODE:
      return {
        type: ie.CDATA,
        textContent: "",
        rootId: S
      };
    case s.COMMENT_NODE:
      return {
        type: ie.Comment,
        textContent: re.textContent(s) || "",
        rootId: S
      };
    default:
      return !1;
  }
}
function rd(s, e) {
  if (!e.hasNode(s)) return;
  const t = e.getId(s);
  return t === 1 ? void 0 : t;
}
function nd(s, e) {
  var t, i;
  const { needsMask: r, maskTextFn: n, privacySetting: l, rootId: a } = e, o = re.parentNode(s), c = o && o.tagName;
  let u = re.textContent(s);
  const d = c === "STYLE" ? !0 : void 0, h = c === "SCRIPT" ? !0 : void 0;
  if (d && u) {
    try {
      s.nextSibling || s.previousSibling || (t = o.sheet) != null && t.cssRules && (u = Ni(o.sheet));
    } catch (m) {
      console.warn(
        `Cannot get CSS styles from text's parentNode. Error: ${m}`,
        s
      );
    }
    u = ki(u, Fr(e.doc));
  }
  h && (u = "SCRIPT_PLACEHOLDER"), !d && !h && u && r && (u = n ? n(u, re.parentElement(s)) : u.replace(/[\S]/g, "*"));
  const p = l === "strict", y = (i = s.parentElement) == null ? void 0 : i.getAttribute("data-hl-record"), f = l === "default" && ll(u);
  return (p || f) && !y && c && !(/* @__PURE__ */ new Set([
    "HEAD",
    "TITLE",
    "STYLE",
    "SCRIPT",
    "HTML",
    "BODY",
    "NOSCRIPT"
  ])).has(c) && u && (u = Ur(u)), {
    type: ie.Text,
    textContent: u || "",
    isStyle: d,
    rootId: a
  };
}
function od(s, e) {
  const {
    doc: t,
    blockClass: i,
    blockSelector: r,
    inlineStylesheet: n,
    maskInputOptions: l = {},
    maskInputFn: a,
    maskTextClass: o,
    dataURLOptions: c = {},
    inlineImages: u,
    recordCanvas: d,
    keepIframeSrcFn: h,
    newlyAddedElement: p = !1,
    privacySetting: y,
    rootId: f
  } = e;
  let m = Jn(s, i, r);
  const W = Jn(s, o, null), S = y === "strict";
  let g = Qu(s), Z = {};
  const C = s.attributes.length;
  for (let V = 0; V < C; V++) {
    const R = s.attributes[V];
    dl(g, R.name) || (Z[R.name] = ul(
      t,
      g,
      nt(R.name),
      R.value
    ));
  }
  if (g === "link" && n) {
    const V = Array.from(t.styleSheets).find((F) => F.href === s.href);
    let R = null;
    V && (R = Ni(V)), R && (delete Z.rel, delete Z.href, Z._cssText = R);
  }
  if (g === "style" && s.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element
  !(s.innerText || re.textContent(s) || "").trim().length) {
    const V = Ni(
      s.sheet
    );
    V && (Z._cssText = V);
  }
  if (g === "input" || g === "textarea" || g === "select") {
    const V = s.value, R = s.checked;
    Z.type !== "radio" && Z.type !== "checkbox" && Z.type !== "submit" && Z.type !== "button" && V ? Z.value = Tr({
      element: s,
      type: Jr(s),
      tagName: g,
      value: V,
      overwriteRecord: s.getAttribute("data-hl-record"),
      maskInputOptions: l,
      maskInputFn: a
    }) : R && (Z.checked = R);
  }
  if (g === "option" && (s.selected && !l.select ? Z.selected = !0 : delete Z.selected), g === "dialog" && s.open && (Z.rr_open_mode = s.matches("dialog:modal") ? "modal" : "non-modal"), g === "canvas" && d) {
    if (s.__context === "2d")
      ku(s);
    else if (!("__context" in s)) {
      const V = s.toDataURL(
        c.type,
        c.quality
      ), R = t.createElement("canvas");
      R.width = s.width, R.height = s.height;
      const F = R.toDataURL(
        c.type,
        c.quality
      );
      V !== F && (Z.rr_dataURL = V);
    }
  }
  if (g === "img" && u && !m && !W && !S) {
    $e || ($e = t.createElement("canvas"), kn = $e.getContext("2d"));
    const V = s, R = V.currentSrc || V.getAttribute("src") || "<unknown-src>", F = V.crossOrigin, v = () => {
      V.removeEventListener("load", v);
      try {
        $e.width = V.naturalWidth, $e.height = V.naturalHeight, kn.drawImage(V, 0, 0), Z.rr_dataURL = $e.toDataURL(
          c.type,
          c.quality
        );
      } catch (E) {
        if (V.crossOrigin !== "anonymous") {
          V.crossOrigin = "anonymous", V.complete && V.naturalWidth !== 0 ? v() : V.addEventListener("load", v);
          return;
        } else
          console.warn(
            `Cannot inline img src=${R}! Error: ${E}`
          );
      }
      V.crossOrigin === "anonymous" && (F ? Z.crossOrigin = F : V.removeAttribute("crossorigin"));
    };
    V.complete && V.naturalWidth !== 0 ? v() : V.addEventListener("load", v);
  }
  if (g === "audio" || g === "video") {
    const V = Z;
    V.rr_mediaState = s.paused ? "paused" : "played", V.rr_mediaCurrentTime = s.currentTime, V.rr_mediaPlaybackRate = s.playbackRate, V.rr_mediaMuted = s.muted, V.rr_mediaLoop = s.loop, V.rr_mediaVolume = s.volume;
  }
  if (p || (s.scrollLeft && (Z.rr_scrollLeft = s.scrollLeft), s.scrollTop && (Z.rr_scrollTop = s.scrollTop)), m || W || S && Qs(g)) {
    const { width: V, height: R } = s.getBoundingClientRect();
    Z = {
      class: Z.class,
      rr_width: `${V}px`,
      rr_height: `${R}px`
    };
  }
  S && Qs(g) && (m = !0), g === "iframe" && !h(Z.src) && (s.contentDocument || (Z.rr_src = Z.src), delete Z.src);
  let J;
  try {
    customElements.get(g) && (J = !0);
  } catch (V) {
  }
  if (u && g === "video") {
    const V = s;
    if (V.src === "" || V.src.indexOf("blob:") !== -1) {
      const { width: R, height: F } = s.getBoundingClientRect();
      Z = {
        width: R,
        height: F,
        rr_width: `${R}px`,
        rr_height: `${F}px`,
        rr_inlined_video: !0,
        class: Z.class,
        style: Z.style
      }, g = "canvas";
      const v = t.createElement("canvas");
      v.width = s.width, v.height = s.height, Z.rr_dataURL = v.toDataURL(
        c.type,
        c.quality
      );
    }
  }
  return {
    type: ie.Element,
    tagName: g,
    attributes: Z,
    childNodes: [],
    isSVG: ed(s) || void 0,
    needBlock: m,
    needMask: W,
    rootId: f,
    isCustom: J
  };
}
function Q(s) {
  return s == null ? "" : s.toLowerCase();
}
function ld(s, e) {
  if (e.comment && s.type === ie.Comment)
    return !0;
  if (s.type === ie.Element) {
    if (e.script && // script tag
    (s.tagName === "script" || // (module)preload link
    s.tagName === "link" && (s.attributes.rel === "preload" || s.attributes.rel === "modulepreload") && s.attributes.as === "script" || // prefetch link
    s.tagName === "link" && s.attributes.rel === "prefetch" && typeof s.attributes.href == "string" && ol(s.attributes.href) === "js"))
      return !0;
    if (e.headFavicon && (s.tagName === "link" && s.attributes.rel === "shortcut icon" || s.tagName === "meta" && (Q(s.attributes.name).match(
      /^msapplication-tile(image|color)$/
    ) || Q(s.attributes.name) === "application-name" || Q(s.attributes.rel) === "icon" || Q(s.attributes.rel) === "apple-touch-icon" || Q(s.attributes.rel) === "shortcut icon")))
      return !0;
    if (s.tagName === "meta") {
      if (e.headMetaDescKeywords && Q(s.attributes.name).match(/^description|keywords$/))
        return !0;
      if (e.headMetaSocial && (Q(s.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
      Q(s.attributes.name).match(/^(og|twitter):/) || Q(s.attributes.name) === "pinterest"))
        return !0;
      if (e.headMetaRobots && (Q(s.attributes.name) === "robots" || Q(s.attributes.name) === "googlebot" || Q(s.attributes.name) === "bingbot"))
        return !0;
      if (e.headMetaHttpEquiv && s.attributes["http-equiv"] !== void 0)
        return !0;
      if (e.headMetaAuthorship && (Q(s.attributes.name) === "author" || Q(s.attributes.name) === "generator" || Q(s.attributes.name) === "framework" || Q(s.attributes.name) === "publisher" || Q(s.attributes.name) === "progid" || Q(s.attributes.property).match(/^article:/) || Q(s.attributes.property).match(/^product:/)))
        return !0;
      if (e.headMetaVerification && (Q(s.attributes.name) === "google-site-verification" || Q(s.attributes.name) === "yandex-verification" || Q(s.attributes.name) === "csrf-token" || Q(s.attributes.name) === "p:domain_verify" || Q(s.attributes.name) === "verify-v1" || Q(s.attributes.name) === "verification" || Q(s.attributes.name) === "shopify-checkout-api-token"))
        return !0;
    }
  }
  return !1;
}
function it(s, e) {
  const {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    maskTextClass: l,
    maskTextSelector: a,
    skipChild: o = !1,
    inlineStylesheet: c = !0,
    maskInputOptions: u = {},
    maskTextFn: d,
    maskInputFn: h,
    slimDOMOptions: p,
    dataURLOptions: y = {},
    inlineImages: f = !1,
    recordCanvas: m = !1,
    onSerialize: W,
    onIframeLoad: S,
    iframeLoadTimeout: g = 5e3,
    onStylesheetLoad: Z,
    stylesheetLoadTimeout: C = 5e3,
    keepIframeSrcFn: J = () => !1,
    newlyAddedElement: V = !1,
    privacySetting: R
  } = e;
  let { needsMask: F } = e, { preserveWhiteSpace: v = !0 } = e;
  F || (F = hl(
    s,
    l,
    a,
    F === void 0
  ));
  const E = sd(s, {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    needsMask: F,
    inlineStylesheet: c,
    maskInputOptions: u,
    maskTextClass: l,
    maskTextFn: d,
    maskInputFn: h,
    dataURLOptions: y,
    inlineImages: f,
    recordCanvas: m,
    keepIframeSrcFn: J,
    newlyAddedElement: V,
    privacySetting: R
  });
  if (!E)
    return console.warn(s, "not serialized"), null;
  let te;
  i.hasNode(s) ? te = i.getId(s) : ld(E, p) || !v && E.type === ie.Text && !E.isStyle && !E.textContent.replace(/^\s+|\s+$/gm, "").length ? te = Yt : te = cl();
  const N = Object.assign(E, { id: te });
  if (i.add(s, N), te === Yt)
    return null;
  W && W(s);
  let b = !o, G = R, x = R === "strict";
  if (N.type === ie.Element) {
    if (b = b && !N.needBlock, x || (x = !!N.needBlock || !!N.needMask), G = x ? "strict" : G, x && Qs(N.tagName)) {
      const L = s.cloneNode();
      L.src = "", i.add(L, N);
    }
    delete N.needBlock, delete N.needMask;
    const U = re.shadowRoot(s);
    U && Ct(U) && (N.isShadowHost = !0);
  }
  if ((N.type === ie.Document || N.type === ie.Element) && b) {
    p.headWhitespace && N.type === ie.Element && N.tagName === "head" && (v = !1);
    const U = {
      doc: t,
      mirror: i,
      blockClass: r,
      blockSelector: n,
      needsMask: F,
      maskTextClass: l,
      maskTextSelector: a,
      skipChild: o,
      inlineStylesheet: c,
      maskInputOptions: u,
      maskTextFn: d,
      maskInputFn: h,
      slimDOMOptions: p,
      dataURLOptions: y,
      inlineImages: f,
      recordCanvas: m,
      preserveWhiteSpace: v,
      onSerialize: W,
      onIframeLoad: S,
      iframeLoadTimeout: g,
      onStylesheetLoad: Z,
      stylesheetLoadTimeout: C,
      keepIframeSrcFn: J,
      privacySetting: G
    };
    if (!(N.type === ie.Element && N.tagName === "textarea" && N.attributes.value !== void 0)) for (const le of Array.from(re.childNodes(s))) {
      const ne = it(le, U);
      ne && N.childNodes.push(ne);
    }
    let L = null;
    if (sl(s) && (L = re.shadowRoot(s)))
      for (const le of Array.from(re.childNodes(L))) {
        const ne = it(le, U);
        ne && (Ct(L) && (ne.isShadow = !0), N.childNodes.push(ne));
      }
  }
  const j = re.parentNode(s);
  return j && wt(j) && Ct(j) && (N.isShadow = !0), N.type === ie.Element && N.tagName === "iframe" && td(
    s,
    () => {
      const U = s.contentDocument;
      if (U && S) {
        const L = it(U, {
          doc: U,
          mirror: i,
          blockClass: r,
          blockSelector: n,
          needsMask: F,
          maskTextClass: l,
          maskTextSelector: a,
          skipChild: !1,
          inlineStylesheet: c,
          maskInputOptions: u,
          maskTextFn: d,
          maskInputFn: h,
          slimDOMOptions: p,
          dataURLOptions: y,
          inlineImages: f,
          recordCanvas: m,
          preserveWhiteSpace: v,
          onSerialize: W,
          onIframeLoad: S,
          iframeLoadTimeout: g,
          onStylesheetLoad: Z,
          stylesheetLoadTimeout: C,
          keepIframeSrcFn: J,
          privacySetting: R
        });
        L && S(
          s,
          L
        );
      }
    },
    g
  ), N.type === ie.Element && N.tagName === "link" && typeof N.attributes.rel == "string" && (N.attributes.rel === "stylesheet" || N.attributes.rel === "preload" && typeof N.attributes.href == "string" && ol(N.attributes.href) === "css") && id(
    s,
    () => {
      if (Z) {
        const U = it(s, {
          doc: t,
          mirror: i,
          blockClass: r,
          blockSelector: n,
          needsMask: F,
          maskTextClass: l,
          maskTextSelector: a,
          skipChild: !1,
          inlineStylesheet: c,
          maskInputOptions: u,
          maskTextFn: d,
          maskInputFn: h,
          slimDOMOptions: p,
          dataURLOptions: y,
          inlineImages: f,
          recordCanvas: m,
          preserveWhiteSpace: v,
          onSerialize: W,
          onIframeLoad: S,
          iframeLoadTimeout: g,
          onStylesheetLoad: Z,
          stylesheetLoadTimeout: C,
          keepIframeSrcFn: J,
          privacySetting: R
        });
        U && Z(
          s,
          U
        );
      }
    },
    C
  ), N;
}
function ad(s, e) {
  const {
    mirror: t = new nl(),
    blockClass: i = "highlight-block",
    blockSelector: r = null,
    maskTextClass: n = "highlight-mask",
    maskTextSelector: l = null,
    inlineStylesheet: a = !0,
    inlineImages: o = !1,
    recordCanvas: c = !1,
    maskAllInputs: u = !1,
    maskTextFn: d,
    maskInputFn: h,
    slimDOM: p = !1,
    dataURLOptions: y,
    preserveWhiteSpace: f,
    onSerialize: m,
    onIframeLoad: W,
    iframeLoadTimeout: S,
    onStylesheetLoad: g,
    stylesheetLoadTimeout: Z,
    keepIframeSrcFn: C = () => !1,
    privacySetting: J = "default"
  } = e || {};
  return it(s, {
    doc: s,
    mirror: t,
    blockClass: i,
    blockSelector: r,
    maskTextClass: n,
    maskTextSelector: l,
    skipChild: !1,
    inlineStylesheet: a,
    maskInputOptions: u === !0 ? {
      color: !0,
      date: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
      textarea: !0,
      select: !0,
      password: !0
    } : u === !1 ? {
      password: !0
    } : u,
    maskTextFn: d,
    maskInputFn: h,
    slimDOMOptions: p || p === "all" ? (
      // if true: set of sensible options that should not throw away any information
      {
        script: !0,
        comment: !0,
        headFavicon: !0,
        headWhitespace: !0,
        headMetaDescKeywords: p === "all",
        // destructive
        headMetaSocial: !0,
        headMetaRobots: !0,
        headMetaHttpEquiv: !0,
        headMetaAuthorship: !0,
        headMetaVerification: !0
      }
    ) : p || {},
    dataURLOptions: y,
    inlineImages: o,
    recordCanvas: c,
    preserveWhiteSpace: f,
    onSerialize: m,
    onIframeLoad: W,
    iframeLoadTimeout: S,
    onStylesheetLoad: g,
    stylesheetLoadTimeout: Z,
    keepIframeSrcFn: C,
    newlyAddedElement: !1,
    privacySetting: J
  });
}
function cd(s) {
  if (s.__esModule) return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(s, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return s[i];
      }
    });
  }), t;
}
var Kr = { exports: {} }, k = String, pl = function() {
  return { isColorSupported: !1, reset: k, bold: k, dim: k, italic: k, underline: k, inverse: k, hidden: k, strikethrough: k, black: k, red: k, green: k, yellow: k, blue: k, magenta: k, cyan: k, white: k, gray: k, bgBlack: k, bgRed: k, bgGreen: k, bgYellow: k, bgBlue: k, bgMagenta: k, bgCyan: k, bgWhite: k, blackBright: k, redBright: k, greenBright: k, yellowBright: k, blueBright: k, magentaBright: k, cyanBright: k, whiteBright: k, bgBlackBright: k, bgRedBright: k, bgGreenBright: k, bgYellowBright: k, bgBlueBright: k, bgMagentaBright: k, bgCyanBright: k, bgWhiteBright: k };
};
Kr.exports = pl();
Kr.exports.createColors = pl;
var ud = Kr.exports;
const dd = {}, hd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: dd
}, Symbol.toStringTag, { value: "Module" })), Se = /* @__PURE__ */ cd(hd);
let Un = ud, Fn = Se, _s = class ml extends Error {
  constructor(e, t, i, r, n, l) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), r && (this.source = r), l && (this.plugin = l), typeof t != "undefined" && typeof i != "undefined" && (typeof t == "number" ? (this.line = t, this.column = i) : (this.line = t.line, this.column = t.column, this.endLine = i.line, this.endColumn = i.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, ml);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = Un.isColorSupported);
    let i = (u) => u, r = (u) => u, n = (u) => u;
    if (e) {
      let { bold: u, gray: d, red: h } = Un.createColors(!0);
      r = (p) => u(h(p)), i = (p) => d(p), Fn && (n = (p) => Fn(p));
    }
    let l = t.split(/\r?\n/), a = Math.max(this.line - 3, 0), o = Math.min(this.line + 2, l.length), c = String(o).length;
    return l.slice(a, o).map((u, d) => {
      let h = a + 1 + d, p = " " + (" " + h).slice(-c) + " | ";
      if (h === this.line) {
        if (u.length > 160) {
          let f = 20, m = Math.max(0, this.column - f), W = Math.max(
            this.column + f,
            this.endColumn + f
          ), S = u.slice(m, W), g = i(p.replace(/\d/g, " ")) + u.slice(0, Math.min(this.column - 1, f - 1)).replace(/[^\t]/g, " ");
          return r(">") + i(p) + n(S) + `
 ` + g + r("^");
        }
        let y = i(p.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return r(">") + i(p) + n(u) + `
 ` + y + r("^");
      }
      return " " + i(p) + n(u);
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Hr = _s;
_s.default = _s;
const Kn = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function pd(s) {
  return s[0].toUpperCase() + s.slice(1);
}
let $s = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, r = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName != "undefined" ? i += e.raws.afterName : r && (i += " "), e.nodes)
      this.block(e, i + r);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + r + n, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let r = e.parent, n = 0;
    for (; r && r.type !== "root"; )
      n += 1, r = r.parent;
    if (i.includes(`
`)) {
      let l = this.raw(e, null, "indent");
      if (l.length)
        for (let a = 0; a < n; a++) i += l;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let r;
    e.nodes && e.nodes.length ? (this.body(e), r = this.raw(e, "after")) : r = this.raw(e, "after", "emptyBody"), r && this.builder(r), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let r = 0; r < e.nodes.length; r++) {
      let n = e.nodes[r], l = this.raw(n, "before");
      l && this.builder(l), this.stringify(n, t !== r || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), r = e.prop + i + this.rawValue(e, "value");
    e.important && (r += e.raws.important || " !important"), t && (r += ";"), this.builder(r, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let r;
    if (i || (i = t), t && (r = e.raws[t], typeof r != "undefined"))
      return r;
    let n = e.parent;
    if (i === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return Kn[i];
    let l = e.root();
    if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[i] != "undefined")
      return l.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let a = "raw" + pd(i);
      this[a] ? r = this[a](l, e) : l.walk((o) => {
        if (r = o.raws[t], typeof r != "undefined") return !1;
      });
    }
    return typeof r == "undefined" && (r = Kn[i]), l.rawCache[i] = r, r;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after != "undefined")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before != "undefined")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between != "undefined")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let r = i.parent;
      if (r && r !== e && r.parent && r.parent === e && typeof i.raws.before != "undefined") {
        let n = i.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], r = e.raws[t];
    return r && r.value === i ? r.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var fl = $s;
$s.default = $s;
let md = fl;
function qs(s, e) {
  new md(e).stringify(s);
}
var qi = qs;
qs.default = qs;
var Ot = {};
Ot.isClean = Symbol("isClean");
Ot.my = Symbol("my");
let fd = Hr, bd = fl, yd = qi, { isClean: gt, my: gd } = Ot;
function er(s, e) {
  let t = new s.constructor();
  for (let i in s) {
    if (!Object.prototype.hasOwnProperty.call(s, i) || i === "proxyCache") continue;
    let r = s[i], n = typeof r;
    i === "parent" && n === "object" ? e && (t[i] = e) : i === "source" ? t[i] = r : Array.isArray(r) ? t[i] = r.map((l) => er(l, t)) : (n === "object" && r !== null && (r = er(r)), t[i] = r);
  }
  return t;
}
let tr = class {
  constructor(e = {}) {
    this.raws = {}, this[gt] = !1, this[gd] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = er(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: r } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: r.column, line: r.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new fd(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[gt] = !0;
  }
  markDirty() {
    if (this[gt]) {
      this[gt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[gt] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, t) {
    let i = this.source.start;
    if (e.index)
      i = this.positionInside(e.index, t);
    else if (e.word) {
      t = this.toString();
      let r = t.indexOf(e.word);
      r !== -1 && (i = this.positionInside(r, t));
    }
    return i;
  }
  positionInside(e, t) {
    let i = t || this.toString(), r = this.source.start.column, n = this.source.start.line;
    for (let l = 0; l < e; l++)
      i[l] === `
` ? (r = 1, n += 1) : r += 1;
    return { column: r, line: n };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let t = {
      column: this.source.start.column,
      line: this.source.start.line
    }, i = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: t.column + 1,
      line: t.line
    };
    if (e.word) {
      let r = this.toString(), n = r.indexOf(e.word);
      n !== -1 && (t = this.positionInside(n, r), i = this.positionInside(
        n + e.word.length,
        r
      ));
    } else
      e.start ? t = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (t = this.positionInside(e.index)), e.end ? i = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? i = this.positionInside(e.endIndex) : e.index && (i = this.positionInside(e.index + 1));
    return (i.line < t.line || i.line === t.line && i.column <= t.column) && (i = { column: t.column + 1, line: t.line }), { end: i, start: t };
  }
  raw(e, t) {
    return new bd().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let r of e)
        r === this ? i = !0 : i ? (this.parent.insertAfter(t, r), t = r) : this.parent.insertBefore(t, r);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, r = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let l in this) {
      if (!Object.prototype.hasOwnProperty.call(this, l) || l === "parent" || l === "proxyCache") continue;
      let a = this[l];
      if (Array.isArray(a))
        i[l] = a.map((o) => typeof o == "object" && o.toJSON ? o.toJSON(null, t) : o);
      else if (typeof a == "object" && a.toJSON)
        i[l] = a.toJSON(null, t);
      else if (l === "source") {
        let o = t.get(a.input);
        o == null && (o = n, t.set(a.input, n), n++), i[l] = {
          end: a.end,
          inputId: o,
          start: a.start
        };
      } else
        i[l] = a;
    }
    return r && (i.inputs = [...t.keys()].map((l) => l.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = yd) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i) {
    let r = { node: this };
    for (let n in i) r[n] = i[n];
    return e.warn(t, r);
  }
  get proxyOf() {
    return this;
  }
};
var es = tr;
tr.default = tr;
let Zd = es, ir = class extends Zd {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var ts = ir;
ir.default = ir;
let Gd = es, sr = class extends Gd {
  constructor(e) {
    e && typeof e.value != "undefined" && typeof e.value != "string" && (e = se(X({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var is = sr;
sr.default = sr;
let bl = ts, yl = is, Id = es, { isClean: gl, my: Zl } = Ot, Mr, Gl, Il, zr;
function Sl(s) {
  return s.map((e) => (e.nodes && (e.nodes = Sl(e.nodes)), delete e.source, e));
}
function Vl(s) {
  if (s[gl] = !1, s.proxyOf.nodes)
    for (let e of s.proxyOf.nodes)
      Vl(e);
}
let Ne = class Wl extends Id {
  append(...e) {
    for (let t of e) {
      let i = this.normalize(t, this.last);
      for (let r of i) this.proxyOf.nodes.push(r);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), i, r;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (i = this.indexes[t], r = e(this.proxyOf.nodes[i], i), r !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], r;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...i) => e[t](
          ...i.map((r) => typeof r == "function" ? (n, l) => r(n.toProxy(), l) : r)
        ) : t === "every" || t === "some" ? (i) => e[t](
          (r, ...n) => i(r.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((i) => i.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let i = this.index(e), r = this.normalize(t, this.proxyOf.nodes[i]).reverse();
    i = this.index(e);
    for (let l of r) this.proxyOf.nodes.splice(i + 1, 0, l);
    let n;
    for (let l in this.indexes)
      n = this.indexes[l], i < n && (this.indexes[l] = n + r.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let i = this.index(e), r = i === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[i],
      r
    ).reverse();
    i = this.index(e);
    for (let a of n) this.proxyOf.nodes.splice(i, 0, a);
    let l;
    for (let a in this.indexes)
      l = this.indexes[a], i <= l && (this.indexes[a] = l + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = Sl(Gl(e).nodes);
    else if (typeof e == "undefined")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value == "undefined")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new yl(e)];
    } else if (e.selector || e.selectors)
      e = [new zr(e)];
    else if (e.name)
      e = [new Mr(e)];
    else if (e.text)
      e = [new bl(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((r) => (r[Zl] || Wl.rebuild(r), r = r.proxyOf, r.parent && r.parent.removeChild(r), r[gl] && Vl(r), r.raws || (r.raws = {}), typeof r.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (r.raws.before = t.raws.before.replace(/\S/g, "")), r.parent = this.proxyOf, r));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let i = this.normalize(t, this.first, "prepend").reverse();
      for (let r of i) this.proxyOf.nodes.unshift(r);
      for (let r in this.indexes)
        this.indexes[r] = this.indexes[r] + i.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let i in this.indexes)
      t = this.indexes[i], t >= e && (this.indexes[i] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, i) {
    return i || (i = t, t = {}), this.walkDecls((r) => {
      t.props && !t.props.includes(r.prop) || t.fast && !r.value.includes(t.fast) || (r.value = r.value.replace(e, i));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, i) => {
      let r;
      try {
        r = e(t, i);
      } catch (n) {
        throw t.addToError(n);
      }
      return r !== !1 && t.walk && (r = t.walk(e)), r;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "atrule" && e.test(i.name))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "atrule" && i.name === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "atrule")
        return t(i, r);
    }));
  }
  walkComments(e) {
    return this.walk((t, i) => {
      if (t.type === "comment")
        return e(t, i);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "decl" && e.test(i.prop))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "decl" && i.prop === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "decl")
        return t(i, r);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "rule" && e.test(i.selector))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "rule" && i.selector === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "rule")
        return t(i, r);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Ne.registerParse = (s) => {
  Gl = s;
};
Ne.registerRule = (s) => {
  zr = s;
};
Ne.registerAtRule = (s) => {
  Mr = s;
};
Ne.registerRoot = (s) => {
  Il = s;
};
var Be = Ne;
Ne.default = Ne;
Ne.rebuild = (s) => {
  s.type === "atrule" ? Object.setPrototypeOf(s, Mr.prototype) : s.type === "rule" ? Object.setPrototypeOf(s, zr.prototype) : s.type === "decl" ? Object.setPrototypeOf(s, yl.prototype) : s.type === "comment" ? Object.setPrototypeOf(s, bl.prototype) : s.type === "root" && Object.setPrototypeOf(s, Il.prototype), s[Zl] = !0, s.nodes && s.nodes.forEach((e) => {
    Ne.rebuild(e);
  });
};
let Xl = Be, Ji = class extends Xl {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var Or = Ji;
Ji.default = Ji;
Xl.registerAtRule(Ji);
let Sd = Be, Rl, wl, Nt = class extends Sd {
  constructor(e) {
    super(X({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new Rl(new wl(), this, e).stringify();
  }
};
Nt.registerLazyResult = (s) => {
  Rl = s;
};
Nt.registerProcessor = (s) => {
  wl = s;
};
var Er = Nt;
Nt.default = Nt;
let Vd = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Wd = (s, e = 21) => (t = e) => {
  let i = "", r = t;
  for (; r--; )
    i += s[Math.random() * s.length | 0];
  return i;
}, Xd = (s = 21) => {
  let e = "", t = s;
  for (; t--; )
    e += Vd[Math.random() * 64 | 0];
  return e;
};
var Rd = { nanoid: Xd, customAlphabet: Wd };
let { existsSync: wd, readFileSync: Cd } = Se, { dirname: vs, join: vd } = Se, { SourceMapConsumer: Hn, SourceMapGenerator: Mn } = Se;
function xd(s) {
  return Buffer ? Buffer.from(s, "base64").toString() : window.atob(s);
}
let rr = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, r = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = vs(this.mapFile)), r && (this.text = r);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Hn(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, r = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/, l = e.match(r) || e.match(n);
    if (l)
      return decodeURIComponent(e.substr(l[0].length));
    let a = e.match(t) || e.match(i);
    if (a)
      return xd(e.substr(a[0].length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), r = e.indexOf("*/", i);
    i > -1 && r > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, r)));
  }
  loadFile(e) {
    if (this.root = vs(e), wd(e))
      return this.mapFile = e, Cd(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let r = this.loadFile(i);
          if (!r)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return r;
        }
      } else {
        if (t instanceof Hn)
          return Mn.fromSourceMap(t).toString();
        if (t instanceof Mn)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = vd(vs(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var Cl = rr;
rr.default = rr;
let { nanoid: Ld } = Rd, { isAbsolute: nr, resolve: or } = Se, { SourceMapConsumer: Yd, SourceMapGenerator: Nd } = Se, { fileURLToPath: zn, pathToFileURL: ti } = Se, On = Hr, kd = Cl, xs = Se, Ls = Symbol("fromOffsetCache"), Td = !!(Yd && Nd), En = !!(or && nr), Ui = class {
  constructor(e, t = {}) {
    if (e === null || typeof e == "undefined" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!En || /^\w+:\/\//.test(t.from) || nr(t.from) ? this.file = t.from : this.file = or(t.from)), En && Td) {
      let i = new kd(this.css, t);
      if (i.text) {
        this.map = i;
        let r = i.consumer().file;
        !this.file && r && (this.file = this.mapResolve(r));
      }
    }
    this.file || (this.id = "<input css " + Ld(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, r = {}) {
    let n, l, a;
    if (t && typeof t == "object") {
      let c = t, u = i;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        t = d.line, i = d.col;
      } else
        t = c.line, i = c.column;
      if (typeof u.offset == "number") {
        let d = this.fromOffset(u.offset);
        l = d.line, n = d.col;
      } else
        l = u.line, n = u.column;
    } else if (!i) {
      let c = this.fromOffset(t);
      t = c.line, i = c.col;
    }
    let o = this.origin(t, i, l, n);
    return o ? a = new On(
      e,
      o.endLine === void 0 ? o.line : { column: o.column, line: o.line },
      o.endLine === void 0 ? o.column : { column: o.endColumn, line: o.endLine },
      o.source,
      o.file,
      r.plugin
    ) : a = new On(
      e,
      l === void 0 ? t : { column: i, line: t },
      l === void 0 ? i : { column: n, line: l },
      this.css,
      this.file,
      r.plugin
    ), a.input = { column: i, endColumn: n, endLine: l, line: t, source: this.css }, this.file && (ti && (a.input.url = ti(this.file).toString()), a.input.file = this.file), a;
  }
  fromOffset(e) {
    let t, i;
    if (this[Ls])
      i = this[Ls];
    else {
      let n = this.css.split(`
`);
      i = new Array(n.length);
      let l = 0;
      for (let a = 0, o = n.length; a < o; a++)
        i[a] = l, l += n[a].length + 1;
      this[Ls] = i;
    }
    t = i[i.length - 1];
    let r = 0;
    if (e >= t)
      r = i.length - 1;
    else {
      let n = i.length - 2, l;
      for (; r < n; )
        if (l = r + (n - r >> 1), e < i[l])
          n = l - 1;
        else if (e >= i[l + 1])
          r = l + 1;
        else {
          r = l;
          break;
        }
    }
    return {
      col: e - i[r] + 1,
      line: r + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : or(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, r) {
    if (!this.map) return !1;
    let n = this.map.consumer(), l = n.originalPositionFor({ column: t, line: e });
    if (!l.source) return !1;
    let a;
    typeof i == "number" && (a = n.originalPositionFor({ column: r, line: i }));
    let o;
    nr(l.source) ? o = ti(l.source) : o = new URL(
      l.source,
      this.map.consumer().sourceRoot || ti(this.map.mapFile)
    );
    let c = {
      column: l.column,
      endColumn: a && a.column,
      endLine: a && a.line,
      line: l.line,
      url: o.toString()
    };
    if (o.protocol === "file:")
      if (zn)
        c.file = zn(o);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let u = n.sourceContentFor(l.source);
    return u && (c.source = u), c;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = X({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var ss = Ui;
Ui.default = Ui;
xs && xs.registerInput && xs.registerInput(Ui);
let vl = Be, xl, Ll, ot = class extends vl {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let r = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of r)
          n.raws.before = t.raws.before;
    }
    return r;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new xl(new Ll(), this, e).stringify();
  }
};
ot.registerLazyResult = (s) => {
  xl = s;
};
ot.registerProcessor = (s) => {
  Ll = s;
};
var Et = ot;
ot.default = ot;
vl.registerRoot(ot);
let kt = {
  comma(s) {
    return kt.split(s, [","], !0);
  },
  space(s) {
    let e = [" ", `
`, "	"];
    return kt.split(s, e);
  },
  split(s, e, t) {
    let i = [], r = "", n = !1, l = 0, a = !1, o = "", c = !1;
    for (let u of s)
      c ? c = !1 : u === "\\" ? c = !0 : a ? u === o && (a = !1) : u === '"' || u === "'" ? (a = !0, o = u) : u === "(" ? l += 1 : u === ")" ? l > 0 && (l -= 1) : l === 0 && e.includes(u) && (n = !0), n ? (r !== "" && i.push(r.trim()), r = "", n = !1) : r += u;
    return (t || r !== "") && i.push(r.trim()), i;
  }
};
var Yl = kt;
kt.default = kt;
let Nl = Be, Jd = Yl, Fi = class extends Nl {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return Jd.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
};
var Pr = Fi;
Fi.default = Fi;
Nl.registerRule(Fi);
let Ud = Or, Fd = ts, Kd = is, Hd = ss, Md = Cl, zd = Et, Od = Pr;
function Tt(s, e) {
  if (Array.isArray(s)) return s.map((l) => Tt(l));
  let r = s, { inputs: t } = r, i = pe(r, ["inputs"]);
  if (t) {
    e = [];
    for (let l of t) {
      let a = se(X({}, l), { __proto__: Hd.prototype });
      a.map && (a.map = se(X({}, a.map), {
        __proto__: Md.prototype
      })), e.push(a);
    }
  }
  if (i.nodes && (i.nodes = s.nodes.map((l) => Tt(l, e))), i.source) {
    let n = i.source, { inputId: l } = n, a = pe(n, ["inputId"]);
    i.source = a, l != null && (i.source.input = e[l]);
  }
  if (i.type === "root")
    return new zd(i);
  if (i.type === "decl")
    return new Kd(i);
  if (i.type === "rule")
    return new Od(i);
  if (i.type === "comment")
    return new Fd(i);
  if (i.type === "atrule")
    return new Ud(i);
  throw new Error("Unknown node type: " + s.type);
}
var Ed = Tt;
Tt.default = Tt;
let { dirname: Xi, relative: kl, resolve: Tl, sep: Jl } = Se, { SourceMapConsumer: Ul, SourceMapGenerator: Ri } = Se, { pathToFileURL: Pn } = Se, Pd = ss, Bd = !!(Ul && Ri), Dd = !!(Xi && Tl && kl && Jl), Ad = class {
  constructor(e, t, i, r) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = r, this.originalCSS = r, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || Xi(e.file), r;
      this.mapOpts.sourcesContent === !1 ? (r = new Ul(e.text), r.sourcesContent && (r.sourcesContent = null)) : r = e.consumer(), this.map.applySourceMap(r, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), Dd && Bd && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Ri.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Ri({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Ri({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", r = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, l;
    this.stringify(this.root, (a, o, c) => {
      if (this.css += a, o && c !== "end" && (r.generated.line = e, r.generated.column = t - 1, o.source && o.source.start ? (r.source = this.sourcePath(o), r.original.line = o.source.start.line, r.original.column = o.source.start.column - 1, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, this.map.addMapping(r))), l = a.match(/\n/g), l ? (e += l.length, n = a.lastIndexOf(`
`), t = a.length - n) : t += a.length, o && c !== "start") {
        let u = o.parent || { raws: {} };
        (!(o.type === "decl" || o.type === "atrule" && !o.nodes) || o !== u.last || u.raws.semicolon) && (o.source && o.source.end ? (r.source = this.sourcePath(o), r.original.line = o.source.end.line, r.original.column = o.source.end.column - 1, r.generated.line = e, r.generated.column = t - 2, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, r.generated.line = e, r.generated.column = t - 1, this.map.addMapping(r)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation != "undefined" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline != "undefined")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e != "undefined" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map != "undefined" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent != "undefined" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? Xi(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = Xi(Tl(i, this.mapOpts.annotation)));
    let r = kl(i, e);
    return this.memoizedPaths.set(e, r), r;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new Pd(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let r = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(r, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (Pn) {
      let i = Pn(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Jl === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var Fl = Ad;
const Ys = 39, Bn = 34, ii = 92, Dn = 47, si = 10, Zt = 32, ri = 12, ni = 9, oi = 13, jd = 91, Qd = 93, _d = 40, $d = 41, qd = 123, eh = 125, th = 59, ih = 42, sh = 58, rh = 64, li = /[\t\n\f\r "#'()/;[\\\]{}]/g, ai = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, nh = /.[\r\n"'(/\\]/, An = /[\da-f]/i;
var oh = function(e, t = {}) {
  let i = e.css.valueOf(), r = t.ignoreErrors, n, l, a, o, c, u, d, h, p, y, f = i.length, m = 0, W = [], S = [];
  function g() {
    return m;
  }
  function Z(R) {
    throw e.error("Unclosed " + R, m);
  }
  function C() {
    return S.length === 0 && m >= f;
  }
  function J(R) {
    if (S.length) return S.pop();
    if (m >= f) return;
    let F = R ? R.ignoreUnclosed : !1;
    switch (n = i.charCodeAt(m), n) {
      case si:
      case Zt:
      case ni:
      case oi:
      case ri: {
        o = m;
        do
          o += 1, n = i.charCodeAt(o);
        while (n === Zt || n === si || n === ni || n === oi || n === ri);
        u = ["space", i.slice(m, o)], m = o - 1;
        break;
      }
      case jd:
      case Qd:
      case qd:
      case eh:
      case sh:
      case th:
      case $d: {
        let v = String.fromCharCode(n);
        u = [v, v, m];
        break;
      }
      case _d: {
        if (y = W.length ? W.pop()[1] : "", p = i.charCodeAt(m + 1), y === "url" && p !== Ys && p !== Bn && p !== Zt && p !== si && p !== ni && p !== ri && p !== oi) {
          o = m;
          do {
            if (d = !1, o = i.indexOf(")", o + 1), o === -1)
              if (r || F) {
                o = m;
                break;
              } else
                Z("bracket");
            for (h = o; i.charCodeAt(h - 1) === ii; )
              h -= 1, d = !d;
          } while (d);
          u = ["brackets", i.slice(m, o + 1), m, o], m = o;
        } else
          o = i.indexOf(")", m + 1), l = i.slice(m, o + 1), o === -1 || nh.test(l) ? u = ["(", "(", m] : (u = ["brackets", l, m, o], m = o);
        break;
      }
      case Ys:
      case Bn: {
        c = n === Ys ? "'" : '"', o = m;
        do {
          if (d = !1, o = i.indexOf(c, o + 1), o === -1)
            if (r || F) {
              o = m + 1;
              break;
            } else
              Z("string");
          for (h = o; i.charCodeAt(h - 1) === ii; )
            h -= 1, d = !d;
        } while (d);
        u = ["string", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      case rh: {
        li.lastIndex = m + 1, li.test(i), li.lastIndex === 0 ? o = i.length - 1 : o = li.lastIndex - 2, u = ["at-word", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      case ii: {
        for (o = m, a = !0; i.charCodeAt(o + 1) === ii; )
          o += 1, a = !a;
        if (n = i.charCodeAt(o + 1), a && n !== Dn && n !== Zt && n !== si && n !== ni && n !== oi && n !== ri && (o += 1, An.test(i.charAt(o)))) {
          for (; An.test(i.charAt(o + 1)); )
            o += 1;
          i.charCodeAt(o + 1) === Zt && (o += 1);
        }
        u = ["word", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      default: {
        n === Dn && i.charCodeAt(m + 1) === ih ? (o = i.indexOf("*/", m + 2) + 1, o === 0 && (r || F ? o = i.length : Z("comment")), u = ["comment", i.slice(m, o + 1), m, o], m = o) : (ai.lastIndex = m + 1, ai.test(i), ai.lastIndex === 0 ? o = i.length - 1 : o = ai.lastIndex - 2, u = ["word", i.slice(m, o + 1), m, o], W.push(u), m = o);
        break;
      }
    }
    return m++, u;
  }
  function V(R) {
    S.push(R);
  }
  return {
    back: V,
    endOfFile: C,
    nextToken: J,
    position: g
  };
};
let lh = Or, ah = ts, ch = is, uh = Et, jn = Pr, dh = oh;
const Qn = {
  empty: !0,
  space: !0
};
function hh(s) {
  for (let e = s.length - 1; e >= 0; e--) {
    let t = s[e], i = t[3] || t[2];
    if (i) return i;
  }
}
let ph = class {
  constructor(e) {
    this.input = e, this.root = new uh(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new lh();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, r, n, l = !1, a = !1, o = [], c = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? c.push(i === "(" ? ")" : "]") : i === "{" && c.length > 0 ? c.push("}") : i === c[c.length - 1] && c.pop(), c.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          a = !0;
          break;
        } else if (i === "}") {
          if (o.length > 0) {
            for (n = o.length - 1, r = o[n]; r && r[0] === "space"; )
              r = o[--n];
            r && (t.source.end = this.getPosition(r[3] || r[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          o.push(e);
      else
        o.push(e);
      if (this.tokenizer.endOfFile()) {
        l = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(o), o.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(o), this.raw(t, "params", o), l && (e = o[o.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), a && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, r;
    for (let n = t - 1; n >= 0 && (r = e[n], !(r[0] !== "space" && (i += 1, i === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      r[0] === "word" ? r[3] + 1 : r[2]
    );
  }
  colon(e) {
    let t = 0, i, r, n;
    for (let [l, a] of e.entries()) {
      if (r = a, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":")
        if (!i)
          this.doubleColon(r);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return l;
        }
      i = r;
    }
    return !1;
  }
  comment(e) {
    let t = new ah();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let r = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = r[2], t.raws.left = r[1], t.raws.right = r[3];
    }
  }
  createTokenizer() {
    this.tokenizer = dh(this.input);
  }
  decl(e, t) {
    let i = new ch();
    this.init(i, e[0][2]);
    let r = e[e.length - 1];
    for (r[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      r[3] || r[2] || hh(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let c = e[0][0];
      if (c === ":" || c === "space" || c === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        i.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), i.raws.between += n[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let l = [], a;
    for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment")); )
      l.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let c = e.length - 1; c >= 0; c--) {
      if (n = e[c], n[1].toLowerCase() === "!important") {
        i.important = !0;
        let u = this.stringFrom(e, c);
        u = this.spacesFromEnd(e) + u, u !== " !important" && (i.raws.important = u);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let u = e.slice(0), d = "";
        for (let h = c; h > 0; h--) {
          let p = u[h][0];
          if (d.trim().startsWith("!") && p !== "space")
            break;
          d = u.pop()[1] + d;
        }
        d.trim().startsWith("!") && (i.important = !0, i.raws.important = d, e = u);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((c) => c[0] !== "space" && c[0] !== "comment") && (i.raws.between += l.map((c) => c[1]).join(""), l = []), this.raw(i, "value", l.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new jn();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, r = !1, n = null, l = [], a = e[1].startsWith("--"), o = [], c = e;
    for (; c; ) {
      if (i = c[0], o.push(c), i === "(" || i === "[")
        n || (n = c), l.push(i === "(" ? ")" : "]");
      else if (a && r && i === "{")
        n || (n = c), l.push("}");
      else if (l.length === 0)
        if (i === ";")
          if (r) {
            this.decl(o, a);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(o);
          return;
        } else if (i === "}") {
          this.tokenizer.back(o.pop()), t = !0;
          break;
        } else i === ":" && (r = !0);
      else i === l[l.length - 1] && (l.pop(), l.length === 0 && (n = null));
      c = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), l.length > 0 && this.unclosedBracket(n), t && r) {
      if (!a)
        for (; o.length && (c = o[o.length - 1][0], !(c !== "space" && c !== "comment")); )
          this.tokenizer.back(o.pop());
      this.decl(o, a);
    } else
      this.unknownWord(o);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, r) {
    let n, l, a = i.length, o = "", c = !0, u, d;
    for (let h = 0; h < a; h += 1)
      n = i[h], l = n[0], l === "space" && h === a - 1 && !r ? c = !1 : l === "comment" ? (d = i[h - 1] ? i[h - 1][0] : "empty", u = i[h + 1] ? i[h + 1][0] : "empty", !Qn[d] && !Qn[u] ? o.slice(-1) === "," ? c = !1 : o += n[1] : c = !1) : o += n[1];
    if (!c) {
      let h = i.reduce((p, y) => p + y[1], "");
      e.raws[t] = { raw: h, value: o };
    }
    e[t] = o;
  }
  rule(e) {
    e.pop();
    let t = new jn();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let r = t; r < e.length; r++)
      i += e[r][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var mh = ph;
let fh = Be, bh = ss, yh = mh;
function Ki(s, e) {
  let t = new bh(s, e), i = new yh(t);
  try {
    i.parse();
  } catch (r) {
    throw process.env.NODE_ENV !== "production" && r.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? r.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? r.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (r.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), r;
  }
  return i.root;
}
var Br = Ki;
Ki.default = Ki;
fh.registerParse(Ki);
let lr = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Kl = lr;
lr.default = lr;
let gh = Kl, ar = class {
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new gh(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var Dr = ar;
ar.default = ar;
let _n = {};
var Hl = function(e) {
  _n[e] || (_n[e] = !0, typeof console != "undefined" && console.warn && console.warn(e));
};
let Zh = Be, Gh = Er, Ih = Fl, Sh = Br, $n = Dr, Vh = Et, Wh = qi, { isClean: Re, my: Xh } = Ot, Rh = Hl;
const wh = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, Ch = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, vh = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, lt = 0;
function Gt(s) {
  return typeof s == "object" && typeof s.then == "function";
}
function Ml(s) {
  let e = !1, t = wh[s.type];
  return s.type === "decl" ? e = s.prop.toLowerCase() : s.type === "atrule" && (e = s.name.toLowerCase()), e && s.append ? [
    t,
    t + "-" + e,
    lt,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : s.append ? [t, lt, t + "Exit"] : [t, t + "Exit"];
}
function qn(s) {
  let e;
  return s.type === "document" ? e = ["Document", lt, "DocumentExit"] : s.type === "root" ? e = ["Root", lt, "RootExit"] : e = Ml(s), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: s,
    visitorIndex: 0,
    visitors: []
  };
}
function cr(s) {
  return s[Re] = !1, s.nodes && s.nodes.forEach((e) => cr(e)), s;
}
let ur = {}, at = class zl {
  constructor(e, t, i) {
    this.stringified = !1, this.processed = !1;
    let r;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      r = cr(t);
    else if (t instanceof zl || t instanceof $n)
      r = cr(t.root), t.map && (typeof i.map == "undefined" && (i.map = {}), i.map.inline || (i.map.inline = !1), i.map.prev = t.map);
    else {
      let n = Sh;
      i.syntax && (n = i.syntax.parse), i.parser && (n = i.parser), n.parse && (n = n.parse);
      try {
        r = n(t, i);
      } catch (l) {
        this.processed = !0, this.error = l;
      }
      r && !r[Xh] && Zh.rebuild(r);
    }
    this.result = new $n(e, r, i), this.helpers = se(X({}, ur), { postcss: ur, result: this.result }), this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? X(X({}, n), n.prepare(this.result)) : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let i = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = i.postcssPlugin, e.setMessage();
      else if (i.postcssVersion && process.env.NODE_ENV !== "production") {
        let r = i.postcssPlugin, n = i.postcssVersion, l = this.result.processor.version, a = n.split("."), o = l.split(".");
        (a[0] !== o[0] || parseInt(a[1]) > parseInt(o[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + l + ", but " + r + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (r) {
      console && console.error && console.error(r);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, i, r) => {
      this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push([t, r]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let i in t) {
          if (!Ch[i] && /^[A-Z]/.test(i))
            throw new Error(
              `Unknown event ${i} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!vh[i])
            if (typeof t[i] == "object")
              for (let r in t[i])
                r === "*" ? e(t, i, t[i][r]) : e(
                  t,
                  i + "-" + r.toLowerCase(),
                  t[i][r]
                );
            else typeof t[i] == "function" && e(t, i, t[i]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return ee(this, null, function* () {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let t = this.plugins[e], i = this.runOnRoot(t);
        if (Gt(i))
          try {
            yield i;
          } catch (r) {
            throw this.handleError(r);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[Re]; ) {
          e[Re] = !0;
          let t = [qn(e)];
          for (; t.length > 0; ) {
            let i = this.visitTick(t);
            if (Gt(i))
              try {
                yield i;
              } catch (r) {
                let n = t[t.length - 1].node;
                throw this.handleError(r, n);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [t, i] of this.listeners.OnceExit) {
            this.result.lastPlugin = t;
            try {
              if (e.type === "document") {
                let r = e.nodes.map(
                  (n) => i(n, this.helpers)
                );
                yield Promise.all(r);
              } else
                yield i(e, this.helpers);
            } catch (r) {
              throw this.handleError(r);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (i) => e.Once(i, this.helpers)
          );
          return Gt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = Wh;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let r = new Ih(t, this.result.root, this.result.opts).generate();
    return this.result.css = r[0], this.result.map = r[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (Gt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Re]; )
        e[Re] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || Rh(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [i, r] of e) {
      this.result.lastPlugin = i;
      let n;
      try {
        n = r(t, this.helpers);
      } catch (l) {
        throw this.handleError(l, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (Gt(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: i, visitors: r } = t;
    if (i.type !== "root" && i.type !== "document" && !i.parent) {
      e.pop();
      return;
    }
    if (r.length > 0 && t.visitorIndex < r.length) {
      let [l, a] = r[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === r.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = l;
      try {
        return a(i.toProxy(), this.helpers);
      } catch (o) {
        throw this.handleError(o, i);
      }
    }
    if (t.iterator !== 0) {
      let l = t.iterator, a;
      for (; a = i.nodes[i.indexes[l]]; )
        if (i.indexes[l] += 1, !a[Re]) {
          a[Re] = !0, e.push(qn(a));
          return;
        }
      t.iterator = 0, delete i.indexes[l];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let l = n[t.eventIndex];
      if (t.eventIndex += 1, l === lt) {
        i.nodes && i.nodes.length && (i[Re] = !0, t.iterator = i.getIterator());
        return;
      } else if (this.listeners[l]) {
        t.visitors = this.listeners[l];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Re] = !0;
    let t = Ml(e);
    for (let i of t)
      if (i === lt)
        e.nodes && e.each((r) => {
          r[Re] || this.walkSync(r);
        });
      else {
        let r = this.listeners[i];
        if (r && this.visitSync(r, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
at.registerPostcss = (s) => {
  ur = s;
};
var Ol = at;
at.default = at;
Vh.registerLazyResult(at);
Gh.registerLazyResult(at);
let xh = Fl, Lh = Br;
const Yh = Dr;
let Nh = qi, kh = Hl, dr = class {
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let r, n = Nh;
    this.result = new Yh(this._processor, r, this._opts), this.result.css = t;
    let l = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return l.root;
      }
    });
    let a = new xh(n, r, this._opts, t);
    if (a.isMap()) {
      let [o, c] = a.generate();
      o && (this.result.css = o), c && (this.result.map = c);
    } else
      a.clearAnnotation(), this.result.css = a.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || kh(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = Lh;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var Th = dr;
dr.default = dr;
let Jh = Er, Uh = Ol, Fh = Th, Kh = Et, Jt = class {
  constructor(e = []) {
    this.version = "8.4.47", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new Fh(this, e, t) : new Uh(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var Hh = Jt;
Jt.default = Jt;
Kh.registerProcessor(Jt);
Jh.registerProcessor(Jt);
let El = Or, Pl = ts, Mh = Be, zh = Hr, Bl = is, Dl = Er, Oh = Ed, Eh = ss, Ph = Ol, Bh = Yl, Dh = es, Ah = Br, Ar = Hh, jh = Dr, Al = Et, jl = Pr, Qh = qi, _h = Kl;
function B(...s) {
  return s.length === 1 && Array.isArray(s[0]) && (s = s[0]), new Ar(s);
}
B.plugin = function(e, t) {
  let i = !1;
  function r(...l) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let a = t(...l);
    return a.postcssPlugin = e, a.postcssVersion = new Ar().version, a;
  }
  let n;
  return Object.defineProperty(r, "postcss", {
    get() {
      return n || (n = r()), n;
    }
  }), r.process = function(l, a, o) {
    return B([r(o)]).process(l, a);
  }, r;
};
B.stringify = Qh;
B.parse = Ah;
B.fromJSON = Oh;
B.list = Bh;
B.comment = (s) => new Pl(s);
B.atRule = (s) => new El(s);
B.decl = (s) => new Bl(s);
B.rule = (s) => new jl(s);
B.root = (s) => new Al(s);
B.document = (s) => new Dl(s);
B.CssSyntaxError = zh;
B.Declaration = Bl;
B.Container = Mh;
B.Processor = Ar;
B.Document = Dl;
B.Comment = Pl;
B.Warning = _h;
B.AtRule = El;
B.Result = jh;
B.Input = Eh;
B.Rule = jl;
B.Root = Al;
B.Node = Dh;
Ph.registerPostcss(B);
B.default = B;
var $h = Object.defineProperty, qh = (s, e, t) => e in s ? $h(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, me = (s, e, t) => qh(s, typeof e != "symbol" ? e + "" : e, t);
function ep(s) {
  if (s.__esModule) return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(s, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return s[i];
      }
    });
  }), t;
}
var jr = { exports: {} }, T = String, Ql = function() {
  return { isColorSupported: !1, reset: T, bold: T, dim: T, italic: T, underline: T, inverse: T, hidden: T, strikethrough: T, black: T, red: T, green: T, yellow: T, blue: T, magenta: T, cyan: T, white: T, gray: T, bgBlack: T, bgRed: T, bgGreen: T, bgYellow: T, bgBlue: T, bgMagenta: T, bgCyan: T, bgWhite: T, blackBright: T, redBright: T, greenBright: T, yellowBright: T, blueBright: T, magentaBright: T, cyanBright: T, whiteBright: T, bgBlackBright: T, bgRedBright: T, bgGreenBright: T, bgYellowBright: T, bgBlueBright: T, bgMagentaBright: T, bgCyanBright: T, bgWhiteBright: T };
};
jr.exports = Ql();
jr.exports.createColors = Ql;
var tp = jr.exports;
const ip = {}, sp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ip
}, Symbol.toStringTag, { value: "Module" })), Ve = /* @__PURE__ */ ep(sp);
let eo = tp, to = Ve, hr = class _l extends Error {
  constructor(e, t, i, r, n, l) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), r && (this.source = r), l && (this.plugin = l), typeof t != "undefined" && typeof i != "undefined" && (typeof t == "number" ? (this.line = t, this.column = i) : (this.line = t.line, this.column = t.column, this.endLine = i.line, this.endColumn = i.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, _l);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = eo.isColorSupported);
    let i = (u) => u, r = (u) => u, n = (u) => u;
    if (e) {
      let { bold: u, gray: d, red: h } = eo.createColors(!0);
      r = (p) => u(h(p)), i = (p) => d(p), to && (n = (p) => to(p));
    }
    let l = t.split(/\r?\n/), a = Math.max(this.line - 3, 0), o = Math.min(this.line + 2, l.length), c = String(o).length;
    return l.slice(a, o).map((u, d) => {
      let h = a + 1 + d, p = " " + (" " + h).slice(-c) + " | ";
      if (h === this.line) {
        if (u.length > 160) {
          let f = 20, m = Math.max(0, this.column - f), W = Math.max(
            this.column + f,
            this.endColumn + f
          ), S = u.slice(m, W), g = i(p.replace(/\d/g, " ")) + u.slice(0, Math.min(this.column - 1, f - 1)).replace(/[^\t]/g, " ");
          return r(">") + i(p) + n(S) + `
 ` + g + r("^");
        }
        let y = i(p.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return r(">") + i(p) + n(u) + `
 ` + y + r("^");
      }
      return " " + i(p) + n(u);
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Qr = hr;
hr.default = hr;
const io = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function rp(s) {
  return s[0].toUpperCase() + s.slice(1);
}
let pr = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, r = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName != "undefined" ? i += e.raws.afterName : r && (i += " "), e.nodes)
      this.block(e, i + r);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + r + n, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let r = e.parent, n = 0;
    for (; r && r.type !== "root"; )
      n += 1, r = r.parent;
    if (i.includes(`
`)) {
      let l = this.raw(e, null, "indent");
      if (l.length)
        for (let a = 0; a < n; a++) i += l;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let r;
    e.nodes && e.nodes.length ? (this.body(e), r = this.raw(e, "after")) : r = this.raw(e, "after", "emptyBody"), r && this.builder(r), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let r = 0; r < e.nodes.length; r++) {
      let n = e.nodes[r], l = this.raw(n, "before");
      l && this.builder(l), this.stringify(n, t !== r || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), r = e.prop + i + this.rawValue(e, "value");
    e.important && (r += e.raws.important || " !important"), t && (r += ";"), this.builder(r, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let r;
    if (i || (i = t), t && (r = e.raws[t], typeof r != "undefined"))
      return r;
    let n = e.parent;
    if (i === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return io[i];
    let l = e.root();
    if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[i] != "undefined")
      return l.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let a = "raw" + rp(i);
      this[a] ? r = this[a](l, e) : l.walk((o) => {
        if (r = o.raws[t], typeof r != "undefined") return !1;
      });
    }
    return typeof r == "undefined" && (r = io[i]), l.rawCache[i] = r, r;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after != "undefined")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before != "undefined")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between != "undefined")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let r = i.parent;
      if (r && r !== e && r.parent && r.parent === e && typeof i.raws.before != "undefined") {
        let n = i.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], r = e.raws[t];
    return r && r.value === i ? r.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var $l = pr;
pr.default = pr;
let np = $l;
function mr(s, e) {
  new np(e).stringify(s);
}
var rs = mr;
mr.default = mr;
var Pt = {};
Pt.isClean = Symbol("isClean");
Pt.my = Symbol("my");
let op = Qr, lp = $l, ap = rs, { isClean: It, my: cp } = Pt;
function fr(s, e) {
  let t = new s.constructor();
  for (let i in s) {
    if (!Object.prototype.hasOwnProperty.call(s, i) || i === "proxyCache") continue;
    let r = s[i], n = typeof r;
    i === "parent" && n === "object" ? e && (t[i] = e) : i === "source" ? t[i] = r : Array.isArray(r) ? t[i] = r.map((l) => fr(l, t)) : (n === "object" && r !== null && (r = fr(r)), t[i] = r);
  }
  return t;
}
let br = class {
  constructor(e = {}) {
    this.raws = {}, this[It] = !1, this[cp] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = fr(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: r } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: r.column, line: r.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new op(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[It] = !0;
  }
  markDirty() {
    if (this[It]) {
      this[It] = !1;
      let e = this;
      for (; e = e.parent; )
        e[It] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, t) {
    let i = this.source.start;
    if (e.index)
      i = this.positionInside(e.index, t);
    else if (e.word) {
      t = this.toString();
      let r = t.indexOf(e.word);
      r !== -1 && (i = this.positionInside(r, t));
    }
    return i;
  }
  positionInside(e, t) {
    let i = t || this.toString(), r = this.source.start.column, n = this.source.start.line;
    for (let l = 0; l < e; l++)
      i[l] === `
` ? (r = 1, n += 1) : r += 1;
    return { column: r, line: n };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let t = {
      column: this.source.start.column,
      line: this.source.start.line
    }, i = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: t.column + 1,
      line: t.line
    };
    if (e.word) {
      let r = this.toString(), n = r.indexOf(e.word);
      n !== -1 && (t = this.positionInside(n, r), i = this.positionInside(
        n + e.word.length,
        r
      ));
    } else
      e.start ? t = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (t = this.positionInside(e.index)), e.end ? i = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? i = this.positionInside(e.endIndex) : e.index && (i = this.positionInside(e.index + 1));
    return (i.line < t.line || i.line === t.line && i.column <= t.column) && (i = { column: t.column + 1, line: t.line }), { end: i, start: t };
  }
  raw(e, t) {
    return new lp().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let r of e)
        r === this ? i = !0 : i ? (this.parent.insertAfter(t, r), t = r) : this.parent.insertBefore(t, r);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, r = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let l in this) {
      if (!Object.prototype.hasOwnProperty.call(this, l) || l === "parent" || l === "proxyCache") continue;
      let a = this[l];
      if (Array.isArray(a))
        i[l] = a.map((o) => typeof o == "object" && o.toJSON ? o.toJSON(null, t) : o);
      else if (typeof a == "object" && a.toJSON)
        i[l] = a.toJSON(null, t);
      else if (l === "source") {
        let o = t.get(a.input);
        o == null && (o = n, t.set(a.input, n), n++), i[l] = {
          end: a.end,
          inputId: o,
          start: a.start
        };
      } else
        i[l] = a;
    }
    return r && (i.inputs = [...t.keys()].map((l) => l.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = ap) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i) {
    let r = { node: this };
    for (let n in i) r[n] = i[n];
    return e.warn(t, r);
  }
  get proxyOf() {
    return this;
  }
};
var ns = br;
br.default = br;
let up = ns, yr = class extends up {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var os = yr;
yr.default = yr;
let dp = ns, gr = class extends dp {
  constructor(e) {
    e && typeof e.value != "undefined" && typeof e.value != "string" && (e = se(X({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var ls = gr;
gr.default = gr;
let ql = os, ea = ls, hp = ns, { isClean: ta, my: ia } = Pt, _r, sa, ra, $r;
function na(s) {
  return s.map((e) => (e.nodes && (e.nodes = na(e.nodes)), delete e.source, e));
}
function oa(s) {
  if (s[ta] = !1, s.proxyOf.nodes)
    for (let e of s.proxyOf.nodes)
      oa(e);
}
let ke = class la extends hp {
  append(...e) {
    for (let t of e) {
      let i = this.normalize(t, this.last);
      for (let r of i) this.proxyOf.nodes.push(r);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), i, r;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (i = this.indexes[t], r = e(this.proxyOf.nodes[i], i), r !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], r;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...i) => e[t](
          ...i.map((r) => typeof r == "function" ? (n, l) => r(n.toProxy(), l) : r)
        ) : t === "every" || t === "some" ? (i) => e[t](
          (r, ...n) => i(r.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((i) => i.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let i = this.index(e), r = this.normalize(t, this.proxyOf.nodes[i]).reverse();
    i = this.index(e);
    for (let l of r) this.proxyOf.nodes.splice(i + 1, 0, l);
    let n;
    for (let l in this.indexes)
      n = this.indexes[l], i < n && (this.indexes[l] = n + r.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let i = this.index(e), r = i === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[i],
      r
    ).reverse();
    i = this.index(e);
    for (let a of n) this.proxyOf.nodes.splice(i, 0, a);
    let l;
    for (let a in this.indexes)
      l = this.indexes[a], i <= l && (this.indexes[a] = l + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = na(sa(e).nodes);
    else if (typeof e == "undefined")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value == "undefined")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new ea(e)];
    } else if (e.selector || e.selectors)
      e = [new $r(e)];
    else if (e.name)
      e = [new _r(e)];
    else if (e.text)
      e = [new ql(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((r) => (r[ia] || la.rebuild(r), r = r.proxyOf, r.parent && r.parent.removeChild(r), r[ta] && oa(r), r.raws || (r.raws = {}), typeof r.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (r.raws.before = t.raws.before.replace(/\S/g, "")), r.parent = this.proxyOf, r));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let i = this.normalize(t, this.first, "prepend").reverse();
      for (let r of i) this.proxyOf.nodes.unshift(r);
      for (let r in this.indexes)
        this.indexes[r] = this.indexes[r] + i.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let i in this.indexes)
      t = this.indexes[i], t >= e && (this.indexes[i] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, i) {
    return i || (i = t, t = {}), this.walkDecls((r) => {
      t.props && !t.props.includes(r.prop) || t.fast && !r.value.includes(t.fast) || (r.value = r.value.replace(e, i));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, i) => {
      let r;
      try {
        r = e(t, i);
      } catch (n) {
        throw t.addToError(n);
      }
      return r !== !1 && t.walk && (r = t.walk(e)), r;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "atrule" && e.test(i.name))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "atrule" && i.name === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "atrule")
        return t(i, r);
    }));
  }
  walkComments(e) {
    return this.walk((t, i) => {
      if (t.type === "comment")
        return e(t, i);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "decl" && e.test(i.prop))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "decl" && i.prop === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "decl")
        return t(i, r);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "rule" && e.test(i.selector))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "rule" && i.selector === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "rule")
        return t(i, r);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
ke.registerParse = (s) => {
  sa = s;
};
ke.registerRule = (s) => {
  $r = s;
};
ke.registerAtRule = (s) => {
  _r = s;
};
ke.registerRoot = (s) => {
  ra = s;
};
var De = ke;
ke.default = ke;
ke.rebuild = (s) => {
  s.type === "atrule" ? Object.setPrototypeOf(s, _r.prototype) : s.type === "rule" ? Object.setPrototypeOf(s, $r.prototype) : s.type === "decl" ? Object.setPrototypeOf(s, ea.prototype) : s.type === "comment" ? Object.setPrototypeOf(s, ql.prototype) : s.type === "root" && Object.setPrototypeOf(s, ra.prototype), s[ia] = !0, s.nodes && s.nodes.forEach((e) => {
    ke.rebuild(e);
  });
};
let aa = De, Hi = class extends aa {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var qr = Hi;
Hi.default = Hi;
aa.registerAtRule(Hi);
let pp = De, ca, ua, Ut = class extends pp {
  constructor(e) {
    super(X({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new ca(new ua(), this, e).stringify();
  }
};
Ut.registerLazyResult = (s) => {
  ca = s;
};
Ut.registerProcessor = (s) => {
  ua = s;
};
var en = Ut;
Ut.default = Ut;
let mp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", fp = (s, e = 21) => (t = e) => {
  let i = "", r = t;
  for (; r--; )
    i += s[Math.random() * s.length | 0];
  return i;
}, bp = (s = 21) => {
  let e = "", t = s;
  for (; t--; )
    e += mp[Math.random() * 64 | 0];
  return e;
};
var yp = { nanoid: bp, customAlphabet: fp };
let { existsSync: gp, readFileSync: Zp } = Ve, { dirname: Ns, join: Gp } = Ve, { SourceMapConsumer: so, SourceMapGenerator: ro } = Ve;
function Ip(s) {
  return Buffer ? Buffer.from(s, "base64").toString() : window.atob(s);
}
let Zr = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, r = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = Ns(this.mapFile)), r && (this.text = r);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new so(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, r = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/, l = e.match(r) || e.match(n);
    if (l)
      return decodeURIComponent(e.substr(l[0].length));
    let a = e.match(t) || e.match(i);
    if (a)
      return Ip(e.substr(a[0].length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), r = e.indexOf("*/", i);
    i > -1 && r > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, r)));
  }
  loadFile(e) {
    if (this.root = Ns(e), gp(e))
      return this.mapFile = e, Zp(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let r = this.loadFile(i);
          if (!r)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return r;
        }
      } else {
        if (t instanceof so)
          return ro.fromSourceMap(t).toString();
        if (t instanceof ro)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = Gp(Ns(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var da = Zr;
Zr.default = Zr;
let { nanoid: Sp } = yp, { isAbsolute: Gr, resolve: Ir } = Ve, { SourceMapConsumer: Vp, SourceMapGenerator: Wp } = Ve, { fileURLToPath: no, pathToFileURL: ci } = Ve, oo = Qr, Xp = da, ks = Ve, Ts = Symbol("fromOffsetCache"), Rp = !!(Vp && Wp), lo = !!(Ir && Gr), Mi = class {
  constructor(e, t = {}) {
    if (e === null || typeof e == "undefined" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!lo || /^\w+:\/\//.test(t.from) || Gr(t.from) ? this.file = t.from : this.file = Ir(t.from)), lo && Rp) {
      let i = new Xp(this.css, t);
      if (i.text) {
        this.map = i;
        let r = i.consumer().file;
        !this.file && r && (this.file = this.mapResolve(r));
      }
    }
    this.file || (this.id = "<input css " + Sp(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, r = {}) {
    let n, l, a;
    if (t && typeof t == "object") {
      let c = t, u = i;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        t = d.line, i = d.col;
      } else
        t = c.line, i = c.column;
      if (typeof u.offset == "number") {
        let d = this.fromOffset(u.offset);
        l = d.line, n = d.col;
      } else
        l = u.line, n = u.column;
    } else if (!i) {
      let c = this.fromOffset(t);
      t = c.line, i = c.col;
    }
    let o = this.origin(t, i, l, n);
    return o ? a = new oo(
      e,
      o.endLine === void 0 ? o.line : { column: o.column, line: o.line },
      o.endLine === void 0 ? o.column : { column: o.endColumn, line: o.endLine },
      o.source,
      o.file,
      r.plugin
    ) : a = new oo(
      e,
      l === void 0 ? t : { column: i, line: t },
      l === void 0 ? i : { column: n, line: l },
      this.css,
      this.file,
      r.plugin
    ), a.input = { column: i, endColumn: n, endLine: l, line: t, source: this.css }, this.file && (ci && (a.input.url = ci(this.file).toString()), a.input.file = this.file), a;
  }
  fromOffset(e) {
    let t, i;
    if (this[Ts])
      i = this[Ts];
    else {
      let n = this.css.split(`
`);
      i = new Array(n.length);
      let l = 0;
      for (let a = 0, o = n.length; a < o; a++)
        i[a] = l, l += n[a].length + 1;
      this[Ts] = i;
    }
    t = i[i.length - 1];
    let r = 0;
    if (e >= t)
      r = i.length - 1;
    else {
      let n = i.length - 2, l;
      for (; r < n; )
        if (l = r + (n - r >> 1), e < i[l])
          n = l - 1;
        else if (e >= i[l + 1])
          r = l + 1;
        else {
          r = l;
          break;
        }
    }
    return {
      col: e - i[r] + 1,
      line: r + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Ir(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, r) {
    if (!this.map) return !1;
    let n = this.map.consumer(), l = n.originalPositionFor({ column: t, line: e });
    if (!l.source) return !1;
    let a;
    typeof i == "number" && (a = n.originalPositionFor({ column: r, line: i }));
    let o;
    Gr(l.source) ? o = ci(l.source) : o = new URL(
      l.source,
      this.map.consumer().sourceRoot || ci(this.map.mapFile)
    );
    let c = {
      column: l.column,
      endColumn: a && a.column,
      endLine: a && a.line,
      line: l.line,
      url: o.toString()
    };
    if (o.protocol === "file:")
      if (no)
        c.file = no(o);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let u = n.sourceContentFor(l.source);
    return u && (c.source = u), c;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = X({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var as = Mi;
Mi.default = Mi;
ks && ks.registerInput && ks.registerInput(Mi);
let ha = De, pa, ma, ct = class extends ha {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let r = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of r)
          n.raws.before = t.raws.before;
    }
    return r;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new pa(new ma(), this, e).stringify();
  }
};
ct.registerLazyResult = (s) => {
  pa = s;
};
ct.registerProcessor = (s) => {
  ma = s;
};
var Bt = ct;
ct.default = ct;
ha.registerRoot(ct);
let Ft = {
  comma(s) {
    return Ft.split(s, [","], !0);
  },
  space(s) {
    let e = [" ", `
`, "	"];
    return Ft.split(s, e);
  },
  split(s, e, t) {
    let i = [], r = "", n = !1, l = 0, a = !1, o = "", c = !1;
    for (let u of s)
      c ? c = !1 : u === "\\" ? c = !0 : a ? u === o && (a = !1) : u === '"' || u === "'" ? (a = !0, o = u) : u === "(" ? l += 1 : u === ")" ? l > 0 && (l -= 1) : l === 0 && e.includes(u) && (n = !0), n ? (r !== "" && i.push(r.trim()), r = "", n = !1) : r += u;
    return (t || r !== "") && i.push(r.trim()), i;
  }
};
var fa = Ft;
Ft.default = Ft;
let ba = De, wp = fa, zi = class extends ba {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return wp.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
};
var tn = zi;
zi.default = zi;
ba.registerRule(zi);
let Cp = qr, vp = os, xp = ls, Lp = as, Yp = da, Np = Bt, kp = tn;
function Kt(s, e) {
  if (Array.isArray(s)) return s.map((l) => Kt(l));
  let r = s, { inputs: t } = r, i = pe(r, ["inputs"]);
  if (t) {
    e = [];
    for (let l of t) {
      let a = se(X({}, l), { __proto__: Lp.prototype });
      a.map && (a.map = se(X({}, a.map), {
        __proto__: Yp.prototype
      })), e.push(a);
    }
  }
  if (i.nodes && (i.nodes = s.nodes.map((l) => Kt(l, e))), i.source) {
    let n = i.source, { inputId: l } = n, a = pe(n, ["inputId"]);
    i.source = a, l != null && (i.source.input = e[l]);
  }
  if (i.type === "root")
    return new Np(i);
  if (i.type === "decl")
    return new xp(i);
  if (i.type === "rule")
    return new kp(i);
  if (i.type === "comment")
    return new vp(i);
  if (i.type === "atrule")
    return new Cp(i);
  throw new Error("Unknown node type: " + s.type);
}
var Tp = Kt;
Kt.default = Kt;
let { dirname: wi, relative: ya, resolve: ga, sep: Za } = Ve, { SourceMapConsumer: Ga, SourceMapGenerator: Ci } = Ve, { pathToFileURL: ao } = Ve, Jp = as, Up = !!(Ga && Ci), Fp = !!(wi && ga && ya && Za), Kp = class {
  constructor(e, t, i, r) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = r, this.originalCSS = r, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || wi(e.file), r;
      this.mapOpts.sourcesContent === !1 ? (r = new Ga(e.text), r.sourcesContent && (r.sourcesContent = null)) : r = e.consumer(), this.map.applySourceMap(r, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), Fp && Up && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Ci.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Ci({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Ci({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", r = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, l;
    this.stringify(this.root, (a, o, c) => {
      if (this.css += a, o && c !== "end" && (r.generated.line = e, r.generated.column = t - 1, o.source && o.source.start ? (r.source = this.sourcePath(o), r.original.line = o.source.start.line, r.original.column = o.source.start.column - 1, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, this.map.addMapping(r))), l = a.match(/\n/g), l ? (e += l.length, n = a.lastIndexOf(`
`), t = a.length - n) : t += a.length, o && c !== "start") {
        let u = o.parent || { raws: {} };
        (!(o.type === "decl" || o.type === "atrule" && !o.nodes) || o !== u.last || u.raws.semicolon) && (o.source && o.source.end ? (r.source = this.sourcePath(o), r.original.line = o.source.end.line, r.original.column = o.source.end.column - 1, r.generated.line = e, r.generated.column = t - 2, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, r.generated.line = e, r.generated.column = t - 1, this.map.addMapping(r)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation != "undefined" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline != "undefined")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e != "undefined" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map != "undefined" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent != "undefined" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? wi(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = wi(ga(i, this.mapOpts.annotation)));
    let r = ya(i, e);
    return this.memoizedPaths.set(e, r), r;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new Jp(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let r = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(r, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (ao) {
      let i = ao(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Za === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var Ia = Kp;
const Js = 39, co = 34, ui = 92, uo = 47, di = 10, St = 32, hi = 12, pi = 9, mi = 13, Hp = 91, Mp = 93, zp = 40, Op = 41, Ep = 123, Pp = 125, Bp = 59, Dp = 42, Ap = 58, jp = 64, fi = /[\t\n\f\r "#'()/;[\\\]{}]/g, bi = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Qp = /.[\r\n"'(/\\]/, ho = /[\da-f]/i;
var _p = function(e, t = {}) {
  let i = e.css.valueOf(), r = t.ignoreErrors, n, l, a, o, c, u, d, h, p, y, f = i.length, m = 0, W = [], S = [];
  function g() {
    return m;
  }
  function Z(R) {
    throw e.error("Unclosed " + R, m);
  }
  function C() {
    return S.length === 0 && m >= f;
  }
  function J(R) {
    if (S.length) return S.pop();
    if (m >= f) return;
    let F = R ? R.ignoreUnclosed : !1;
    switch (n = i.charCodeAt(m), n) {
      case di:
      case St:
      case pi:
      case mi:
      case hi: {
        o = m;
        do
          o += 1, n = i.charCodeAt(o);
        while (n === St || n === di || n === pi || n === mi || n === hi);
        u = ["space", i.slice(m, o)], m = o - 1;
        break;
      }
      case Hp:
      case Mp:
      case Ep:
      case Pp:
      case Ap:
      case Bp:
      case Op: {
        let v = String.fromCharCode(n);
        u = [v, v, m];
        break;
      }
      case zp: {
        if (y = W.length ? W.pop()[1] : "", p = i.charCodeAt(m + 1), y === "url" && p !== Js && p !== co && p !== St && p !== di && p !== pi && p !== hi && p !== mi) {
          o = m;
          do {
            if (d = !1, o = i.indexOf(")", o + 1), o === -1)
              if (r || F) {
                o = m;
                break;
              } else
                Z("bracket");
            for (h = o; i.charCodeAt(h - 1) === ui; )
              h -= 1, d = !d;
          } while (d);
          u = ["brackets", i.slice(m, o + 1), m, o], m = o;
        } else
          o = i.indexOf(")", m + 1), l = i.slice(m, o + 1), o === -1 || Qp.test(l) ? u = ["(", "(", m] : (u = ["brackets", l, m, o], m = o);
        break;
      }
      case Js:
      case co: {
        c = n === Js ? "'" : '"', o = m;
        do {
          if (d = !1, o = i.indexOf(c, o + 1), o === -1)
            if (r || F) {
              o = m + 1;
              break;
            } else
              Z("string");
          for (h = o; i.charCodeAt(h - 1) === ui; )
            h -= 1, d = !d;
        } while (d);
        u = ["string", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      case jp: {
        fi.lastIndex = m + 1, fi.test(i), fi.lastIndex === 0 ? o = i.length - 1 : o = fi.lastIndex - 2, u = ["at-word", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      case ui: {
        for (o = m, a = !0; i.charCodeAt(o + 1) === ui; )
          o += 1, a = !a;
        if (n = i.charCodeAt(o + 1), a && n !== uo && n !== St && n !== di && n !== pi && n !== mi && n !== hi && (o += 1, ho.test(i.charAt(o)))) {
          for (; ho.test(i.charAt(o + 1)); )
            o += 1;
          i.charCodeAt(o + 1) === St && (o += 1);
        }
        u = ["word", i.slice(m, o + 1), m, o], m = o;
        break;
      }
      default: {
        n === uo && i.charCodeAt(m + 1) === Dp ? (o = i.indexOf("*/", m + 2) + 1, o === 0 && (r || F ? o = i.length : Z("comment")), u = ["comment", i.slice(m, o + 1), m, o], m = o) : (bi.lastIndex = m + 1, bi.test(i), bi.lastIndex === 0 ? o = i.length - 1 : o = bi.lastIndex - 2, u = ["word", i.slice(m, o + 1), m, o], W.push(u), m = o);
        break;
      }
    }
    return m++, u;
  }
  function V(R) {
    S.push(R);
  }
  return {
    back: V,
    endOfFile: C,
    nextToken: J,
    position: g
  };
};
let $p = qr, qp = os, em = ls, tm = Bt, po = tn, im = _p;
const mo = {
  empty: !0,
  space: !0
};
function sm(s) {
  for (let e = s.length - 1; e >= 0; e--) {
    let t = s[e], i = t[3] || t[2];
    if (i) return i;
  }
}
let rm = class {
  constructor(e) {
    this.input = e, this.root = new tm(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new $p();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, r, n, l = !1, a = !1, o = [], c = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? c.push(i === "(" ? ")" : "]") : i === "{" && c.length > 0 ? c.push("}") : i === c[c.length - 1] && c.pop(), c.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          a = !0;
          break;
        } else if (i === "}") {
          if (o.length > 0) {
            for (n = o.length - 1, r = o[n]; r && r[0] === "space"; )
              r = o[--n];
            r && (t.source.end = this.getPosition(r[3] || r[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          o.push(e);
      else
        o.push(e);
      if (this.tokenizer.endOfFile()) {
        l = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(o), o.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(o), this.raw(t, "params", o), l && (e = o[o.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), a && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, r;
    for (let n = t - 1; n >= 0 && (r = e[n], !(r[0] !== "space" && (i += 1, i === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      r[0] === "word" ? r[3] + 1 : r[2]
    );
  }
  colon(e) {
    let t = 0, i, r, n;
    for (let [l, a] of e.entries()) {
      if (r = a, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":")
        if (!i)
          this.doubleColon(r);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return l;
        }
      i = r;
    }
    return !1;
  }
  comment(e) {
    let t = new qp();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let r = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = r[2], t.raws.left = r[1], t.raws.right = r[3];
    }
  }
  createTokenizer() {
    this.tokenizer = im(this.input);
  }
  decl(e, t) {
    let i = new em();
    this.init(i, e[0][2]);
    let r = e[e.length - 1];
    for (r[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      r[3] || r[2] || sm(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let c = e[0][0];
      if (c === ":" || c === "space" || c === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        i.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), i.raws.between += n[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let l = [], a;
    for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment")); )
      l.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let c = e.length - 1; c >= 0; c--) {
      if (n = e[c], n[1].toLowerCase() === "!important") {
        i.important = !0;
        let u = this.stringFrom(e, c);
        u = this.spacesFromEnd(e) + u, u !== " !important" && (i.raws.important = u);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let u = e.slice(0), d = "";
        for (let h = c; h > 0; h--) {
          let p = u[h][0];
          if (d.trim().startsWith("!") && p !== "space")
            break;
          d = u.pop()[1] + d;
        }
        d.trim().startsWith("!") && (i.important = !0, i.raws.important = d, e = u);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((c) => c[0] !== "space" && c[0] !== "comment") && (i.raws.between += l.map((c) => c[1]).join(""), l = []), this.raw(i, "value", l.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new po();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, r = !1, n = null, l = [], a = e[1].startsWith("--"), o = [], c = e;
    for (; c; ) {
      if (i = c[0], o.push(c), i === "(" || i === "[")
        n || (n = c), l.push(i === "(" ? ")" : "]");
      else if (a && r && i === "{")
        n || (n = c), l.push("}");
      else if (l.length === 0)
        if (i === ";")
          if (r) {
            this.decl(o, a);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(o);
          return;
        } else if (i === "}") {
          this.tokenizer.back(o.pop()), t = !0;
          break;
        } else i === ":" && (r = !0);
      else i === l[l.length - 1] && (l.pop(), l.length === 0 && (n = null));
      c = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), l.length > 0 && this.unclosedBracket(n), t && r) {
      if (!a)
        for (; o.length && (c = o[o.length - 1][0], !(c !== "space" && c !== "comment")); )
          this.tokenizer.back(o.pop());
      this.decl(o, a);
    } else
      this.unknownWord(o);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, r) {
    let n, l, a = i.length, o = "", c = !0, u, d;
    for (let h = 0; h < a; h += 1)
      n = i[h], l = n[0], l === "space" && h === a - 1 && !r ? c = !1 : l === "comment" ? (d = i[h - 1] ? i[h - 1][0] : "empty", u = i[h + 1] ? i[h + 1][0] : "empty", !mo[d] && !mo[u] ? o.slice(-1) === "," ? c = !1 : o += n[1] : c = !1) : o += n[1];
    if (!c) {
      let h = i.reduce((p, y) => p + y[1], "");
      e.raws[t] = { raw: h, value: o };
    }
    e[t] = o;
  }
  rule(e) {
    e.pop();
    let t = new po();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let r = t; r < e.length; r++)
      i += e[r][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var nm = rm;
let om = De, lm = as, am = nm;
function Oi(s, e) {
  let t = new lm(s, e), i = new am(t);
  try {
    i.parse();
  } catch (r) {
    throw process.env.NODE_ENV !== "production" && r.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? r.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? r.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (r.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), r;
  }
  return i.root;
}
var sn = Oi;
Oi.default = Oi;
om.registerParse(Oi);
let Sr = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Sa = Sr;
Sr.default = Sr;
let cm = Sa, Vr = class {
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new cm(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var rn = Vr;
Vr.default = Vr;
let fo = {};
var Va = function(e) {
  fo[e] || (fo[e] = !0, typeof console != "undefined" && console.warn && console.warn(e));
};
let um = De, dm = en, hm = Ia, pm = sn, bo = rn, mm = Bt, fm = rs, { isClean: we, my: bm } = Pt, ym = Va;
const gm = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, Zm = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, Gm = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, ut = 0;
function Vt(s) {
  return typeof s == "object" && typeof s.then == "function";
}
function Wa(s) {
  let e = !1, t = gm[s.type];
  return s.type === "decl" ? e = s.prop.toLowerCase() : s.type === "atrule" && (e = s.name.toLowerCase()), e && s.append ? [
    t,
    t + "-" + e,
    ut,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : s.append ? [t, ut, t + "Exit"] : [t, t + "Exit"];
}
function yo(s) {
  let e;
  return s.type === "document" ? e = ["Document", ut, "DocumentExit"] : s.type === "root" ? e = ["Root", ut, "RootExit"] : e = Wa(s), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: s,
    visitorIndex: 0,
    visitors: []
  };
}
function Wr(s) {
  return s[we] = !1, s.nodes && s.nodes.forEach((e) => Wr(e)), s;
}
let Xr = {}, dt = class Xa {
  constructor(e, t, i) {
    this.stringified = !1, this.processed = !1;
    let r;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      r = Wr(t);
    else if (t instanceof Xa || t instanceof bo)
      r = Wr(t.root), t.map && (typeof i.map == "undefined" && (i.map = {}), i.map.inline || (i.map.inline = !1), i.map.prev = t.map);
    else {
      let n = pm;
      i.syntax && (n = i.syntax.parse), i.parser && (n = i.parser), n.parse && (n = n.parse);
      try {
        r = n(t, i);
      } catch (l) {
        this.processed = !0, this.error = l;
      }
      r && !r[bm] && um.rebuild(r);
    }
    this.result = new bo(e, r, i), this.helpers = se(X({}, Xr), { postcss: Xr, result: this.result }), this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? X(X({}, n), n.prepare(this.result)) : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let i = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = i.postcssPlugin, e.setMessage();
      else if (i.postcssVersion && process.env.NODE_ENV !== "production") {
        let r = i.postcssPlugin, n = i.postcssVersion, l = this.result.processor.version, a = n.split("."), o = l.split(".");
        (a[0] !== o[0] || parseInt(a[1]) > parseInt(o[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + l + ", but " + r + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (r) {
      console && console.error && console.error(r);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, i, r) => {
      this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push([t, r]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let i in t) {
          if (!Zm[i] && /^[A-Z]/.test(i))
            throw new Error(
              `Unknown event ${i} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!Gm[i])
            if (typeof t[i] == "object")
              for (let r in t[i])
                r === "*" ? e(t, i, t[i][r]) : e(
                  t,
                  i + "-" + r.toLowerCase(),
                  t[i][r]
                );
            else typeof t[i] == "function" && e(t, i, t[i]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return ee(this, null, function* () {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let t = this.plugins[e], i = this.runOnRoot(t);
        if (Vt(i))
          try {
            yield i;
          } catch (r) {
            throw this.handleError(r);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[we]; ) {
          e[we] = !0;
          let t = [yo(e)];
          for (; t.length > 0; ) {
            let i = this.visitTick(t);
            if (Vt(i))
              try {
                yield i;
              } catch (r) {
                let n = t[t.length - 1].node;
                throw this.handleError(r, n);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [t, i] of this.listeners.OnceExit) {
            this.result.lastPlugin = t;
            try {
              if (e.type === "document") {
                let r = e.nodes.map(
                  (n) => i(n, this.helpers)
                );
                yield Promise.all(r);
              } else
                yield i(e, this.helpers);
            } catch (r) {
              throw this.handleError(r);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (i) => e.Once(i, this.helpers)
          );
          return Vt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = fm;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let r = new hm(t, this.result.root, this.result.opts).generate();
    return this.result.css = r[0], this.result.map = r[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (Vt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[we]; )
        e[we] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || ym(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [i, r] of e) {
      this.result.lastPlugin = i;
      let n;
      try {
        n = r(t, this.helpers);
      } catch (l) {
        throw this.handleError(l, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (Vt(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: i, visitors: r } = t;
    if (i.type !== "root" && i.type !== "document" && !i.parent) {
      e.pop();
      return;
    }
    if (r.length > 0 && t.visitorIndex < r.length) {
      let [l, a] = r[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === r.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = l;
      try {
        return a(i.toProxy(), this.helpers);
      } catch (o) {
        throw this.handleError(o, i);
      }
    }
    if (t.iterator !== 0) {
      let l = t.iterator, a;
      for (; a = i.nodes[i.indexes[l]]; )
        if (i.indexes[l] += 1, !a[we]) {
          a[we] = !0, e.push(yo(a));
          return;
        }
      t.iterator = 0, delete i.indexes[l];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let l = n[t.eventIndex];
      if (t.eventIndex += 1, l === ut) {
        i.nodes && i.nodes.length && (i[we] = !0, t.iterator = i.getIterator());
        return;
      } else if (this.listeners[l]) {
        t.visitors = this.listeners[l];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[we] = !0;
    let t = Wa(e);
    for (let i of t)
      if (i === ut)
        e.nodes && e.each((r) => {
          r[we] || this.walkSync(r);
        });
      else {
        let r = this.listeners[i];
        if (r && this.visitSync(r, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
dt.registerPostcss = (s) => {
  Xr = s;
};
var Ra = dt;
dt.default = dt;
mm.registerLazyResult(dt);
dm.registerLazyResult(dt);
let Im = Ia, Sm = sn;
const Vm = rn;
let Wm = rs, Xm = Va, Rr = class {
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let r, n = Wm;
    this.result = new Vm(this._processor, r, this._opts), this.result.css = t;
    let l = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return l.root;
      }
    });
    let a = new Im(n, r, this._opts, t);
    if (a.isMap()) {
      let [o, c] = a.generate();
      o && (this.result.css = o), c && (this.result.map = c);
    } else
      a.clearAnnotation(), this.result.css = a.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || Xm(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = Sm;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var Rm = Rr;
Rr.default = Rr;
let wm = en, Cm = Ra, vm = Rm, xm = Bt, Ht = class {
  constructor(e = []) {
    this.version = "8.4.47", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new vm(this, e, t) : new Cm(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var Lm = Ht;
Ht.default = Ht;
xm.registerProcessor(Ht);
wm.registerProcessor(Ht);
let wa = qr, Ca = os, Ym = De, Nm = Qr, va = ls, xa = en, km = Tp, Tm = as, Jm = Ra, Um = fa, Fm = ns, Km = sn, nn = Lm, Hm = rn, La = Bt, Ya = tn, Mm = rs, zm = Sa;
function D(...s) {
  return s.length === 1 && Array.isArray(s[0]) && (s = s[0]), new nn(s);
}
D.plugin = function(e, t) {
  let i = !1;
  function r(...l) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let a = t(...l);
    return a.postcssPlugin = e, a.postcssVersion = new nn().version, a;
  }
  let n;
  return Object.defineProperty(r, "postcss", {
    get() {
      return n || (n = r()), n;
    }
  }), r.process = function(l, a, o) {
    return D([r(o)]).process(l, a);
  }, r;
};
D.stringify = Mm;
D.parse = Km;
D.fromJSON = km;
D.list = Um;
D.comment = (s) => new Ca(s);
D.atRule = (s) => new wa(s);
D.decl = (s) => new va(s);
D.rule = (s) => new Ya(s);
D.root = (s) => new La(s);
D.document = (s) => new xa(s);
D.CssSyntaxError = Nm;
D.Declaration = va;
D.Container = Ym;
D.Processor = nn;
D.Document = xa;
D.Comment = Ca;
D.Warning = zm;
D.AtRule = wa;
D.Result = Hm;
D.Input = Tm;
D.Rule = Ya;
D.Root = La;
D.Node = Fm;
Jm.registerPostcss(D);
D.default = D;
class on {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(...e) {
    me(this, "parentElement", null), me(this, "parentNode", null), me(this, "ownerDocument"), me(this, "firstChild", null), me(this, "lastChild", null), me(this, "previousSibling", null), me(this, "nextSibling", null), me(this, "ELEMENT_NODE", 1), me(this, "TEXT_NODE", 3), me(this, "nodeType"), me(this, "nodeName"), me(this, "RRNodeType");
  }
  get childNodes() {
    const e = [];
    let t = this.firstChild;
    for (; t; )
      e.push(t), t = t.nextSibling;
    return e;
  }
  contains(e) {
    if (e instanceof on) {
      if (e.ownerDocument !== this.ownerDocument) return !1;
      if (e === this) return !0;
    } else return !1;
    for (; e.parentNode; ) {
      if (e.parentNode === this) return !0;
      e = e.parentNode;
    }
    return !1;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(e) {
    throw new Error(
      "RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(e, t) {
    throw new Error(
      "RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(e) {
    throw new Error(
      "RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  toString() {
    return "RRNode";
  }
}
const go = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, Zo = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, yi = {};
function ln(s) {
  if (yi[s])
    return yi[s];
  const e = globalThis[s], t = e.prototype, i = s in go ? go[s] : void 0, r = !!(i && // @ts-expect-error 2345
  i.every(
    (a) => {
      var o, c;
      return !!((c = (o = Object.getOwnPropertyDescriptor(t, a)) == null ? void 0 : o.get) != null && c.toString().includes("[native code]"));
    }
  )), n = s in Zo ? Zo[s] : void 0, l = !!(n && n.every(
    // @ts-expect-error 2345
    (a) => {
      var o;
      return typeof t[a] == "function" && ((o = t[a]) == null ? void 0 : o.toString().includes("[native code]"));
    }
  ));
  if (r && l)
    return yi[s] = e.prototype, e.prototype;
  try {
    const a = document.createElement("iframe");
    document.body.appendChild(a);
    const o = a.contentWindow;
    if (!o) return e.prototype;
    const c = o[s].prototype;
    return document.body.removeChild(a), c ? yi[s] = c : t;
  } catch (a) {
    return t;
  }
}
const Us = {};
function Me(s, e, t) {
  var i;
  const r = `${s}.${String(t)}`;
  if (Us[r])
    return Us[r].call(
      e
    );
  const n = ln(s), l = (i = Object.getOwnPropertyDescriptor(
    n,
    t
  )) == null ? void 0 : i.get;
  return l ? (Us[r] = l, l.call(e)) : e[t];
}
const Fs = {};
function Na(s, e, t) {
  const i = `${s}.${String(t)}`;
  if (Fs[i])
    return Fs[i].bind(
      e
    );
  const n = ln(s)[t];
  return typeof n != "function" ? e[t] : (Fs[i] = n, n.bind(e));
}
function Om(s) {
  return Me("Node", s, "childNodes");
}
function Em(s) {
  return Me("Node", s, "parentNode");
}
function Pm(s) {
  return Me("Node", s, "parentElement");
}
function Bm(s) {
  return Me("Node", s, "textContent");
}
function Dm(s, e) {
  return Na("Node", s, "contains")(e);
}
function Am(s) {
  return Na("Node", s, "getRootNode")();
}
function jm(s) {
  return !s || !("host" in s) ? null : Me("ShadowRoot", s, "host");
}
function Qm(s) {
  return s.styleSheets;
}
function _m(s) {
  return !s || !("shadowRoot" in s) ? null : Me("Element", s, "shadowRoot");
}
function $m(s, e) {
  return Me("Element", s, "querySelector")(e);
}
function qm(s, e) {
  return Me("Element", s, "querySelectorAll")(e);
}
function ka() {
  return ln("MutationObserver").constructor;
}
const H = {
  childNodes: Om,
  parentNode: Em,
  parentElement: Pm,
  textContent: Bm,
  contains: Dm,
  getRootNode: Am,
  host: jm,
  styleSheets: Qm,
  shadowRoot: _m,
  querySelector: $m,
  querySelectorAll: qm,
  mutationObserver: ka
};
function ue(s, e, t = document) {
  const i = { capture: !0 };
  return t.addEventListener(s, e, i), () => t.removeEventListener(s, e, i);
}
const qe = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let Go = {
  map: {},
  getId() {
    return console.error(qe), -1;
  },
  getNode() {
    return console.error(qe), null;
  },
  removeNodeFromMap() {
    console.error(qe);
  },
  has() {
    return console.error(qe), !1;
  },
  reset() {
    console.error(qe);
  }
};
typeof window != "undefined" && window.Proxy && window.Reflect && (Go = new Proxy(Go, {
  get(s, e, t) {
    return e === "map" && console.error(qe), Reflect.get(s, e, t);
  }
}));
function Mt(s, e, t = {}) {
  let i = null, r = 0;
  return function(...n) {
    const l = Date.now();
    !r && t.leading === !1 && (r = l);
    const a = e - (l - r), o = this;
    a <= 0 || a > e ? (i && (clearTimeout(i), i = null), r = l, s.apply(o, n)) : !i && t.trailing !== !1 && (i = setTimeout(() => {
      r = t.leading === !1 ? 0 : Date.now(), i = null, s.apply(o, n);
    }, a));
  };
}
function cs(s, e, t, i, r = window) {
  const n = r.Object.getOwnPropertyDescriptor(s, e);
  return r.Object.defineProperty(
    s,
    e,
    i ? t : {
      set(l) {
        setTimeout(() => {
          t.set.call(this, l);
        }, 0), n && n.set && n.set.call(this, l);
      }
    }
  ), () => cs(s, e, n || {}, !0);
}
function pt(s, e, t) {
  try {
    if (!(e in s))
      return () => {
      };
    const i = s[e], r = t(i);
    return typeof r == "function" && (r.prototype = r.prototype || {}, Object.defineProperties(r, {
      __rrweb_original__: {
        enumerable: !1,
        value: i
      }
    })), s[e] = r, () => {
      s[e] = i;
    };
  } catch (i) {
    return () => {
    };
  }
}
let Ei = Date.now;
/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString()) || (Ei = () => (/* @__PURE__ */ new Date()).getTime());
function Ta(s) {
  var e, t, i, r;
  const n = s.document;
  return {
    left: n.scrollingElement ? n.scrollingElement.scrollLeft : s.pageXOffset !== void 0 ? s.pageXOffset : n.documentElement.scrollLeft || (n == null ? void 0 : n.body) && ((e = H.parentElement(n.body)) == null ? void 0 : e.scrollLeft) || ((t = n == null ? void 0 : n.body) == null ? void 0 : t.scrollLeft) || 0,
    top: n.scrollingElement ? n.scrollingElement.scrollTop : s.pageYOffset !== void 0 ? s.pageYOffset : (n == null ? void 0 : n.documentElement.scrollTop) || (n == null ? void 0 : n.body) && ((i = H.parentElement(n.body)) == null ? void 0 : i.scrollTop) || ((r = n == null ? void 0 : n.body) == null ? void 0 : r.scrollTop) || 0
  };
}
function Ja() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function Ua() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function Fa(s) {
  return s ? s.nodeType === s.ELEMENT_NODE ? s : H.parentElement(s) : null;
}
const ef = (s) => {
  try {
    if (s instanceof HTMLElement)
      return s.tagName === "CANVAS";
  } catch (e) {
    return !1;
  }
  return !1;
};
function oe(s, e, t, i) {
  if (!s)
    return !1;
  const r = Fa(s);
  if (!r)
    return !1;
  try {
    if (typeof e == "string") {
      if (r.classList.contains(e) || i && r.closest("." + e) !== null) return !0;
    } else if (Ti(r, e, i)) return !0;
  } catch (n) {
  }
  return !!(t && (r.matches(t) || i && r.closest(t) !== null));
}
function tf(s, e) {
  return e.getId(s) !== -1;
}
function Ks(s, e, t) {
  return s.tagName === "TITLE" && t.headTitleMutations ? !0 : e.getId(s) === Yt;
}
function Ka(s, e) {
  if (wt(s))
    return !1;
  const t = e.getId(s);
  if (!e.has(t))
    return !0;
  const i = H.parentNode(s);
  return i && i.nodeType === s.DOCUMENT_NODE ? !1 : i ? Ka(i, e) : !0;
}
function wr(s) {
  return !!s.changedTouches;
}
function sf(s = window) {
  "NodeList" in s && !s.NodeList.prototype.forEach && (s.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in s && !s.DOMTokenList.prototype.forEach && (s.DOMTokenList.prototype.forEach = Array.prototype.forEach);
}
function Ha(s, e) {
  return !!(s.nodeName === "IFRAME" && e.getMeta(s));
}
function Ma(s, e) {
  return !!(s.nodeName === "LINK" && s.nodeType === s.ELEMENT_NODE && s.getAttribute && s.getAttribute("rel") === "stylesheet" && e.getMeta(s));
}
function Cr(s) {
  return s ? s instanceof on && "shadowRoot" in s ? !!s.shadowRoot : !!H.shadowRoot(s) : !1;
}
class rf {
  constructor() {
    I(this, "id", 1), I(this, "styleIDMap", /* @__PURE__ */ new WeakMap()), I(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(e) {
    var t;
    return (t = this.styleIDMap.get(e)) != null ? t : -1;
  }
  has(e) {
    return this.styleIDMap.has(e);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(e, t) {
    if (this.has(e)) return this.getId(e);
    let i;
    return t === void 0 ? i = this.id++ : i = t, this.styleIDMap.set(e, i), this.idStyleMap.set(i, e), i;
  }
  getStyle(e) {
    return this.idStyleMap.get(e) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map(), this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function za(s) {
  var e;
  let t = null;
  return "getRootNode" in s && ((e = H.getRootNode(s)) == null ? void 0 : e.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && H.host(H.getRootNode(s)) && (t = H.host(H.getRootNode(s))), t;
}
function nf(s) {
  let e = s, t;
  for (; t = za(e); )
    e = t;
  return e;
}
function of(s) {
  const e = s.ownerDocument;
  if (!e) return !1;
  const t = nf(s);
  return H.contains(e, t);
}
function Oa(s) {
  const e = s.ownerDocument;
  return e ? H.contains(e, s) || of(s) : !1;
}
var O = /* @__PURE__ */ ((s) => (s[s.DomContentLoaded = 0] = "DomContentLoaded", s[s.Load = 1] = "Load", s[s.FullSnapshot = 2] = "FullSnapshot", s[s.IncrementalSnapshot = 3] = "IncrementalSnapshot", s[s.Meta = 4] = "Meta", s[s.Custom = 5] = "Custom", s[s.Plugin = 6] = "Plugin", s))(O || {}), M = /* @__PURE__ */ ((s) => (s[s.Mutation = 0] = "Mutation", s[s.MouseMove = 1] = "MouseMove", s[s.MouseInteraction = 2] = "MouseInteraction", s[s.Scroll = 3] = "Scroll", s[s.ViewportResize = 4] = "ViewportResize", s[s.Input = 5] = "Input", s[s.TouchMove = 6] = "TouchMove", s[s.MediaInteraction = 7] = "MediaInteraction", s[s.StyleSheetRule = 8] = "StyleSheetRule", s[s.CanvasMutation = 9] = "CanvasMutation", s[s.Font = 10] = "Font", s[s.Log = 11] = "Log", s[s.Drag = 12] = "Drag", s[s.StyleDeclaration = 13] = "StyleDeclaration", s[s.Selection = 14] = "Selection", s[s.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", s[s.CustomElement = 16] = "CustomElement", s))(M || {}), de = /* @__PURE__ */ ((s) => (s[s.MouseUp = 0] = "MouseUp", s[s.MouseDown = 1] = "MouseDown", s[s.Click = 2] = "Click", s[s.ContextMenu = 3] = "ContextMenu", s[s.DblClick = 4] = "DblClick", s[s.Focus = 5] = "Focus", s[s.Blur = 6] = "Blur", s[s.TouchStart = 7] = "TouchStart", s[s.TouchMove_Departed = 8] = "TouchMove_Departed", s[s.TouchEnd = 9] = "TouchEnd", s[s.TouchCancel = 10] = "TouchCancel", s))(de || {}), Te = /* @__PURE__ */ ((s) => (s[s.Mouse = 0] = "Mouse", s[s.Pen = 1] = "Pen", s[s.Touch = 2] = "Touch", s))(Te || {}), ht = /* @__PURE__ */ ((s) => (s[s["2D"] = 0] = "2D", s[s.WebGL = 1] = "WebGL", s[s.WebGL2 = 2] = "WebGL2", s))(ht || {}), et = /* @__PURE__ */ ((s) => (s[s.Play = 0] = "Play", s[s.Pause = 1] = "Pause", s[s.Seeked = 2] = "Seeked", s[s.VolumeChange = 3] = "VolumeChange", s[s.RateChange = 4] = "RateChange", s))(et || {});
function Io(s) {
  return "__ln" in s;
}
class lf {
  constructor() {
    I(this, "length", 0), I(this, "head", null), I(this, "tail", null);
  }
  get(e) {
    if (e >= this.length)
      throw new Error("Position outside of list range");
    let t = this.head;
    for (let i = 0; i < e; i++)
      t = (t == null ? void 0 : t.next) || null;
    return t;
  }
  addNode(e) {
    const t = {
      value: e,
      previous: null,
      next: null
    };
    if (e.__ln = t, e.previousSibling && Io(e.previousSibling)) {
      const i = e.previousSibling.__ln.next;
      t.next = i, t.previous = e.previousSibling.__ln, e.previousSibling.__ln.next = t, i && (i.previous = t);
    } else if (e.nextSibling && Io(e.nextSibling) && e.nextSibling.__ln.previous) {
      const i = e.nextSibling.__ln.previous;
      t.previous = i, t.next = e.nextSibling.__ln, e.nextSibling.__ln.previous = t, i && (i.next = t);
    } else
      this.head && (this.head.previous = t), t.next = this.head, this.head = t;
    t.next === null && (this.tail = t), this.length++;
  }
  removeNode(e) {
    const t = e.__ln;
    this.head && (t.previous ? (t.previous.next = t.next, t.next ? t.next.previous = t.previous : this.tail = t.previous) : (this.head = t.next, this.head ? this.head.previous = null : this.tail = null), e.__ln && delete e.__ln, this.length--);
  }
}
const So = (s, e) => `${s}@${e}`;
class af {
  constructor() {
    I(this, "frozen", !1), I(this, "locked", !1), I(this, "texts", []), I(this, "attributes", []), I(this, "attributeMap", /* @__PURE__ */ new WeakMap()), I(this, "removes", []), I(this, "mapRemoves", []), I(this, "movedMap", {}), I(this, "addedSet", /* @__PURE__ */ new Set()), I(this, "movedSet", /* @__PURE__ */ new Set()), I(this, "droppedSet", /* @__PURE__ */ new Set()), I(this, "removesSubTreeCache", /* @__PURE__ */ new Set()), I(this, "mutationCb"), I(this, "blockClass"), I(this, "blockSelector"), I(this, "maskTextClass"), I(this, "maskTextSelector"), I(this, "inlineStylesheet"), I(this, "maskInputOptions"), I(this, "maskTextFn"), I(this, "maskInputFn"), I(this, "keepIframeSrcFn"), I(this, "recordCanvas"), I(this, "inlineImages"), I(this, "privacySetting"), I(this, "slimDOMOptions"), I(this, "dataURLOptions"), I(this, "doc"), I(this, "mirror"), I(this, "iframeManager"), I(this, "stylesheetManager"), I(this, "shadowDomManager"), I(this, "canvasManager"), I(this, "processedNodeManager"), I(this, "unattachedDoc"), I(this, "processMutations", (e) => {
      e.forEach(this.processMutation), this.emit();
    }), I(this, "emit", () => {
      if (this.frozen || this.locked)
        return;
      const e = [], t = /* @__PURE__ */ new Set(), i = new lf(), r = (o) => {
        let c = o, u = Yt;
        for (; u === Yt; )
          c = c && c.nextSibling, u = c && this.mirror.getId(c);
        return u;
      }, n = (o) => {
        const c = H.parentNode(o);
        if (!c || !Oa(o) || c.tagName === "TEXTAREA")
          return;
        const u = wt(c) ? this.mirror.getId(za(o)) : this.mirror.getId(c), d = r(o);
        if (u === -1 || d === -1)
          return i.addNode(o);
        const h = it(o, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: !0,
          newlyAddedElement: !0,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          privacySetting: this.privacySetting,
          onSerialize: (p) => {
            Ha(p, this.mirror) && this.iframeManager.addIframe(p), Ma(p, this.mirror) && this.stylesheetManager.trackLinkElement(
              p
            ), Cr(o) && this.shadowDomManager.addShadowRoot(H.shadowRoot(o), this.doc);
          },
          onIframeLoad: (p, y) => {
            this.iframeManager.attachIframe(p, y), this.shadowDomManager.observeAttachShadow(p);
          },
          onStylesheetLoad: (p, y) => {
            this.stylesheetManager.attachLinkElement(p, y);
          }
        });
        h && (e.push({
          parentId: u,
          nextId: d,
          node: h
        }), t.add(h.id));
      };
      for (; this.mapRemoves.length; )
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      for (const o of this.movedSet)
        Vo(this.removesSubTreeCache, o) && !this.movedSet.has(H.parentNode(o)) || n(o);
      for (const o of this.addedSet)
        !Wo(this.droppedSet, o) && !Vo(this.removesSubTreeCache, o) || Wo(this.movedSet, o) ? n(o) : this.droppedSet.add(o);
      let l = null;
      for (; i.length; ) {
        let o = null;
        if (l) {
          const c = this.mirror.getId(H.parentNode(l.value)), u = r(l.value);
          c !== -1 && u !== -1 && (o = l);
        }
        if (!o) {
          let c = i.tail;
          for (; c; ) {
            const u = c;
            if (c = c.previous, u) {
              const d = this.mirror.getId(H.parentNode(u.value));
              if (r(u.value) === -1) continue;
              if (d !== -1) {
                o = u;
                break;
              } else {
                const p = u.value, y = H.parentNode(p);
                if (y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const f = H.host(y);
                  if (this.mirror.getId(f) !== -1) {
                    o = u;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!o) {
          for (; i.head; )
            i.removeNode(i.head.value);
          break;
        }
        l = o.previous, i.removeNode(o.value), n(o.value);
      }
      const a = {
        texts: this.texts.map((o) => {
          var c, u;
          const d = o.node, h = H.parentNode(d);
          h && h.tagName === "TEXTAREA" && this.genTextAreaValueMutation(h);
          let p = o.value;
          const y = this.privacySetting === "strict", f = this.privacySetting === "default" && ll(p), m = (u = (c = o.node) == null ? void 0 : c.parentElement) == null ? void 0 : u.getAttribute("data-hl-record");
          return (y || f) && !m && p && (p = Ur(p)), {
            id: this.mirror.getId(d),
            value: p
          };
        }).filter((o) => !t.has(o.id)).filter((o) => this.mirror.has(o.id)),
        attributes: this.attributes.map((o) => {
          const { attributes: c } = o;
          if (typeof c.style == "string") {
            const u = JSON.stringify(o.styleDiff), d = JSON.stringify(o._unchangedStyles);
            u.length < c.style.length && (u + d).split("var(").length === c.style.split("var(").length && (c.style = o.styleDiff);
          }
          return {
            id: this.mirror.getId(o.node),
            attributes: c
          };
        }).filter((o) => !t.has(o.id)).filter((o) => this.mirror.has(o.id)),
        removes: this.removes,
        adds: e
      };
      !a.texts.length && !a.attributes.length && !a.removes.length && !a.adds.length || (this.texts = [], this.attributes = [], this.attributeMap = /* @__PURE__ */ new WeakMap(), this.removes = [], this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.removesSubTreeCache = /* @__PURE__ */ new Set(), this.movedMap = {}, this.mutationCb(a));
    }), I(this, "genTextAreaValueMutation", (e) => {
      let t = this.attributeMap.get(e);
      t || (t = {
        node: e,
        attributes: {},
        styleDiff: {},
        _unchangedStyles: {}
      }, this.attributes.push(t), this.attributeMap.set(e, t)), t.attributes.value = Array.from(
        H.childNodes(e),
        (i) => H.textContent(i) || ""
      ).join("");
    }), I(this, "processMutation", (e) => {
      if (!Ks(e.target, this.mirror, this.slimDOMOptions))
        switch (e.type) {
          case "characterData": {
            const t = H.textContent(e.target);
            !oe(e.target, this.blockClass, this.blockSelector, !1) && t !== e.oldValue && this.texts.push({
              value: hl(
                e.target,
                this.maskTextClass,
                this.maskTextSelector,
                !0
                // checkAncestors
              ) && t ? this.maskTextFn ? this.maskTextFn(t, Fa(e.target)) : t.replace(/[\S]/g, "*") : t,
              node: e.target
            });
            break;
          }
          case "attributes": {
            const t = e.target;
            let i = e.attributeName, r = e.target.getAttribute(i);
            if (i === "value") {
              const l = Jr(t);
              r = Tr({
                element: t,
                maskInputOptions: this.maskInputOptions,
                tagName: t.tagName,
                type: l,
                value: r,
                overwriteRecord: t.getAttribute("data-hl-record"),
                maskInputFn: this.maskInputFn
              });
            }
            if (oe(e.target, this.blockClass, this.blockSelector, !1) || r === e.oldValue)
              return;
            let n = this.attributeMap.get(e.target);
            if (t.tagName === "IFRAME" && i === "src" && !this.keepIframeSrcFn(r))
              if (!t.contentDocument)
                i = "rr_src";
              else
                return;
            if (n || (n = {
              node: e.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            }, this.attributes.push(n), this.attributeMap.set(e.target, n)), i === "type" && t.tagName === "INPUT" && (e.oldValue || "").toLowerCase() === "password" && t.setAttribute("data-rr-is-password", "true"), !dl(t.tagName, i)) {
              if (e.target.tagName === "INPUT") {
                const a = e.target;
                if (a.type === "password") {
                  n.attributes.value = "*".repeat(a.value.length);
                  break;
                }
              }
              if (n.attributes[i] = ul(
                this.doc,
                nt(t.tagName),
                nt(i),
                r
              ), i === "style") {
                if (!this.unattachedDoc)
                  try {
                    this.unattachedDoc = document.implementation.createHTMLDocument();
                  } catch (o) {
                    this.unattachedDoc = this.doc;
                  }
                const a = this.unattachedDoc.createElement("span");
                e.oldValue && a.setAttribute("style", e.oldValue);
                for (const o of Array.from(t.style)) {
                  const c = t.style.getPropertyValue(o), u = t.style.getPropertyPriority(o);
                  c !== a.style.getPropertyValue(o) || u !== a.style.getPropertyPriority(o) ? u === "" ? n.styleDiff[o] = c : n.styleDiff[o] = [c, u] : n._unchangedStyles[o] = [c, u];
                }
                for (const o of Array.from(a.style))
                  t.style.getPropertyValue(o) === "" && (n.styleDiff[o] = !1);
              } else i === "open" && t.tagName === "DIALOG" && (t.matches("dialog:modal") ? n.attributes.rr_open_mode = "modal" : n.attributes.rr_open_mode = "non-modal");
            }
            break;
          }
          case "childList": {
            if (oe(e.target, this.blockClass, this.blockSelector, !0))
              return;
            if (e.target.tagName === "TEXTAREA") {
              this.genTextAreaValueMutation(e.target);
              return;
            }
            e.addedNodes.forEach((t) => this.genAdds(t, e.target)), e.removedNodes.forEach((t) => {
              const i = this.mirror.getId(t), r = wt(e.target) ? this.mirror.getId(H.host(e.target)) : this.mirror.getId(e.target);
              oe(e.target, this.blockClass, this.blockSelector, !1) || Ks(t, this.mirror, this.slimDOMOptions) || !tf(t, this.mirror) || (this.addedSet.has(t) ? (vr(this.addedSet, t), this.droppedSet.add(t)) : this.addedSet.has(e.target) && i === -1 || Ka(e.target, this.mirror) || (this.movedSet.has(t) && this.movedMap[So(i, r)] ? vr(this.movedSet, t) : (this.removes.push({
                parentId: r,
                id: i,
                isShadow: wt(e.target) && Ct(e.target) ? !0 : void 0
              }), cf(t, this.removesSubTreeCache))), this.mapRemoves.push(t));
            });
            break;
          }
        }
    }), I(this, "genAdds", (e, t) => {
      if (!this.processedNodeManager.inOtherBuffer(e, this) && !(this.addedSet.has(e) || this.movedSet.has(e))) {
        if (this.mirror.hasNode(e)) {
          if (Ks(e, this.mirror, this.slimDOMOptions))
            return;
          this.movedSet.add(e);
          let i = null;
          t && this.mirror.hasNode(t) && (i = this.mirror.getId(t)), i && i !== -1 && (this.movedMap[So(this.mirror.getId(e), i)] = !0);
        } else
          this.addedSet.add(e), this.droppedSet.delete(e);
        oe(e, this.blockClass, this.blockSelector, !1) || (H.childNodes(e).forEach((i) => this.genAdds(i)), Cr(e) && H.childNodes(H.shadowRoot(e)).forEach((i) => {
          this.processedNodeManager.add(i, this), this.genAdds(i, e);
        }));
      }
    });
  }
  init(e) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "privacySetting",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((t) => {
      this[t] = e[t];
    });
  }
  freeze() {
    this.frozen = !0, this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = !1, this.canvasManager.unfreeze(), this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = !0, this.canvasManager.lock();
  }
  unlock() {
    this.locked = !1, this.canvasManager.unlock(), this.emit();
  }
  reset() {
    this.shadowDomManager.reset(), this.canvasManager.reset();
  }
}
function vr(s, e) {
  s.delete(e), H.childNodes(e).forEach((t) => vr(s, t));
}
function cf(s, e) {
  const t = [s];
  for (; t.length; ) {
    const i = t.pop();
    e.has(i) || (e.add(i), H.childNodes(i).forEach((r) => t.push(r)));
  }
}
function Vo(s, e, t) {
  return s.size === 0 ? !1 : uf(s, e);
}
function uf(s, e, t) {
  const i = H.parentNode(e);
  return i ? s.has(i) : !1;
}
function Wo(s, e) {
  return s.size === 0 ? !1 : Ea(s, e);
}
function Ea(s, e) {
  const t = H.parentNode(e);
  return t ? s.has(t) ? !0 : Ea(s, t) : !1;
}
let vt;
function df(s) {
  vt = s;
}
function hf() {
  vt = void 0;
}
const z = (s) => vt ? (...t) => {
  try {
    return s(...t);
  } catch (i) {
    if (vt && vt(i) === !0)
      return;
    throw i;
  }
} : s, Ee = [];
function Dt(s) {
  try {
    if ("composedPath" in s) {
      const e = s.composedPath();
      if (e.length)
        return e[0];
    } else if ("path" in s && s.path.length)
      return s.path[0];
  } catch (e) {
  }
  return s && s.target;
}
function Pa(s, e) {
  const t = new af();
  Ee.push(t), t.init(s);
  const i = new (ka())(
    z(t.processMutations.bind(t))
  );
  return i.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  }), i;
}
function pf({
  mousemoveCb: s,
  sampling: e,
  doc: t,
  mirror: i
}) {
  if (e.mousemove === !1)
    return () => {
    };
  const r = typeof e.mousemove == "number" ? e.mousemove : 50, n = typeof e.mousemoveCallback == "number" ? e.mousemoveCallback : 500;
  let l = [], a;
  const o = Mt(
    z(
      (d) => {
        const h = Date.now() - a;
        s(
          l.map((p) => (p.timeOffset -= h, p)),
          d
        ), l = [], a = null;
      }
    ),
    n
  ), c = z(
    Mt(
      z((d) => {
        const h = Dt(d), { clientX: p, clientY: y } = wr(d) ? d.changedTouches[0] : d;
        a || (a = Ei()), l.push({
          x: p,
          y,
          id: i.getId(h),
          timeOffset: Ei() - a
        }), o(
          typeof DragEvent != "undefined" && d instanceof DragEvent ? M.Drag : d instanceof MouseEvent ? M.MouseMove : M.TouchMove
        );
      }),
      r,
      {
        trailing: !1
      }
    )
  ), u = [
    ue("mousemove", c, t),
    ue("touchmove", c, t),
    ue("drag", c, t)
  ];
  return z(() => {
    u.forEach((d) => d());
  });
}
function mf({
  mouseInteractionCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  sampling: n
}) {
  if (n.mouseInteraction === !1)
    return () => {
    };
  const l = n.mouseInteraction === !0 || n.mouseInteraction === void 0 ? {} : n.mouseInteraction, a = [];
  let o = null;
  const c = (u) => (d) => {
    const h = Dt(d);
    if (oe(h, i, r, !0) || // We ignore canvas elements for rage click detection because we cannot infer what inside the canvas is getting interacted with.
    ef(h))
      return;
    let p = null, y = u;
    if ("pointerType" in d) {
      switch (d.pointerType) {
        case "mouse":
          p = Te.Mouse;
          break;
        case "touch":
          p = Te.Touch;
          break;
        case "pen":
          p = Te.Pen;
          break;
      }
      p === Te.Touch && (de[u] === de.MouseDown ? y = "TouchStart" : de[u] === de.MouseUp && (y = "TouchEnd"));
    } else wr(d) && (p = Te.Touch);
    p !== null ? (o = p, (y.startsWith("Touch") && p === Te.Touch || y.startsWith("Mouse") && p === Te.Mouse) && (p = null)) : de[u] === de.Click && (p = o, o = null);
    const f = wr(d) ? d.changedTouches[0] : d;
    if (!f)
      return;
    const m = t.getId(h), { clientX: W, clientY: S } = f;
    z(s)(X({
      type: de[y],
      id: m,
      x: W,
      y: S
    }, p !== null && { pointerType: p }));
  };
  return Object.keys(de).filter(
    (u) => Number.isNaN(Number(u)) && !u.endsWith("_Departed") && l[u] !== !1
  ).forEach((u) => {
    let d = nt(u);
    const h = c(u);
    if (window.PointerEvent)
      switch (de[u]) {
        case de.MouseDown:
        case de.MouseUp:
          d = d.replace(
            "mouse",
            "pointer"
          );
          break;
        case de.TouchStart:
        case de.TouchEnd:
          return;
      }
    a.push(ue(d, h, e));
  }), z(() => {
    a.forEach((u) => u());
  });
}
function Ba({
  scrollCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  sampling: n
}) {
  const l = z(
    Mt(
      z((a) => {
        const o = Dt(a);
        if (!o || oe(o, i, r, !0))
          return;
        const c = t.getId(o);
        if (o === e && e.defaultView) {
          const u = Ta(e.defaultView);
          s({
            id: c,
            x: u.left,
            y: u.top
          });
        } else
          s({
            id: c,
            x: o.scrollLeft,
            y: o.scrollTop
          });
      }),
      n.scroll || 100
    )
  );
  return ue("scroll", l, e);
}
function ff({ viewportResizeCb: s }, { win: e }) {
  let t = -1, i = -1;
  const r = z(
    Mt(
      z(() => {
        const n = Ja(), l = Ua();
        (t !== n || i !== l) && (s({
          width: Number(l),
          height: Number(n)
        }), t = n, i = l);
      }),
      200
    )
  );
  return ue("resize", r, e);
}
const bf = ["INPUT", "TEXTAREA", "SELECT"], Xo = /* @__PURE__ */ new WeakMap();
function yf({
  inputCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  ignoreClass: n,
  ignoreSelector: l,
  maskInputOptions: a,
  maskInputFn: o,
  sampling: c,
  userTriggeredOnInput: u
}) {
  function d(S) {
    let g = Dt(S);
    const Z = S.isTrusted, C = g && g.tagName;
    if (g && C === "OPTION" && (g = H.parentElement(g)), !g || !C || bf.indexOf(C) < 0 || oe(g, i, r, !0) || g.classList.contains(n) || l && g.matches(l))
      return;
    let J = g.value, V = !1;
    const R = Jr(g) || "", F = g.getAttribute("data-hl-record");
    R === "radio" || R === "checkbox" ? V = g.checked : al({
      maskInputOptions: a,
      type: R,
      tagName: C,
      overwriteRecord: F
    }) && (J = Tr({
      element: g,
      maskInputOptions: a,
      tagName: C,
      type: R,
      value: J,
      overwriteRecord: F,
      maskInputFn: o
    })), h(
      g,
      u ? { text: J, isChecked: V, userTriggered: Z } : { text: J, isChecked: V }
    );
    const v = g.name;
    R === "radio" && v && V && e.querySelectorAll(`input[type="radio"][name="${v}"]`).forEach((E) => {
      if (E !== g) {
        const te = E.value;
        h(
          E,
          u ? { text: te, isChecked: !V, userTriggered: !1 } : { text: te, isChecked: !V }
        );
      }
    });
  }
  function h(S, g) {
    const Z = Xo.get(S);
    if (!Z || Z.text !== g.text || Z.isChecked !== g.isChecked) {
      Xo.set(S, g);
      const C = t.getId(S);
      z(s)(se(X({}, g), {
        id: C
      }));
    }
  }
  const y = (c.input === "last" ? ["change"] : ["input", "change"]).map(
    (S) => ue(S, z(d), e)
  ), f = e.defaultView;
  if (!f)
    return () => {
      y.forEach((S) => S());
    };
  const m = f.Object.getOwnPropertyDescriptor(
    f.HTMLInputElement.prototype,
    "value"
  ), W = [
    [f.HTMLInputElement.prototype, "value"],
    [f.HTMLInputElement.prototype, "checked"],
    [f.HTMLSelectElement.prototype, "value"],
    [f.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [f.HTMLSelectElement.prototype, "selectedIndex"],
    [f.HTMLOptionElement.prototype, "selected"]
  ];
  return m && m.set && y.push(
    ...W.map(
      (S) => cs(
        S[0],
        S[1],
        {
          set() {
            z(d)({
              target: this,
              isTrusted: !1
              // userTriggered to false as this could well be programmatic
            });
          }
        },
        !1,
        f
      )
    )
  ), z(() => {
    y.forEach((S) => S());
  });
}
function Pi(s) {
  const e = [];
  function t(i, r) {
    if (gi("CSSGroupingRule") && i.parentRule instanceof CSSGroupingRule || gi("CSSMediaRule") && i.parentRule instanceof CSSMediaRule || gi("CSSSupportsRule") && i.parentRule instanceof CSSSupportsRule || gi("CSSConditionRule") && i.parentRule instanceof CSSConditionRule) {
      const l = Array.from(
        i.parentRule.cssRules
      ).indexOf(i);
      r.unshift(l);
    } else if (i.parentStyleSheet) {
      const l = Array.from(i.parentStyleSheet.cssRules).indexOf(i);
      r.unshift(l);
    }
    return r;
  }
  return t(s, e);
}
function Je(s, e, t) {
  let i, r;
  return s ? (s.ownerNode ? i = e.getId(s.ownerNode) : r = t.getId(s), {
    styleId: r,
    id: i
  }) : {};
}
function gf({ styleSheetRuleCb: s, mirror: e, stylesheetManager: t }, { win: i }) {
  if (!i.CSSStyleSheet || !i.CSSStyleSheet.prototype)
    return () => {
    };
  const r = i.CSSStyleSheet.prototype.insertRule;
  i.CSSStyleSheet.prototype.insertRule = new Proxy(r, {
    apply: z(
      (u, d, h) => {
        const [p, y] = h, { id: f, styleId: m } = Je(
          d,
          e,
          t.styleMirror
        );
        return (f && f !== -1 || m && m !== -1) && s({
          id: f,
          styleId: m,
          adds: [{ rule: p, index: y }]
        }), u.apply(d, h);
      }
    )
  }), i.CSSStyleSheet.prototype.addRule = function(u, d, h = this.cssRules.length) {
    const p = `${u} { ${d} }`;
    return i.CSSStyleSheet.prototype.insertRule.apply(this, [p, h]);
  };
  const n = i.CSSStyleSheet.prototype.deleteRule;
  i.CSSStyleSheet.prototype.deleteRule = new Proxy(n, {
    apply: z(
      (u, d, h) => {
        const [p] = h, { id: y, styleId: f } = Je(
          d,
          e,
          t.styleMirror
        );
        return (y && y !== -1 || f && f !== -1) && s({
          id: y,
          styleId: f,
          removes: [{ index: p }]
        }), u.apply(d, h);
      }
    )
  }), i.CSSStyleSheet.prototype.removeRule = function(u) {
    return i.CSSStyleSheet.prototype.deleteRule.apply(this, [u]);
  };
  let l;
  i.CSSStyleSheet.prototype.replace && (l = i.CSSStyleSheet.prototype.replace, i.CSSStyleSheet.prototype.replace = new Proxy(l, {
    apply: z(
      (u, d, h) => {
        const [p] = h, { id: y, styleId: f } = Je(
          d,
          e,
          t.styleMirror
        );
        return (y && y !== -1 || f && f !== -1) && s({
          id: y,
          styleId: f,
          replace: p
        }), u.apply(d, h);
      }
    )
  }));
  let a;
  i.CSSStyleSheet.prototype.replaceSync && (a = i.CSSStyleSheet.prototype.replaceSync, i.CSSStyleSheet.prototype.replaceSync = new Proxy(a, {
    apply: z(
      (u, d, h) => {
        const [p] = h, { id: y, styleId: f } = Je(
          d,
          e,
          t.styleMirror
        );
        return (y && y !== -1 || f && f !== -1) && s({
          id: y,
          styleId: f,
          replaceSync: p
        }), u.apply(d, h);
      }
    )
  }));
  const o = {};
  Zi("CSSGroupingRule") ? o.CSSGroupingRule = i.CSSGroupingRule : (Zi("CSSMediaRule") && (o.CSSMediaRule = i.CSSMediaRule), Zi("CSSConditionRule") && (o.CSSConditionRule = i.CSSConditionRule), Zi("CSSSupportsRule") && (o.CSSSupportsRule = i.CSSSupportsRule));
  const c = {};
  return Object.entries(o).forEach(([u, d]) => {
    c[u] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: d.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: d.prototype.deleteRule
    }, d.prototype.insertRule = new Proxy(
      c[u].insertRule,
      {
        apply: z(
          (h, p, y) => {
            const [f, m] = y, { id: W, styleId: S } = Je(
              p.parentStyleSheet,
              e,
              t.styleMirror
            );
            return (W && W !== -1 || S && S !== -1) && s({
              id: W,
              styleId: S,
              adds: [
                {
                  rule: f,
                  index: [
                    ...Pi(p),
                    m || 0
                    // defaults to 0
                  ]
                }
              ]
            }), h.apply(p, y);
          }
        )
      }
    ), d.prototype.deleteRule = new Proxy(
      c[u].deleteRule,
      {
        apply: z(
          (h, p, y) => {
            const [f] = y, { id: m, styleId: W } = Je(
              p.parentStyleSheet,
              e,
              t.styleMirror
            );
            return (m && m !== -1 || W && W !== -1) && s({
              id: m,
              styleId: W,
              removes: [
                { index: [...Pi(p), f] }
              ]
            }), h.apply(p, y);
          }
        )
      }
    );
  }), z(() => {
    i.CSSStyleSheet.prototype.insertRule = r, i.CSSStyleSheet.prototype.deleteRule = n, l && (i.CSSStyleSheet.prototype.replace = l), a && (i.CSSStyleSheet.prototype.replaceSync = a), Object.entries(o).forEach(([u, d]) => {
      d.prototype.insertRule = c[u].insertRule, d.prototype.deleteRule = c[u].deleteRule;
    });
  });
}
function Da({
  mirror: s,
  stylesheetManager: e
}, t) {
  var i, r, n;
  let l = null;
  t.nodeName === "#document" ? l = s.getId(t) : l = s.getId(H.host(t));
  const a = t.nodeName === "#document" ? (i = t.defaultView) == null ? void 0 : i.Document : (n = (r = t.ownerDocument) == null ? void 0 : r.defaultView) == null ? void 0 : n.ShadowRoot, o = a != null && a.prototype ? Object.getOwnPropertyDescriptor(
    a == null ? void 0 : a.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  return l === null || l === -1 || !a || !o ? () => {
  } : (Object.defineProperty(t, "adoptedStyleSheets", {
    configurable: o.configurable,
    enumerable: o.enumerable,
    get() {
      var c;
      return (c = o.get) == null ? void 0 : c.call(this);
    },
    set(c) {
      var u;
      const d = (u = o.set) == null ? void 0 : u.call(this, c);
      if (l !== null && l !== -1)
        try {
          e.adoptStyleSheets(c, l);
        } catch (h) {
        }
      return d;
    }
  }), z(() => {
    Object.defineProperty(t, "adoptedStyleSheets", {
      configurable: o.configurable,
      enumerable: o.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: o.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: o.set
    });
  }));
}
function Zf({
  styleDeclarationCb: s,
  mirror: e,
  ignoreCSSAttributes: t,
  stylesheetManager: i
}, { win: r }) {
  const n = r.CSSStyleDeclaration.prototype.setProperty;
  r.CSSStyleDeclaration.prototype.setProperty = new Proxy(n, {
    apply: z(
      (a, o, c) => {
        var u;
        const [d, h, p] = c;
        if (t.has(d))
          return n.apply(o, [d, h, p]);
        const { id: y, styleId: f } = Je(
          (u = o.parentRule) == null ? void 0 : u.parentStyleSheet,
          e,
          i.styleMirror
        );
        return (y && y !== -1 || f && f !== -1) && s({
          id: y,
          styleId: f,
          set: {
            property: d,
            value: h,
            priority: p
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: Pi(o.parentRule)
        }), a.apply(o, c);
      }
    )
  });
  const l = r.CSSStyleDeclaration.prototype.removeProperty;
  return r.CSSStyleDeclaration.prototype.removeProperty = new Proxy(l, {
    apply: z(
      (a, o, c) => {
        var u;
        const [d] = c;
        if (t.has(d))
          return l.apply(o, [d]);
        const { id: h, styleId: p } = Je(
          (u = o.parentRule) == null ? void 0 : u.parentStyleSheet,
          e,
          i.styleMirror
        );
        return (h && h !== -1 || p && p !== -1) && s({
          id: h,
          styleId: p,
          remove: {
            property: d
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: Pi(o.parentRule)
        }), a.apply(o, c);
      }
    )
  }), z(() => {
    r.CSSStyleDeclaration.prototype.setProperty = n, r.CSSStyleDeclaration.prototype.removeProperty = l;
  });
}
function Gf({
  mediaInteractionCb: s,
  blockClass: e,
  blockSelector: t,
  mirror: i,
  sampling: r,
  doc: n
}) {
  const l = z(
    (o) => Mt(
      z((c) => {
        const u = Dt(c);
        if (!u || oe(u, e, t, !0))
          return;
        const { currentTime: d, volume: h, muted: p, playbackRate: y, loop: f } = u;
        s({
          type: o,
          id: i.getId(u),
          currentTime: d,
          volume: h,
          muted: p,
          playbackRate: y,
          loop: f
        });
      }),
      r.media || 500
    )
  ), a = [
    ue("play", l(et.Play), n),
    ue("pause", l(et.Pause), n),
    ue("seeked", l(et.Seeked), n),
    ue("volumechange", l(et.VolumeChange), n),
    ue("ratechange", l(et.RateChange), n)
  ];
  return z(() => {
    a.forEach((o) => o());
  });
}
function If({ fontCb: s, doc: e }) {
  const t = e.defaultView;
  if (!t)
    return () => {
    };
  const i = [], r = /* @__PURE__ */ new WeakMap(), n = t.FontFace;
  t.FontFace = function(o, c, u) {
    const d = new n(o, c, u);
    return r.set(d, {
      family: o,
      buffer: typeof c != "string",
      descriptors: u,
      fontSource: typeof c == "string" ? c : JSON.stringify(Array.from(new Uint8Array(c)))
    }), d;
  };
  const l = pt(
    e.fonts,
    "add",
    function(a) {
      return function(o) {
        return setTimeout(
          z(() => {
            const c = r.get(o);
            c && (s(c), r.delete(o));
          }),
          0
        ), a.apply(this, [o]);
      };
    }
  );
  return i.push(() => {
    t.FontFace = n;
  }), i.push(l), z(() => {
    i.forEach((a) => a());
  });
}
function Sf(s) {
  const { doc: e, mirror: t, blockClass: i, blockSelector: r, selectionCb: n } = s;
  let l = !0;
  const a = z(() => {
    const o = e.getSelection();
    if (!o || l && (o != null && o.isCollapsed)) return;
    l = o.isCollapsed || !1;
    const c = [], u = o.rangeCount || 0;
    for (let d = 0; d < u; d++) {
      const h = o.getRangeAt(d), { startContainer: p, startOffset: y, endContainer: f, endOffset: m } = h;
      oe(p, i, r, !0) || oe(f, i, r, !0) || c.push({
        start: t.getId(p),
        startOffset: y,
        end: t.getId(f),
        endOffset: m
      });
    }
    n({ ranges: c });
  });
  return a(), ue("selectionchange", a);
}
function Vf({
  doc: s,
  customElementCb: e
}) {
  const t = s.defaultView;
  return !t || !t.customElements ? () => {
  } : pt(
    t.customElements,
    "define",
    function(r) {
      return function(n, l, a) {
        try {
          e({
            define: {
              name: n
            }
          });
        } catch (o) {
          console.warn(`Custom element callback failed for ${n}`);
        }
        return r.apply(this, [n, l, a]);
      };
    }
  );
}
function Wf(s, e) {
  const {
    mutationCb: t,
    mousemoveCb: i,
    mouseInteractionCb: r,
    scrollCb: n,
    viewportResizeCb: l,
    inputCb: a,
    mediaInteractionCb: o,
    styleSheetRuleCb: c,
    styleDeclarationCb: u,
    canvasMutationCb: d,
    fontCb: h,
    selectionCb: p,
    customElementCb: y
  } = s;
  s.mutationCb = (...f) => {
    e.mutation && e.mutation(...f), t(...f);
  }, s.mousemoveCb = (...f) => {
    e.mousemove && e.mousemove(...f), i(...f);
  }, s.mouseInteractionCb = (...f) => {
    e.mouseInteraction && e.mouseInteraction(...f), r(...f);
  }, s.scrollCb = (...f) => {
    e.scroll && e.scroll(...f), n(...f);
  }, s.viewportResizeCb = (...f) => {
    e.viewportResize && e.viewportResize(...f), l(...f);
  }, s.inputCb = (...f) => {
    e.input && e.input(...f), a(...f);
  }, s.mediaInteractionCb = (...f) => {
    e.mediaInteaction && e.mediaInteaction(...f), o(...f);
  }, s.styleSheetRuleCb = (...f) => {
    e.styleSheetRule && e.styleSheetRule(...f), c(...f);
  }, s.styleDeclarationCb = (...f) => {
    e.styleDeclaration && e.styleDeclaration(...f), u(...f);
  }, s.canvasMutationCb = (...f) => {
    e.canvasMutation && e.canvasMutation(...f), d(...f);
  }, s.fontCb = (...f) => {
    e.font && e.font(...f), h(...f);
  }, s.selectionCb = (...f) => {
    e.selection && e.selection(...f), p(...f);
  }, s.customElementCb = (...f) => {
    e.customElement && e.customElement(...f), y(...f);
  };
}
function Xf(s, e = {}) {
  const t = s.doc.defaultView;
  if (!t)
    return () => {
    };
  Wf(s, e);
  let i;
  s.recordDOM && (i = Pa(s, s.doc));
  const r = pf(s), n = mf(s), l = Ba(s), a = ff(s, {
    win: t
  }), o = yf(s), c = Gf(s);
  let u = () => {
  }, d = () => {
  }, h = () => {
  }, p = () => {
  };
  s.recordDOM && (u = gf(s, { win: t }), d = Da(s, s.doc), h = Zf(s, {
    win: t
  }), s.collectFonts && (p = If(s)));
  const y = Sf(s), f = Vf(s), m = [];
  for (const W of s.plugins)
    m.push(
      W.observer(W.callback, t, W.options)
    );
  return z(() => {
    Ee.forEach((W) => W.reset()), i == null || i.disconnect(), r(), n(), l(), a(), o(), c(), u(), d(), h(), p(), y(), f(), m.forEach((W) => W());
  });
}
function gi(s) {
  return typeof window[s] != "undefined";
}
function Zi(s) {
  return !!(typeof window[s] != "undefined" && // Note: Generally, this check _shouldn't_ be necessary
  // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
  window[s].prototype && "insertRule" in window[s].prototype && "deleteRule" in window[s].prototype);
}
class Ro {
  constructor(e) {
    I(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap()), I(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap()), this.generateIdFn = e;
  }
  getId(e, t, i, r) {
    const n = i || this.getIdToRemoteIdMap(e), l = r || this.getRemoteIdToIdMap(e);
    let a = n.get(t);
    return a || (a = this.generateIdFn(), n.set(t, a), l.set(a, t)), a;
  }
  getIds(e, t) {
    const i = this.getIdToRemoteIdMap(e), r = this.getRemoteIdToIdMap(e);
    return t.map(
      (n) => this.getId(e, n, i, r)
    );
  }
  getRemoteId(e, t, i) {
    const r = i || this.getRemoteIdToIdMap(e);
    if (typeof t != "number") return t;
    const n = r.get(t);
    return n || -1;
  }
  getRemoteIds(e, t) {
    const i = this.getRemoteIdToIdMap(e);
    return t.map((r) => this.getRemoteId(e, r, i));
  }
  reset(e) {
    if (!e) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(e), this.iframeRemoteIdToIdMap.delete(e);
  }
  getIdToRemoteIdMap(e) {
    let t = this.iframeIdToRemoteIdMap.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this.iframeIdToRemoteIdMap.set(e, t)), t;
  }
  getRemoteIdToIdMap(e) {
    let t = this.iframeRemoteIdToIdMap.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this.iframeRemoteIdToIdMap.set(e, t)), t;
  }
}
class Rf {
  constructor(e) {
    I(this, "iframes", /* @__PURE__ */ new WeakMap()), I(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap()), I(this, "crossOriginIframeMirror", new Ro(cl)), I(this, "crossOriginIframeStyleMirror"), I(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap()), I(this, "mirror"), I(this, "mutationCb"), I(this, "wrappedEmit"), I(this, "loadListener"), I(this, "stylesheetManager"), I(this, "recordCrossOriginIframes"), this.mutationCb = e.mutationCb, this.wrappedEmit = e.wrappedEmit, this.stylesheetManager = e.stylesheetManager, this.recordCrossOriginIframes = e.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new Ro(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    ), this.mirror = e.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this));
  }
  addIframe(e) {
    this.iframes.set(e, !0), e.contentWindow && this.crossOriginIframeMap.set(e.contentWindow, e);
  }
  addLoadListener(e) {
    this.loadListener = e;
  }
  attachIframe(e, t) {
    var i, r;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(e),
          nextId: null,
          node: t
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: !0
    }), this.recordCrossOriginIframes && ((i = e.contentWindow) == null || i.addEventListener(
      "message",
      this.handleMessage.bind(this)
    )), (r = this.loadListener) == null || r.call(this, e), e.contentDocument && e.contentDocument.adoptedStyleSheets && e.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(
      e.contentDocument.adoptedStyleSheets,
      this.mirror.getId(e.contentDocument)
    );
  }
  handleMessage(e) {
    const t = e;
    if (t.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    t.origin !== t.data.origin)
      return;
    const i = e.source;
    if (!i) return;
    const r = this.crossOriginIframeMap.get(i);
    if (!r) return;
    const n = this.transformCrossOriginEvent(
      r,
      t.data.event
    );
    n && this.wrappedEmit(
      n,
      t.data.isCheckout
    );
  }
  transformCrossOriginEvent(e, t) {
    var i;
    switch (t.type) {
      case O.FullSnapshot: {
        this.crossOriginIframeMirror.reset(e), this.crossOriginIframeStyleMirror.reset(e), this.replaceIdOnNode(t.data.node, e);
        const r = t.data.node.id;
        return this.crossOriginIframeRootIdMap.set(e, r), this.patchRootIdOnNode(t.data.node, r), {
          timestamp: t.timestamp,
          type: O.IncrementalSnapshot,
          data: {
            source: M.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(e),
                nextId: null,
                node: t.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
          }
        };
      }
      case O.Meta:
      case O.Load:
      case O.DomContentLoaded:
        return !1;
      case O.Plugin:
        return t;
      case O.Custom:
        return this.replaceIds(
          t.data.payload,
          e,
          ["id", "parentId", "previousId", "nextId"]
        ), t;
      case O.IncrementalSnapshot:
        switch (t.data.source) {
          case M.Mutation:
            return t.data.adds.forEach((r) => {
              this.replaceIds(r, e, [
                "parentId",
                "nextId",
                "previousId"
              ]), this.replaceIdOnNode(r.node, e);
              const n = this.crossOriginIframeRootIdMap.get(e);
              n && this.patchRootIdOnNode(r.node, n);
            }), t.data.removes.forEach((r) => {
              this.replaceIds(r, e, ["parentId", "id"]);
            }), t.data.attributes.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t.data.texts.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t;
          case M.Drag:
          case M.TouchMove:
          case M.MouseMove:
            return t.data.positions.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t;
          case M.ViewportResize:
            return !1;
          case M.MediaInteraction:
          case M.MouseInteraction:
          case M.Scroll:
          case M.CanvasMutation:
          case M.Input:
            return this.replaceIds(t.data, e, ["id"]), t;
          case M.StyleSheetRule:
          case M.StyleDeclaration:
            return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleId"]), t;
          case M.Font:
            return t;
          case M.Selection:
            return t.data.ranges.forEach((r) => {
              this.replaceIds(r, e, ["start", "end"]);
            }), t;
          case M.AdoptedStyleSheet:
            return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleIds"]), (i = t.data.styles) == null || i.forEach((r) => {
              this.replaceStyleIds(r, e, ["styleId"]);
            }), t;
        }
    }
    return !1;
  }
  replace(e, t, i, r) {
    for (const n of r)
      !Array.isArray(t[n]) && typeof t[n] != "number" || (Array.isArray(t[n]) ? t[n] = e.getIds(
        i,
        t[n]
      ) : t[n] = e.getId(i, t[n]));
    return t;
  }
  replaceIds(e, t, i) {
    return this.replace(this.crossOriginIframeMirror, e, t, i);
  }
  replaceStyleIds(e, t, i) {
    return this.replace(this.crossOriginIframeStyleMirror, e, t, i);
  }
  replaceIdOnNode(e, t) {
    this.replaceIds(e, t, ["id", "rootId"]), "childNodes" in e && e.childNodes.forEach((i) => {
      this.replaceIdOnNode(i, t);
    });
  }
  patchRootIdOnNode(e, t) {
    e.type !== ie.Document && !e.rootId && (e.rootId = t), "childNodes" in e && e.childNodes.forEach((i) => {
      this.patchRootIdOnNode(i, t);
    });
  }
}
class wf {
  constructor(e) {
    I(this, "shadowDoms", /* @__PURE__ */ new WeakSet()), I(this, "mutationCb"), I(this, "scrollCb"), I(this, "bypassOptions"), I(this, "mirror"), I(this, "restoreHandlers", []), this.mutationCb = e.mutationCb, this.scrollCb = e.scrollCb, this.bypassOptions = e.bypassOptions, this.mirror = e.mirror, this.init();
  }
  init() {
    this.reset(), this.patchAttachShadow(Element, document);
  }
  addShadowRoot(e, t) {
    if (!Ct(e) || this.shadowDoms.has(e)) return;
    this.shadowDoms.add(e);
    const i = Pa(
      se(X({}, this.bypassOptions), {
        doc: t,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      }),
      e
    );
    this.restoreHandlers.push(() => i.disconnect()), this.restoreHandlers.push(
      Ba(se(X({}, this.bypassOptions), {
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: e,
        mirror: this.mirror
      }))
    ), setTimeout(() => {
      e.adoptedStyleSheets && e.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(
        e.adoptedStyleSheets,
        this.mirror.getId(H.host(e))
      ), this.restoreHandlers.push(
        Da(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          e
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(e) {
    !e.contentWindow || !e.contentDocument || this.patchAttachShadow(
      e.contentWindow.Element,
      e.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(e, t) {
    const i = this;
    this.restoreHandlers.push(
      pt(
        e.prototype,
        "attachShadow",
        function(r) {
          return function(n) {
            const l = r.call(this, n), a = H.shadowRoot(this);
            return a && Oa(this) && i.addShadowRoot(a, t), l;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((e) => {
      try {
        e();
      } catch (t) {
      }
    }), this.restoreHandlers = [], this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var st = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Cf = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (var Gi = 0; Gi < st.length; Gi++)
  Cf[st.charCodeAt(Gi)] = Gi;
var vf = function(s) {
  var e = new Uint8Array(s), t, i = e.length, r = "";
  for (t = 0; t < i; t += 3)
    r += st[e[t] >> 2], r += st[(e[t] & 3) << 4 | e[t + 1] >> 4], r += st[(e[t + 1] & 15) << 2 | e[t + 2] >> 6], r += st[e[t + 2] & 63];
  return i % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : i % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
};
const wo = /* @__PURE__ */ new Map();
function xf(s, e) {
  let t = wo.get(s);
  return t || (t = /* @__PURE__ */ new Map(), wo.set(s, t)), t.has(e) || t.set(e, []), t.get(e);
}
const Aa = (s, e, t) => {
  if (!s || !(Qa(s, e) || typeof s == "object"))
    return;
  const i = s.constructor.name, r = xf(t, i);
  let n = r.indexOf(s);
  return n === -1 && (n = r.length, r.push(s)), n;
};
function vi(s, e, t) {
  if (s instanceof Array)
    return s.map((i) => vi(i, e, t));
  if (s === null)
    return s;
  if (s instanceof Float32Array || s instanceof Float64Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Uint8Array || s instanceof Uint16Array || s instanceof Int16Array || s instanceof Int8Array || s instanceof Uint8ClampedArray)
    return {
      rr_type: s.constructor.name,
      args: [Object.values(s)]
    };
  if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    s instanceof ArrayBuffer
  ) {
    const i = s.constructor.name, r = vf(s);
    return {
      rr_type: i,
      base64: r
    };
  } else {
    if (s instanceof DataView)
      return {
        rr_type: s.constructor.name,
        args: [
          vi(s.buffer, e, t),
          s.byteOffset,
          s.byteLength
        ]
      };
    if (s instanceof HTMLImageElement) {
      const i = s.constructor.name, { src: r } = s;
      return {
        rr_type: i,
        src: r
      };
    } else if (s instanceof HTMLCanvasElement) {
      const i = "HTMLImageElement", r = s.toDataURL();
      return {
        rr_type: i,
        src: r
      };
    } else {
      if (s instanceof ImageData)
        return {
          rr_type: s.constructor.name,
          args: [vi(s.data, e, t), s.width, s.height]
        };
      if (Qa(s, e) || typeof s == "object") {
        const i = s.constructor.name, r = Aa(s, e, t);
        return {
          rr_type: i,
          index: r
        };
      }
    }
  }
  return s;
}
const ja = (s, e, t) => s.map((i) => vi(i, e, t)), Qa = (s, e) => !![
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLFramebuffer",
  "WebGLProgram",
  "WebGLRenderbuffer",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLTexture",
  "WebGLUniformLocation",
  "WebGLVertexArrayObject",
  // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
  "WebGLVertexArrayObjectOES"
].filter(
  (r) => typeof e[r] == "function"
).find(
  (r) => s instanceof e[r]
);
function Lf(s, e, t, i) {
  const r = [], n = Object.getOwnPropertyNames(
    e.CanvasRenderingContext2D.prototype
  );
  for (const l of n)
    try {
      if (typeof e.CanvasRenderingContext2D.prototype[l] != "function")
        continue;
      const a = pt(
        e.CanvasRenderingContext2D.prototype,
        l,
        function(o) {
          return function(...c) {
            return oe(this.canvas, t, i, !0) || setTimeout(() => {
              const u = ja(c, e, this);
              s(this.canvas, {
                type: ht["2D"],
                property: l,
                args: u
              });
            }, 0), o.apply(this, c);
          };
        }
      );
      r.push(a);
    } catch (a) {
      const o = cs(
        e.CanvasRenderingContext2D.prototype,
        l,
        {
          set(c) {
            s(this.canvas, {
              type: ht["2D"],
              property: l,
              args: [c],
              setter: !0
            });
          }
        }
      );
      r.push(o);
    }
  return () => {
    r.forEach((l) => l());
  };
}
function Yf(s) {
  return s === "experimental-webgl" ? "webgl" : s;
}
function Co(s, e, t, i) {
  const r = [];
  try {
    const n = pt(
      s.HTMLCanvasElement.prototype,
      "getContext",
      function(l) {
        return function(a, ...o) {
          if (!oe(this, e, t, !0)) {
            const c = Yf(a);
            if ("__context" in this || (this.__context = c), i && ["webgl", "webgl2"].includes(c))
              if (o[0] && typeof o[0] == "object") {
                const u = o[0];
                u.preserveDrawingBuffer || (u.preserveDrawingBuffer = !0);
              } else
                o.splice(0, 1, {
                  preserveDrawingBuffer: !0
                });
          }
          return l.apply(this, [a, ...o]);
        };
      }
    );
    r.push(n);
  } catch (n) {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    r.forEach((n) => n());
  };
}
function vo(s, e, t, i, r, n) {
  const l = [], a = Object.getOwnPropertyNames(s);
  for (const o of a)
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      ![
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(o)
    )
      try {
        if (typeof s[o] != "function")
          continue;
        const c = pt(
          s,
          o,
          function(u) {
            return function(...d) {
              const h = u.apply(this, d);
              if (Aa(h, n, this), "tagName" in this.canvas && !oe(
                this.canvas,
                i,
                r,
                !0
              )) {
                const p = ja(d, n, this), y = {
                  type: e,
                  property: o,
                  args: p
                };
                t(this.canvas, y);
              }
              return h;
            };
          }
        );
        l.push(c);
      } catch (c) {
        const u = cs(s, o, {
          set(d) {
            t(this.canvas, {
              type: e,
              property: o,
              args: [d],
              setter: !0
            });
          }
        });
        l.push(u);
      }
  return l;
}
function Nf(s, e, t, i) {
  const r = [];
  return r.push(
    ...vo(
      e.WebGLRenderingContext.prototype,
      ht.WebGL,
      s,
      t,
      i,
      e
    )
  ), typeof e.WebGL2RenderingContext != "undefined" && r.push(
    ...vo(
      e.WebGL2RenderingContext.prototype,
      ht.WebGL2,
      s,
      t,
      i,
      e
    )
  ), () => {
    r.forEach((n) => n());
  };
}
const _a = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIGxldCBsb2dEZWJ1ZyA9IGZhbHNlOwogIGNvbnN0IGRlYnVnID0gKC4uLmFyZ3MpID0+IHsKICAgIGlmIChsb2dEZWJ1ZykgewogICAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpOwogICAgfQogIH07CiAgd29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uKGUpIHsKICAgIGxvZ0RlYnVnID0gISFlLmRhdGEubG9nRGVidWc7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGR4LCBkeSwgZHcsIGRoLCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhOwogICAgICBjb25zdCB0cmFuc3BhcmVudEJhc2U2NCA9IGdldFRyYW5zcGFyZW50QmxvYkZvcigKICAgICAgICB3aWR0aCwKICAgICAgICBoZWlnaHQsCiAgICAgICAgZGF0YVVSTE9wdGlvbnMKICAgICAgKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgICAgYml0bWFwLmNsb3NlKCk7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGU7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICBpZiAoIWxhc3RCbG9iTWFwLmhhcyhpZCkgJiYgYXdhaXQgdHJhbnNwYXJlbnRCYXNlNjQgPT09IGJhc2U2NCkgewogICAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gY2FudmFzIGJpdG1hcCBpcyB0cmFuc3BhcmVudCIsIHsKICAgICAgICAgIGlkLAogICAgICAgICAgYmFzZTY0CiAgICAgICAgfSk7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCwgc3RhdHVzOiAidHJhbnNwYXJlbnQiIH0pOwogICAgICB9CiAgICAgIGlmIChsYXN0QmxvYk1hcC5nZXQoaWQpID09PSBiYXNlNjQpIHsKICAgICAgICBkZWJ1ZygiW2hpZ2hsaWdodC13b3JrZXJdIGNhbnZhcyBiaXRtYXAgaXMgdW5jaGFuZ2VkIiwgewogICAgICAgICAgaWQsCiAgICAgICAgICBiYXNlNjQKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQsIHN0YXR1czogInVuY2hhbmdlZCIgfSk7CiAgICAgIH0KICAgICAgY29uc3QgbXNnID0gewogICAgICAgIGlkLAogICAgICAgIHR5cGUsCiAgICAgICAgYmFzZTY0LAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkeCwKICAgICAgICBkeSwKICAgICAgICBkdywKICAgICAgICBkaAogICAgICB9OwogICAgICBkZWJ1ZygiW2hpZ2hsaWdodC13b3JrZXJdIGNhbnZhcyBiaXRtYXAgcHJvY2Vzc2VkIiwgbXNnKTsKICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7CiAgICAgIGxhc3RCbG9iTWFwLnNldChpZCwgYmFzZTY0KTsKICAgIH0gZWxzZSB7CiAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gbm8gb2Zmc2NyZWVuY2FudmFzIHN1cHBvcnQiLCB7CiAgICAgICAgaWQ6IGUuZGF0YS5pZAogICAgICB9KTsKICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQsIHN0YXR1czogInVuc3VwcG9ydGVkIiB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUJpWEpSZjQ3LmpzLm1hcAo=", kf = (s) => Uint8Array.from(atob(s), (e) => e.charCodeAt(0)), xo = typeof self != "undefined" && self.Blob && new Blob([kf(_a)], { type: "text/javascript;charset=utf-8" });
function Tf(s) {
  let e;
  try {
    if (e = xo && (self.URL || self.webkitURL).createObjectURL(xo), !e) throw "";
    const t = new Worker(e, {
      name: s == null ? void 0 : s.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch (t) {
    return new Worker(
      "data:text/javascript;base64," + _a,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
class Jf {
  constructor(e) {
    I(this, "pendingCanvasMutations", /* @__PURE__ */ new Map()), I(this, "rafStamps", { latestId: 0, invokeId: null }), I(this, "mirror"), I(this, "logger"), I(this, "worker"), I(this, "snapshotInProgressMap", /* @__PURE__ */ new Map()), I(this, "lastSnapshotTime", /* @__PURE__ */ new Map()), I(this, "options"), I(this, "mutationCb"), I(this, "resetObservers"), I(this, "frozen", !1), I(this, "locked", !1), I(this, "processMutation", (u, d) => {
      (this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(u) || this.pendingCanvasMutations.set(u, []), this.pendingCanvasMutations.get(u).push(d);
    });
    const {
      sampling: t,
      win: i,
      blockClass: r,
      blockSelector: n,
      recordCanvas: l,
      recordVideos: a,
      initialSnapshotDelay: o,
      dataURLOptions: c
    } = e;
    this.mutationCb = e.mutationCb, this.mirror = e.mirror, this.logger = e.logger, this.worker = new Tf(), this.worker.onmessage = (u) => {
      const { id: d } = u.data;
      if (this.snapshotInProgressMap.set(d, !1), !("base64" in u.data)) {
        this.debug(null, "canvas worker received empty message", {
          data: u.data,
          status: u.data.status
        });
        return;
      }
      const { base64: h, type: p, dx: y, dy: f, dw: m, dh: W } = u.data, S = {
        id: d,
        type: ht["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [y, f, m, W]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64: h }],
                    type: p
                  }
                ]
              },
              y,
              f,
              m,
              W
            ]
          }
        ]
      };
      this.debug(null, "canvas worker recording mutation", S), this.mutationCb(S);
    }, this.options = e, l && t === "all" ? (this.debug(null, "initializing canvas mutation observer", { sampling: t }), this.initCanvasMutationObserver(i, r, n)) : l && typeof t == "number" && (this.debug(null, "initializing canvas fps observer", { sampling: t }), this.initCanvasFPSObserver(
      a,
      t,
      i,
      r,
      n,
      {
        initialSnapshotDelay: o,
        dataURLOptions: c
      },
      e.resizeFactor,
      e.maxSnapshotDimension
    ));
  }
  reset() {
    this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = !0;
  }
  unfreeze() {
    this.frozen = !1;
  }
  lock() {
    this.locked = !0;
  }
  unlock() {
    this.locked = !1;
  }
  debug(e, ...t) {
    if (!this.logger) return;
    const i = this.mirror.getId(e);
    let r = "[highlight-canvas-manager]";
    e && (r = `[highlight-canvas] [id:${i}]`, e.tagName.toLowerCase() === "canvas" && (r += ` [ctx:${e.__context}]`)), this.logger.debug(r, e, ...t);
  }
  snapshot(e) {
    return ee(this, null, function* () {
      var t;
      const i = this.mirror.getId(e);
      if (this.snapshotInProgressMap.get(i)) {
        this.debug(e, "snapshotting already in progress for", i);
        return;
      }
      const r = 1e3 / (typeof this.options.samplingManual == "number" ? this.options.samplingManual : 1), n = this.lastSnapshotTime.get(i);
      if (!(n && (/* @__PURE__ */ new Date()).getTime() - n < r)) {
        if (this.debug(e, "starting snapshotting"), e.width === 0 || e.height === 0) {
          this.debug(e, "not yet ready", {
            width: e.width,
            height: e.height
          });
          return;
        }
        this.lastSnapshotTime.set(i, (/* @__PURE__ */ new Date()).getTime()), this.snapshotInProgressMap.set(i, !0);
        try {
          if (this.options.clearWebGLBuffer !== !1 && ["webgl", "webgl2"].includes(e.__context)) {
            const u = e.getContext(e.__context);
            ((t = u == null ? void 0 : u.getContextAttributes()) == null ? void 0 : t.preserveDrawingBuffer) === !1 && (u.clear(u.COLOR_BUFFER_BIT), this.debug(e, "cleared webgl canvas to load it into memory", {
              attributes: u == null ? void 0 : u.getContextAttributes()
            }));
          }
          if (e.width === 0 || e.height === 0) {
            this.debug(e, "not yet ready", {
              width: e.width,
              height: e.height
            });
            return;
          }
          let l = this.options.resizeFactor || 1;
          if (this.options.maxSnapshotDimension) {
            const u = Math.max(e.width, e.height);
            l = Math.min(l, this.options.maxSnapshotDimension / u);
          }
          const a = e.width * l, o = e.height * l, c = yield createImageBitmap(e, {
            resizeWidth: a,
            resizeHeight: o
          });
          this.debug(e, "created image bitmap", {
            width: c.width,
            height: c.height
          }), this.worker.postMessage(
            {
              id: i,
              bitmap: c,
              width: a,
              height: o,
              dx: 0,
              dy: 0,
              dw: e.width,
              dh: e.height,
              dataURLOptions: this.options.dataURLOptions,
              logDebug: !!this.logger
            },
            [c]
          ), this.debug(e, "sent message");
        } catch (l) {
          this.debug(e, "failed to snapshot", l);
        } finally {
          this.snapshotInProgressMap.set(i, !1);
        }
      }
    });
  }
  initCanvasFPSObserver(e, t, i, r, n, l, a, o) {
    const c = Co(
      i,
      r,
      n,
      !0
    ), u = 1e3 / t;
    let d = 0, h;
    const p = /* @__PURE__ */ new Map(), y = (S, g) => {
      const Z = [];
      S.querySelectorAll(g).forEach((V) => Z.push(V));
      const C = document.createNodeIterator(S, Node.ELEMENT_NODE);
      let J;
      for (; J = C.nextNode(); )
        J != null && J.shadowRoot && Z.push(...y(J.shadowRoot, g));
      return Z;
    }, f = (S) => {
      const g = [];
      return y(i.document, "canvas").forEach((Z) => {
        if (!oe(Z, r, n, !0)) {
          this.debug(Z, "discovered canvas"), g.push(Z);
          const C = this.mirror.getId(Z);
          p.has(C) || p.set(C, S);
        }
      }), g;
    }, m = (S) => {
      const g = [];
      return e && y(i.document, "video").forEach((Z) => {
        if (!(Z.src !== "" && Z.src.indexOf("blob:") === -1) && !oe(Z, r, n, !0)) {
          g.push(Z);
          const C = this.mirror.getId(Z);
          p.has(C) || p.set(C, S);
        }
      }), g;
    }, W = (S) => ee(this, null, function* () {
      if (d && S - d < u) {
        h = requestAnimationFrame(W);
        return;
      }
      d = S;
      const g = (C) => {
        const J = this.mirror.getId(C), V = p.get(J), R = !l.initialSnapshotDelay || S - V > l.initialSnapshotDelay;
        return this.debug(C, {
          delay: l.initialSnapshotDelay,
          delta: S - V,
          hadLoadingTime: R
        }), R;
      }, Z = [];
      Z.push(
        ...f(S).filter(g).map((C) => this.snapshot(C))
      ), Z.push(
        ...m(S).filter(g).map((C) => ee(this, null, function* () {
          this.debug(C, "starting video snapshotting");
          const J = this.mirror.getId(C);
          if (this.snapshotInProgressMap.get(J)) {
            this.debug(
              C,
              "video snapshotting already in progress for",
              J
            );
            return;
          }
          this.snapshotInProgressMap.set(J, !0);
          try {
            const { width: V, height: R } = C.getBoundingClientRect(), { actualWidth: F, actualHeight: v } = {
              actualWidth: C.videoWidth,
              actualHeight: C.videoHeight
            }, E = Math.max(F, v);
            if (E === 0) {
              this.debug(C, "not yet ready", {
                width: C.width,
                height: C.height,
                actualWidth: F,
                actualHeight: v,
                boxWidth: V,
                boxHeight: R
              });
              return;
            }
            let te = a || 1;
            o && (te = Math.min(te, o / E));
            const N = F * te, b = v * te, G = yield createImageBitmap(C, {
              resizeWidth: N,
              resizeHeight: b
            }), x = Math.max(V, R) / E, j = F * x, U = v * x, L = (V - j) / 2, le = (R - U) / 2;
            this.debug(C, "created image bitmap", {
              actualWidth: F,
              actualHeight: v,
              boxWidth: V,
              boxHeight: R,
              outputWidth: j,
              outputHeight: U,
              resizeWidth: N,
              resizeHeight: b,
              scale: te,
              outputScale: x,
              offsetX: L,
              offsetY: le
            }), this.worker.postMessage(
              {
                id: J,
                bitmap: G,
                width: N,
                height: b,
                dx: L,
                dy: le,
                dw: j,
                dh: U,
                dataURLOptions: l.dataURLOptions,
                logDebug: !!this.logger
              },
              [G]
            ), this.debug(C, "send message");
          } catch (V) {
            this.debug(C, "failed to snapshot", V);
          } finally {
            this.snapshotInProgressMap.set(J, !1);
          }
        }))
      ), yield Promise.all(Z).catch(console.error), h = requestAnimationFrame(W);
    });
    h = requestAnimationFrame(W), this.resetObservers = () => {
      c(), h && cancelAnimationFrame(h);
    };
  }
  initCanvasMutationObserver(e, t, i) {
    this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
    const r = Co(
      e,
      t,
      i,
      !1
    ), n = Lf(
      this.processMutation.bind(this),
      e,
      t,
      i
    ), l = Nf(
      this.processMutation.bind(this),
      e,
      t,
      i
    );
    this.resetObservers = () => {
      r(), n(), l();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const e = (t) => {
      this.rafStamps.latestId = t, requestAnimationFrame(e);
    };
    requestAnimationFrame(e);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (e, t) => {
        const i = this.mirror.getId(t);
        this.flushPendingCanvasMutationFor(t, i);
      }
    ), requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(e, t) {
    if (this.frozen || this.locked)
      return;
    const i = this.pendingCanvasMutations.get(e);
    if (!i || t === -1) return;
    const r = i.map((l) => {
      const c = l, { type: a } = c;
      return pe(c, ["type"]);
    }), { type: n } = i[0];
    this.mutationCb({ id: t, type: n, commands: r }), this.pendingCanvasMutations.delete(e);
  }
}
class Uf {
  constructor(e) {
    I(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet()), I(this, "mutationCb"), I(this, "adoptedStyleSheetCb"), I(this, "styleMirror", new rf()), this.mutationCb = e.mutationCb, this.adoptedStyleSheetCb = e.adoptedStyleSheetCb;
  }
  attachLinkElement(e, t) {
    "_cssText" in t.attributes && this.mutationCb({
      adds: [],
      removes: [],
      texts: [],
      attributes: [
        {
          id: t.id,
          attributes: t.attributes
        }
      ]
    }), this.trackLinkElement(e);
  }
  trackLinkElement(e) {
    this.trackedLinkElements.has(e) || (this.trackedLinkElements.add(e), this.trackStylesheetInLinkElement(e));
  }
  adoptStyleSheets(e, t) {
    if (e.length === 0) return;
    const i = {
      id: t,
      styleIds: []
    }, r = [];
    for (const n of e) {
      let l;
      this.styleMirror.has(n) ? l = this.styleMirror.getId(n) : (l = this.styleMirror.add(n), r.push({
        styleId: l,
        rules: Array.from(n.rules || CSSRule, (a, o) => ({
          rule: rl(a, n.href),
          index: o
        }))
      })), i.styleIds.push(l);
    }
    r.length > 0 && (i.styles = r), this.adoptedStyleSheetCb(i);
  }
  reset() {
    this.styleMirror.reset(), this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(e) {
  }
}
class Ff {
  constructor() {
    I(this, "nodeMap", /* @__PURE__ */ new WeakMap()), I(this, "active", !1);
  }
  inOtherBuffer(e, t) {
    const i = this.nodeMap.get(e);
    return i && Array.from(i).some((r) => r !== t);
  }
  add(e, t) {
    this.active || (this.active = !0, requestAnimationFrame(() => {
      this.nodeMap = /* @__PURE__ */ new WeakMap(), this.active = !1;
    })), this.nodeMap.set(e, (this.nodeMap.get(e) || /* @__PURE__ */ new Set()).add(t));
  }
  destroy() {
  }
}
let q, xi, xt, Bi = !1;
try {
  if (Array.from([1], (s) => s * 2)[0] !== 2) {
    const s = document.createElement("iframe");
    document.body.appendChild(s), Array.from = ((vn = s.contentWindow) == null ? void 0 : vn.Array.from) || Array.from, document.body.removeChild(s);
  }
} catch (s) {
  console.debug("Unable to override Array.from", s);
}
const Ge = Nu();
function Ye(s = {}) {
  var e, t, i, r, n, l, a, o;
  const {
    emit: c,
    checkoutEveryNms: u,
    checkoutEveryNth: d,
    blockClass: h = "highlight-block",
    blockSelector: p = null,
    ignoreClass: y = "highlight-ignore",
    ignoreSelector: f = null,
    maskTextClass: m = "highlight-mask",
    maskTextSelector: W = null,
    inlineStylesheet: S = !0,
    maskAllInputs: g,
    maskInputOptions: Z,
    slimDOMOptions: C,
    maskInputFn: J,
    maskTextFn: V = Ur,
    hooks: R,
    packFn: F,
    sampling: v = {},
    mousemoveWait: E,
    recordDOM: te = !0,
    recordCanvas: N = !1,
    recordCrossOriginIframes: b = !1,
    recordAfter: G = s.recordAfter === "DOMContentLoaded" ? s.recordAfter : "load",
    userTriggeredOnInput: x = !1,
    collectFonts: j = !1,
    inlineImages: U = !1,
    plugins: L,
    keepIframeSrcFn: le = () => !1,
    privacySetting: ne = "default",
    ignoreCSSAttributes: ft = /* @__PURE__ */ new Set([]),
    errorHandler: gc,
    logger: Zc
  } = s, jt = X(X({}, s.dataURLOptions), (t = (e = s.sampling) == null ? void 0 : e.canvas) == null ? void 0 : t.dataURLOptions);
  df(gc);
  const Qt = b ? window.parent === window : !0;
  let bt = !1;
  if (!Qt)
    try {
      window.parent.document && (bt = !1);
    } catch (P) {
      bt = !0;
    }
  if (Qt && !c)
    throw new Error("emit function is required");
  if (!Qt && !bt)
    return () => {
    };
  E !== void 0 && v.mousemove === void 0 && (v.mousemove = E), Ge.reset();
  const ps = g === !0 ? {
    color: !0,
    date: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
    textarea: !0,
    select: !0,
    password: !0
  } : Z !== void 0 ? Z : { password: !0 }, ms = C === !0 || C === "all" ? {
    script: !0,
    comment: !0,
    headFavicon: !0,
    headWhitespace: !0,
    headMetaSocial: !0,
    headMetaRobots: !0,
    headMetaHttpEquiv: !0,
    headMetaVerification: !0,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: C === "all",
    headMetaDescKeywords: C === "all",
    headTitleMutations: C === "all"
  } : C || {};
  sf();
  let pn, fs = 0;
  const mn = (P) => {
    for (const ge of L || [])
      ge.eventProcessor && (P = ge.eventProcessor(P));
    return F && // Disable packing events which will be emitted to parent frames.
    !bt && (P = F(P)), P;
  };
  q = (P, ge) => {
    var _;
    const $ = P;
    if ($.timestamp = Ei(), (_ = Ee[0]) != null && _.isFrozen() && $.type !== O.FullSnapshot && !($.type === O.IncrementalSnapshot && $.data.source === M.Mutation) && Ee.forEach((We) => We.unfreeze()), Qt)
      c == null || c(mn($), ge);
    else if (bt) {
      const We = {
        type: "rrweb",
        event: mn($),
        origin: window.location.origin,
        isCheckout: ge
      };
      window.parent.postMessage(We, "*");
    }
    if ($.type === O.FullSnapshot)
      pn = $, fs = 0;
    else if ($.type === O.IncrementalSnapshot) {
      if ($.data.source === M.Mutation && $.data.isAttachIframe)
        return;
      fs++;
      const We = d && fs >= d, A = u && $.timestamp - pn.timestamp > u;
      (We || A) && xi(!0);
    }
  };
  const _t = (P) => {
    q({
      type: O.IncrementalSnapshot,
      data: X({
        source: M.Mutation
      }, P)
    });
  }, fn = (P) => q({
    type: O.IncrementalSnapshot,
    data: X({
      source: M.Scroll
    }, P)
  }), bn = (P) => q({
    type: O.IncrementalSnapshot,
    data: X({
      source: M.CanvasMutation
    }, P)
  }), Gc = (P) => q({
    type: O.IncrementalSnapshot,
    data: X({
      source: M.AdoptedStyleSheet
    }, P)
  }), ze = new Uf({
    mutationCb: _t,
    adoptedStyleSheetCb: Gc
  }), Oe = new Rf({
    mirror: Ge,
    mutationCb: _t,
    stylesheetManager: ze,
    recordCrossOriginIframes: b,
    wrappedEmit: q
  });
  for (const P of L || [])
    P.getMirror && P.getMirror({
      nodeMirror: Ge,
      crossOriginIframeMirror: Oe.crossOriginIframeMirror,
      crossOriginIframeStyleMirror: Oe.crossOriginIframeStyleMirror
    });
  const bs = new Ff();
  xt = new Jf({
    recordCanvas: N,
    recordVideos: U,
    mutationCb: bn,
    win: window,
    blockClass: h,
    blockSelector: p,
    mirror: Ge,
    sampling: (i = v == null ? void 0 : v.canvas) == null ? void 0 : i.fps,
    samplingManual: (r = v == null ? void 0 : v.canvas) == null ? void 0 : r.fpsManual,
    clearWebGLBuffer: (n = v == null ? void 0 : v.canvas) == null ? void 0 : n.clearWebGLBuffer,
    initialSnapshotDelay: (l = v == null ? void 0 : v.canvas) == null ? void 0 : l.initialSnapshotDelay,
    dataURLOptions: jt,
    resizeFactor: (a = v == null ? void 0 : v.canvas) == null ? void 0 : a.resizeFactor,
    maxSnapshotDimension: (o = v == null ? void 0 : v.canvas) == null ? void 0 : o.maxSnapshotDimension,
    logger: Zc
  });
  const $t = new wf({
    mutationCb: _t,
    scrollCb: fn,
    bypassOptions: {
      blockClass: h,
      blockSelector: p,
      maskTextClass: m,
      maskTextSelector: W,
      inlineStylesheet: S,
      maskInputOptions: ps,
      dataURLOptions: jt,
      maskTextFn: V,
      maskInputFn: J,
      recordCanvas: N,
      inlineImages: U,
      privacySetting: ne,
      sampling: v,
      slimDOMOptions: ms,
      iframeManager: Oe,
      stylesheetManager: ze,
      canvasManager: xt,
      keepIframeSrcFn: le,
      processedNodeManager: bs
    },
    mirror: Ge
  });
  xi = (P = !1) => {
    if (!te)
      return;
    q(
      {
        type: O.Meta,
        data: {
          href: window.location.href,
          width: Ua(),
          height: Ja()
        }
      },
      P
    ), ze.reset(), $t.init(), Ee.forEach((_) => _.lock());
    const ge = ad(document, {
      mirror: Ge,
      blockClass: h,
      blockSelector: p,
      maskTextClass: m,
      maskTextSelector: W,
      inlineStylesheet: S,
      maskAllInputs: ps,
      maskTextFn: V,
      maskInputFn: J,
      slimDOM: ms,
      dataURLOptions: jt,
      recordCanvas: N,
      inlineImages: U,
      privacySetting: ne,
      onSerialize: (_) => {
        Ha(_, Ge) && Oe.addIframe(_), Ma(_, Ge) && ze.trackLinkElement(_), Cr(_) && $t.addShadowRoot(H.shadowRoot(_), document);
      },
      onIframeLoad: (_, $) => {
        Oe.attachIframe(_, $), $t.observeAttachShadow(_);
      },
      onStylesheetLoad: (_, $) => {
        ze.attachLinkElement(_, $);
      },
      keepIframeSrcFn: le
    });
    if (!ge)
      return console.warn("Failed to snapshot the document");
    q(
      {
        type: O.FullSnapshot,
        data: {
          node: ge,
          initialOffset: Ta(window)
        }
      },
      P
    ), Ee.forEach((_) => _.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && ze.adoptStyleSheets(
      document.adoptedStyleSheets,
      Ge.getId(document)
    );
  };
  try {
    const P = [], ge = ($) => {
      var We;
      return z(Xf)(
        {
          mutationCb: _t,
          mousemoveCb: (A, ys) => q({
            type: O.IncrementalSnapshot,
            data: {
              source: ys,
              positions: A
            }
          }),
          mouseInteractionCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.MouseInteraction
            }, A)
          }),
          scrollCb: fn,
          viewportResizeCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.ViewportResize
            }, A)
          }),
          inputCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.Input
            }, A)
          }),
          mediaInteractionCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.MediaInteraction
            }, A)
          }),
          styleSheetRuleCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.StyleSheetRule
            }, A)
          }),
          styleDeclarationCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.StyleDeclaration
            }, A)
          }),
          canvasMutationCb: bn,
          fontCb: (A) => q({
            type: O.IncrementalSnapshot,
            data: X({
              source: M.Font
            }, A)
          }),
          selectionCb: (A) => {
            q({
              type: O.IncrementalSnapshot,
              data: X({
                source: M.Selection
              }, A)
            });
          },
          customElementCb: (A) => {
            q({
              type: O.IncrementalSnapshot,
              data: X({
                source: M.CustomElement
              }, A)
            });
          },
          blockClass: h,
          ignoreClass: y,
          ignoreSelector: f,
          maskTextClass: m,
          maskTextSelector: W,
          maskInputOptions: ps,
          inlineStylesheet: S,
          sampling: v,
          recordDOM: te,
          recordCanvas: N,
          inlineImages: U,
          userTriggeredOnInput: x,
          collectFonts: j,
          doc: $,
          maskInputFn: J,
          maskTextFn: V,
          keepIframeSrcFn: le,
          blockSelector: p,
          slimDOMOptions: ms,
          dataURLOptions: jt,
          mirror: Ge,
          iframeManager: Oe,
          stylesheetManager: ze,
          shadowDomManager: $t,
          processedNodeManager: bs,
          canvasManager: xt,
          ignoreCSSAttributes: ft,
          privacySetting: ne,
          plugins: ((We = L == null ? void 0 : L.filter((A) => A.observer)) == null ? void 0 : We.map((A) => ({
            observer: A.observer,
            options: A.options,
            callback: (ys) => q({
              type: O.Plugin,
              data: {
                plugin: A.name,
                payload: ys
              }
            })
          }))) || []
        },
        R
      );
    };
    Oe.addLoadListener(($) => {
      try {
        P.push(ge($.contentDocument));
      } catch (We) {
        console.warn(We);
      }
    });
    const _ = () => {
      xi(), P.push(ge(document)), Bi = !0;
    };
    return document.readyState === "interactive" || document.readyState === "complete" ? _() : (P.push(
      ue("DOMContentLoaded", () => {
        q({
          type: O.DomContentLoaded,
          data: {}
        }), G === "DOMContentLoaded" && _();
      })
    ), P.push(
      ue(
        "load",
        () => {
          q({
            type: O.Load,
            data: {}
          }), G === "load" && _();
        },
        window
      )
    )), () => {
      P.forEach(($) => $()), bs.destroy(), Bi = !1, hf();
    };
  } catch (P) {
    console.warn(P);
  }
}
Ye.addCustomEvent = (s, e) => {
  Bi && q({
    type: O.Custom,
    data: {
      tag: s,
      payload: e
    }
  });
};
Ye.freezePage = () => {
  Ee.forEach((s) => s.freeze());
};
Ye.takeFullSnapshot = (s) => {
  if (!Bi)
    throw new Error("please take full snapshot after start recording");
  xi(s);
};
Ye.snapshotCanvas = (s) => ee(void 0, null, function* () {
  if (!xt)
    throw new Error("canvas manager is not initialized");
  yield xt.snapshot(s);
});
Ye.mirror = Ge;
var Lo;
(function(s) {
  s[s.NotStarted = 0] = "NotStarted", s[s.Running = 1] = "Running", s[s.Stopped = 2] = "Stopped";
})(Lo || (Lo = {}));
const { addCustomEvent: Yo } = Ye;
var Di = function() {
  return Di = Object.assign || function(e) {
    for (var t, i = 1, r = arguments.length; i < r; i++) {
      t = arguments[i];
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    }
    return e;
  }, Di.apply(this, arguments);
}, Li = /* @__PURE__ */ new Map(), xr = /* @__PURE__ */ new Map(), $a = !0, Ai = !1;
function qa(s) {
  return s.replace(/[\s,]+/g, " ").trim();
}
function Kf(s) {
  return qa(s.source.body.substring(s.start, s.end));
}
function Hf(s) {
  var e = /* @__PURE__ */ new Set(), t = [];
  return s.definitions.forEach(function(i) {
    if (i.kind === "FragmentDefinition") {
      var r = i.name.value, n = Kf(i.loc), l = xr.get(r);
      l && !l.has(n) ? $a && console.warn("Warning: fragment with name " + r + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : l || xr.set(r, l = /* @__PURE__ */ new Set()), l.add(n), e.has(n) || (e.add(n), t.push(i));
    } else
      t.push(i);
  }), Di(Di({}, s), { definitions: t });
}
function Mf(s) {
  var e = new Set(s.definitions);
  e.forEach(function(i) {
    i.loc && delete i.loc, Object.keys(i).forEach(function(r) {
      var n = i[r];
      n && typeof n == "object" && e.add(n);
    });
  });
  var t = s.loc;
  return t && (delete t.startToken, delete t.endToken), s;
}
function zf(s) {
  var e = qa(s);
  if (!Li.has(e)) {
    var t = el(s, {
      experimentalFragmentVariables: Ai,
      allowLegacyFragmentVariables: Ai
    });
    if (!t || t.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    Li.set(e, Mf(Hf(t)));
  }
  return Li.get(e);
}
function he(s) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  typeof s == "string" && (s = [s]);
  var i = s[0];
  return e.forEach(function(r, n) {
    r && r.kind === "Document" ? i += r.loc.source.body : i += r, i += s[n + 1];
  }), zf(i);
}
function Of() {
  Li.clear(), xr.clear();
}
function Ef() {
  $a = !1;
}
function Pf() {
  Ai = !0;
}
function Bf() {
  Ai = !1;
}
var Wt = {
  gql: he,
  resetCaches: Of,
  disableFragmentWarnings: Ef,
  enableExperimentalFragmentVariables: Pf,
  disableExperimentalFragmentVariables: Bf
};
(function(s) {
  s.gql = Wt.gql, s.resetCaches = Wt.resetCaches, s.disableFragmentWarnings = Wt.disableFragmentWarnings, s.enableExperimentalFragmentVariables = Wt.enableExperimentalFragmentVariables, s.disableExperimentalFragmentVariables = Wt.disableExperimentalFragmentVariables;
})(he || (he = {}));
he.default = he;
var No;
(function(s) {
  s.BillingQuotaExceeded = "BillingQuotaExceeded";
})(No || (No = {}));
const ec = he`
	mutation PushPayload(
		$session_secure_id: String!
		$payload_id: ID!
		$events: ReplayEventsInput!
		$messages: String!
		$resources: String!
		$web_socket_events: String!
		$errors: [ErrorObjectInput]!
		$is_beacon: Boolean
		$has_session_unloaded: Boolean
		$highlight_logs: String
	) {
		pushPayload(
			session_secure_id: $session_secure_id
			payload_id: $payload_id
			events: $events
			messages: $messages
			resources: $resources
			web_socket_events: $web_socket_events
			errors: $errors
			is_beacon: $is_beacon
			has_session_unloaded: $has_session_unloaded
			highlight_logs: $highlight_logs
		)
	}
`, Df = he`
	mutation PushPayloadCompressed(
		$session_secure_id: String!
		$payload_id: ID!
		$data: String!
	) {
		pushPayloadCompressed(
			session_secure_id: $session_secure_id
			payload_id: $payload_id
			data: $data
		)
	}
`, Af = he`
	mutation identifySession(
		$session_secure_id: String!
		$user_identifier: String!
		$user_object: Any
	) {
		identifySession(
			session_secure_id: $session_secure_id
			user_identifier: $user_identifier
			user_object: $user_object
		)
	}
`, jf = he`
	mutation addSessionProperties(
		$session_secure_id: String!
		$properties_object: Any
	) {
		addSessionProperties(
			session_secure_id: $session_secure_id
			properties_object: $properties_object
		)
	}
`, Qf = he`
	mutation pushMetrics($metrics: [MetricInput]!) {
		pushMetrics(metrics: $metrics)
	}
`, _f = he`
	mutation addSessionFeedback(
		$session_secure_id: String!
		$user_name: String
		$user_email: String
		$verbatim: String!
		$timestamp: Timestamp!
	) {
		addSessionFeedback(
			session_secure_id: $session_secure_id
			user_name: $user_name
			user_email: $user_email
			verbatim: $verbatim
			timestamp: $timestamp
		)
	}
`, $f = he`
	mutation initializeSession(
		$session_secure_id: String!
		$organization_verbose_id: String!
		$enable_strict_privacy: Boolean!
		$privacy_setting: String!
		$enable_recording_network_contents: Boolean!
		$clientVersion: String!
		$firstloadVersion: String!
		$clientConfig: String!
		$environment: String!
		$id: String!
		$appVersion: String
		$serviceName: String!
		$client_id: String!
		$network_recording_domains: [String!]
		$disable_session_recording: Boolean
	) {
		initializeSession(
			session_secure_id: $session_secure_id
			organization_verbose_id: $organization_verbose_id
			enable_strict_privacy: $enable_strict_privacy
			enable_recording_network_contents: $enable_recording_network_contents
			clientVersion: $clientVersion
			firstloadVersion: $firstloadVersion
			clientConfig: $clientConfig
			environment: $environment
			appVersion: $appVersion
			serviceName: $serviceName
			fingerprint: $id
			client_id: $client_id
			network_recording_domains: $network_recording_domains
			disable_session_recording: $disable_session_recording
			privacy_setting: $privacy_setting
		) {
			secure_id
			project_id
		}
	}
`, qf = he`
	query Ignore($id: ID!) {
		ignore(id: $id)
	}
`, eb = (s, e, t, i) => s();
function tb(s, e = eb) {
  return {
    PushPayload(t, i) {
      return e((r) => s.request(ec, t, X(X({}, i), r)), "PushPayload", "mutation", t);
    },
    PushPayloadCompressed(t, i) {
      return e((r) => s.request(Df, t, X(X({}, i), r)), "PushPayloadCompressed", "mutation", t);
    },
    identifySession(t, i) {
      return e((r) => s.request(Af, t, X(X({}, i), r)), "identifySession", "mutation", t);
    },
    addSessionProperties(t, i) {
      return e((r) => s.request(jf, t, X(X({}, i), r)), "addSessionProperties", "mutation", t);
    },
    pushMetrics(t, i) {
      return e((r) => s.request(Qf, t, X(X({}, i), r)), "pushMetrics", "mutation", t);
    },
    addSessionFeedback(t, i) {
      return e((r) => s.request(_f, t, X(X({}, i), r)), "addSessionFeedback", "mutation", t);
    },
    initializeSession(t, i) {
      return e((r) => s.request($f, t, X(X({}, i), r)), "initializeSession", "mutation", t);
    },
    Ignore(t, i) {
      return e((r) => s.request(qf, t, X(X({}, i), r)), "Ignore", "query", t);
    }
  };
}
const ib = (s) => {
  s(window.location.href);
  const e = history.pushState;
  history.pushState = /* @__PURE__ */ ((n) => function() {
    var a = n.apply(this, arguments);
    return window.dispatchEvent(new Event("pushstate")), window.dispatchEvent(new Event("locationchange")), a;
  })(history.pushState);
  const t = history.replaceState;
  history.replaceState = /* @__PURE__ */ ((n) => function() {
    var a = n.apply(this, arguments);
    return window.dispatchEvent(new Event("replacestate")), window.dispatchEvent(new Event("locationchange")), a;
  })(history.replaceState);
  const i = () => {
    window.dispatchEvent(new Event("locationchange"));
  };
  window.addEventListener("popstate", i);
  const r = function() {
    s(window.location.href);
  };
  return window.addEventListener("locationchange", r), () => {
    window.removeEventListener("popstate", i), window.removeEventListener("locationchange", r), history.pushState = e, history.replaceState = t;
  };
}, sb = (s) => {
  switch (s) {
    case "strict":
      return [!0, void 0];
    case "default":
      return [!0, void 0];
    case "none":
      return [!1, { password: !0 }];
  }
};
var Fe;
(function(s) {
  s[s.All = 0] = "All", s[s.Two = 1] = "Two", s[s.One = 2] = "One";
})(Fe || (Fe = {}));
let fe, an;
function tc(s, e) {
  return s.nodeType, Node.ELEMENT_NODE, Lr(s);
  return rb(s, e);
}
function ic(s) {
  if (s.id.length)
    return `#${s.id}`;
  if (s.classList.length) {
    let e = [];
    for (const t of s.classList)
      e.push(`.${t}`);
    return `${s.nodeName.toLowerCase()}${e.join(",")}`;
  }
  return s.nodeName.toLowerCase();
}
function rb(s, e) {
  if (s.tagName.toLowerCase() === "html")
    return "html";
  try {
    const t = {
      root: document.body,
      idName: (r) => !0,
      className: (r) => !0,
      tagName: (r) => !0,
      attr: (r, n) => !1,
      seedMinLength: 1,
      optimizedMinLength: 2,
      threshold: 50,
      maxNumberOfTries: 1e3,
      optimized: !0
    };
    fe = X(X({}, t), e), an = nb(fe.root, t);
    let i = Hs(s, Fe.All, () => Hs(s, Fe.Two, () => Hs(s, Fe.One)));
    if (i) {
      if (fe.optimized) {
        const r = nc(oc(i, s));
        r.length > 0 && (i = r[0]);
      }
      return us(i);
    } else
      return Lr(s);
  } catch (t) {
    return Lr(s);
  }
}
function nb(s, e) {
  return s.nodeType === Node.DOCUMENT_NODE ? s : s === e.root ? s.ownerDocument : s;
}
function Hs(s, e, t) {
  let i = null, r = [], n = s, l = 0;
  for (; n && n !== fe.root.parentElement; ) {
    let a = Ii(ob(n)) || Ii(...lb(n)) || Ii(...ab(n)) || Ii(cb(n)) || [ub()];
    const o = db(n);
    if (e === Fe.All)
      o && (a = a.concat(a.filter(zs).map((c) => Ms(c, o))));
    else if (e === Fe.Two)
      a = a.slice(0, 1), o && (a = a.concat(a.filter(zs).map((c) => Ms(c, o))));
    else if (e === Fe.One) {
      const [c] = a = a.slice(0, 1);
      o && zs(c) && (a = [Ms(c, o)]);
    }
    for (let c of a)
      c.level = l;
    if (r.push(a), r.length >= fe.seedMinLength && (i = ko(r, t), i))
      break;
    n = n.parentElement, l++;
  }
  return i || (i = ko(r, t)), i;
}
function ko(s, e) {
  const t = nc(rc(s));
  if (t.length > fe.threshold)
    return e ? e() : null;
  for (let i of t)
    if (sc(i))
      return i;
  return null;
}
function us(s) {
  let e = s[0], t = e.name;
  for (let i = 1; i < s.length; i++) {
    const r = s[i].level || 0;
    e.level === r - 1 ? t = `${s[i].name} > ${t}` : t = `${s[i].name} ${t}`, e = s[i];
  }
  return t;
}
function To(s) {
  return s.map((e) => e.penalty).reduce((e, t) => e + t, 0);
}
function sc(s) {
  switch (an.querySelectorAll(us(s)).length) {
    case 0:
      return !0;
    case 1:
      return !0;
    default:
      return !1;
  }
}
function ob(s) {
  const e = s.getAttribute("id");
  return e && fe.idName(e) ? {
    name: "#" + ji(e, { isIdentifier: !0 }),
    penalty: 0
  } : null;
}
function lb(s) {
  return Array.from(s.attributes).filter((t) => fe.attr(t.name, t.value)).map((t) => ({
    name: "[" + ji(t.name, { isIdentifier: !0 }) + '="' + ji(t.value) + '"]',
    penalty: 0.5
  }));
}
function ab(s) {
  return Array.from(s.classList).filter(fe.className).map((t) => ({
    name: "." + ji(t, { isIdentifier: !0 }),
    penalty: 1
  }));
}
function cb(s) {
  const e = s.tagName.toLowerCase();
  return fe.tagName(e) ? {
    name: e,
    penalty: 2
  } : null;
}
function ub() {
  return {
    name: "*",
    penalty: 3
  };
}
function db(s) {
  const e = s.parentNode;
  if (!e)
    return null;
  let t = e.firstChild;
  if (!t)
    return null;
  let i = 0;
  for (; t && (t.nodeType === Node.ELEMENT_NODE && i++, t !== s); )
    t = t.nextSibling;
  return i;
}
function Ms(s, e) {
  return {
    name: s.name + `:nth-child(${e})`,
    penalty: s.penalty + 1
  };
}
function zs(s) {
  return s.name !== "html" && !s.name.startsWith("#");
}
function Ii(...s) {
  const e = s.filter(hb);
  return e.length > 0 ? e : null;
}
function hb(s) {
  return s != null;
}
function* rc(s, e = []) {
  if (s.length > 0)
    for (let t of s[0])
      yield* Gs(rc(s.slice(1, s.length), e.concat(t)));
  else
    yield e;
}
function nc(s) {
  return Array.from(s).sort((e, t) => To(e) - To(t));
}
function* oc(s, e, t = {
  counter: 0,
  visited: /* @__PURE__ */ new Map()
}) {
  if (s.length > 2 && s.length > fe.optimizedMinLength)
    for (let i = 1; i < s.length - 1; i++) {
      if (t.counter > fe.maxNumberOfTries)
        return;
      t.counter += 1;
      const r = [...s];
      r.splice(i, 1);
      const n = us(r);
      if (t.visited.has(n))
        return;
      sc(r) && pb(r, e) && (yield r, t.visited.set(n, !0), yield* Gs(oc(r, e, t)));
    }
}
function pb(s, e) {
  return an.querySelector(us(s)) === e;
}
const mb = /[ -,\.\/:-@\[-\^`\{-~]/, fb = /[ -,\.\/:-@\[\]\^`\{-~]/, bb = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, yb = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
function ji(s, e = {}) {
  const t = X(X({}, yb), e);
  t.quotes != "single" && t.quotes != "double" && (t.quotes = "single");
  const i = t.quotes == "double" ? '"' : "'", r = t.isIdentifier, n = s.charAt(0);
  let l = "", a = 0;
  const o = s.length;
  for (; a < o; ) {
    const c = s.charAt(a++);
    let u = c.charCodeAt(0), d;
    if (u < 32 || u > 126) {
      if (u >= 55296 && u <= 56319 && a < o) {
        const h = s.charCodeAt(a++);
        (h & 64512) == 56320 ? u = ((u & 1023) << 10) + (h & 1023) + 65536 : a--;
      }
      d = "\\" + u.toString(16).toUpperCase() + " ";
    } else
      t.escapeEverything ? mb.test(c) ? d = "\\" + c : d = "\\" + u.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(c) ? d = "\\" + u.toString(16).toUpperCase() + " " : c == "\\" || !r && (c == '"' && i == c || c == "'" && i == c) || r && fb.test(c) ? d = "\\" + c : d = c;
    l += d;
  }
  return r && (/^-[-\d]/.test(l) ? l = "\\-" + l.slice(1) : /\d/.test(n) && (l = "\\3" + n + " " + l.slice(1))), l = l.replace(bb, function(c, u, d) {
    return u && u.length % 2 ? c : (u || "") + d;
  }), !r && t.wrap ? i + l + i : l;
}
const Lr = (s) => {
  let e = "";
  const t = s.getAttribute("class"), i = s.getAttribute("id");
  return i && (e = e.concat(Jo(i, "#"))), t && (e = e.concat(Jo(t, "."))), e === "" && (e = e.concat(s.tagName.toLowerCase())), e;
}, Jo = (s, e) => `${e}${s.trim().split(" ").join(e)}`, gb = (s) => {
  const e = (t) => {
    if (t.target) {
      const i = t.target, r = tc(i);
      s(r, t);
    }
  };
  return window.addEventListener("click", e), () => window.removeEventListener("click", e);
}, Zb = (s) => {
  const e = (t) => {
    if (t.target) {
      const i = tc(t.target);
      s(i);
    }
  };
  return window.addEventListener("focusin", e), () => window.removeEventListener("focusin", e);
}, Gb = 30, Ib = () => new Promise((s) => requestAnimationFrame((e) => requestAnimationFrame((t) => s(t - e)))), Sb = () => ee(void 0, null, function* () {
  const s = [];
  for (let e = 0; e < Gb; e++)
    s.push(yield Ib());
  return s.reduce((e, t) => e + t, 0) / s.length;
}), Vb = (s, e) => {
  let t = {}, i = 16.666666666666668;
  Sb().then((o) => i = o);
  const r = (o) => {
    var c;
    t != null && t.event || (t = {
      event: o,
      location: window.location.href,
      timerStart: (c = window.performance) == null ? void 0 : c.now()
    }, window.requestAnimationFrame(n));
  }, n = () => {
    if (!(t != null && t.timerStart))
      return;
    const o = window.performance.now() - t.timerStart - i;
    l(o), t = {};
  }, l = (o) => {
    const c = ((/* @__PURE__ */ new Date()).getTime() - e) / 1e3;
    s({
      relativeTimestamp: c,
      jankAmount: o,
      querySelector: a(),
      newLocation: window.location.href != t.location ? window.location.href : void 0
    });
  }, a = () => {
    var o;
    return (o = t == null ? void 0 : t.event) != null && o.target ? ic(t.event.target) : "";
  };
  return window.addEventListener("click", r, !0), window.addEventListener("keydown", r, !0), () => {
    window.removeEventListener("keydown", r, !0), window.removeEventListener("click", r, !0);
  };
}, Wb = (s) => {
  let e, t;
  if (typeof document.hidden != "undefined" ? (e = "hidden", t = "visibilitychange") : typeof document.msHidden != "undefined" ? (e = "msHidden", t = "msvisibilitychange") : typeof document.webkitHidden != "undefined" && (e = "webkitHidden", t = "webkitvisibilitychange"), t === void 0)
    return () => {
    };
  if (e === void 0)
    return () => {
    };
  const i = e, r = () => {
    const l = document[i];
    s(!!l);
  };
  document.addEventListener(t, r);
  const n = t;
  return () => document.removeEventListener(n, r);
}, Xb = typeof window != "undefined", Uo = Xb && "performance" in window && "memory" in performance ? performance : { memory: {} }, Rb = (s, e) => {
  let t = 0, i = 0;
  const r = () => {
    const u = ((/* @__PURE__ */ new Date()).getTime() - e) / 1e3, d = Uo.memory.jsHeapSizeLimit || 0, h = Uo.memory.usedJSHeapSize || 0;
    s({
      jsHeapSizeLimit: d,
      usedJSHeapSize: h,
      relativeTimestamp: u,
      fps: t
    });
  };
  r();
  let n;
  n = setInterval(() => {
    r();
  }, 1e3 * 5);
  let l = 0, a = Date.now();
  const o = function() {
    var c = Date.now();
    l++, c > 1e3 + a && (t = Math.round(l * 1e3 / (c - a)), l = 0, a = c), i = requestAnimationFrame(o);
  };
  return o(), () => {
    clearInterval(n), cancelAnimationFrame(i);
  };
};
var Ke;
(function(s) {
  s.USER_ID = "ajs_user_id", s.USER_TRAITS = "ajs_user_traits", s.ANONYMOUS_ID = "ajs_anonymous_id";
})(Ke || (Ke = {}));
const wb = (s) => {
  s(window.location.href);
  var e = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function(n) {
    setTimeout(() => {
      var a;
      var l;
      try {
        l = JSON.parse((a = n == null ? void 0 : n.toString()) != null ? a : "");
      } catch (o) {
        return;
      }
      (l.type === "track" || l.type === "identify") && Os(l) && s(l);
    }, 100), e.call(this, n);
  };
  const t = (n) => {
    if (n.key === Ke.USER_ID || n.key === Ke.ANONYMOUS_ID || n.key === Ke.USER_TRAITS) {
      const { userId: l, userTraits: a } = Fo();
      if (l) {
        let o = {};
        a && (o = JSON.parse(a));
        const c = {
          type: "identify",
          userId: l.toString(),
          traits: o
        };
        Os(c) && s(c);
      }
    }
  }, { userId: i, userTraits: r } = Fo();
  if (i) {
    let n = {};
    r && (n = JSON.parse(r));
    const l = {
      type: "identify",
      userId: i.toString(),
      traits: n
    };
    Os(l) && s(l);
  }
  return window.addEventListener("storage", t), kc(({ keyName: n }) => {
    t({
      key: n
    });
  }), () => {
    window.removeEventListener("storage", t), XMLHttpRequest.prototype.send = e;
  };
}, Fo = () => {
  const s = xe(Ke.USER_ID), e = xe(Ke.USER_TRAITS), t = xe(Ke.ANONYMOUS_ID);
  return {
    userId: s,
    userTraits: e,
    anonymousId: t
  };
}, Os = (s) => {
  if (!s)
    return !1;
  let e = "";
  try {
    e = JSON.stringify(s);
  } catch (r) {
    return !1;
  }
  const t = Cb(e), i = xe(Le.SEGMENT_LAST_SENT_HASH_KEY);
  return i === void 0 ? (Pe(Le.SEGMENT_LAST_SENT_HASH_KEY, t), !0) : t !== i ? (Pe(Le.SEGMENT_LAST_SENT_HASH_KEY, t), !0) : !1;
}, Cb = (s) => {
  var e = 0, t = s.length, i = 0;
  if (t > 0)
    for (; i < t; )
      e = (e << 5) - e + s.charCodeAt(i++) | 0;
  return e.toString();
}, vb = (s, e) => {
  const t = xb(s);
  let i = [];
  const r = !1, n = !0;
  for (let l = 0; l < t.length; l++) {
    let a = t[l].split("+");
    i = [], a.length > 1 && (i = Nb(lc, a)), a = a[a.length - 1], a = a === "*" ? "*" : Yb(a), a in Ce || (Ce[a] = []), Ce[a].push({
      mods: i,
      shortcut: t[l],
      key: t[l],
      method: e,
      keyup: r,
      keydown: n,
      scope: "all",
      splitKey: "+"
    });
  }
  kb(document, "keydown", (l) => {
    Jb(l);
  });
};
let ae = [];
function xb(s) {
  typeof s != "string" && (s = ""), s = s.replace(/\s/g, "");
  const e = s.split(",");
  let t = e.lastIndexOf("");
  for (; t >= 0; )
    e[t - 1] += ",", e.splice(t, 1), t = e.lastIndexOf("");
  return e;
}
const Ce = {}, Es = typeof navigator != "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1, Lb = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": Es ? 173 : 189,
  "=": Es ? 61 : 187,
  ";": Es ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Ko = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, ce = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, lc = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, Yb = (s) => (
  // @ts-expect-error
  Lb[s.toLowerCase()] || // @ts-expect-error
  lc[s.toLowerCase()] || s.toUpperCase().charCodeAt(0)
);
function Nb(s, e) {
  const t = e.slice(0, e.length - 1);
  for (let i = 0; i < t.length; i++)
    t[i] = s[t[i].toLowerCase()];
  return t;
}
function kb(s, e, t) {
  s.addEventListener ? s.addEventListener(e, t, !1) : s.attachEvent && s.attachEvent(`on${e}`, () => {
    t(window.event);
  });
}
function Tb(s, e, t) {
  let i;
  if (e.scope === t || e.scope === "all") {
    i = e.mods.length > 0;
    for (const r in ce)
      Object.prototype.hasOwnProperty.call(ce, r) && // @ts-expect-error
      (!ce[r] && e.mods.indexOf(+r) > -1 || // @ts-expect-error
      ce[r] && e.mods.indexOf(+r) === -1) && (i = !1);
    (e.mods.length === 0 && !ce[16] && !ce[18] && !ce[17] && !ce[91] || i || e.shortcut === "*") && e.method(s, e) === !1 && (s.preventDefault ? s.preventDefault() : s.returnValue = !1, s.stopPropagation && s.stopPropagation(), s.cancelBubble && (s.cancelBubble = !0));
  }
}
function Jb(s) {
  const e = Ce["*"];
  let t = s.keyCode || s.which || s.charCode;
  if ((t === 93 || t === 224) && (t = 91), ae.indexOf(t) === -1 && t !== 229 && ae.push(t), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((i) => {
    const r = Ko[i];
    s[i] && ae.indexOf(r) === -1 ? ae.push(r) : !s[i] && ae.indexOf(r) > -1 ? ae.splice(ae.indexOf(r), 1) : i === "metaKey" && s[i] && ae.length === 3 && (s.ctrlKey || s.shiftKey || s.altKey || (ae = ae.slice(ae.indexOf(r))));
  }), !(t in ce && (ce[t] = !0, !e))) {
    for (const i in ce)
      Object.prototype.hasOwnProperty.call(ce, i) && (ce[i] = s[Ko[i]]);
    if (s.getModifierState && !(s.altKey && !s.ctrlKey) && s.getModifierState("AltGraph") && (ae.indexOf(17) === -1 && ae.push(17), ae.indexOf(18) === -1 && ae.push(18), ce[17] = !0, ce[18] = !0), t in Ce) {
      for (let i = 0; i < Ce[t].length; i++)
        if (
          // @ts-expect-error
          (s.type === "keydown" && Ce[t][i].keydown || // @ts-expect-error
          s.type === "keyup" && Ce[t][i].keyup) && Ce[t][i].key
        ) {
          const r = Ce[t][i];
          Tb(s, r, "all");
        }
    }
  }
}
const Ub = (s) => {
  let e;
  const i = () => {
    clearTimeout(e), e = setTimeout(() => {
      var r, n;
      s({
        height: window.innerHeight,
        width: window.innerWidth,
        availHeight: window.screen.availHeight,
        availWidth: window.screen.availWidth,
        colorDepth: window.screen.colorDepth,
        pixelDepth: window.screen.pixelDepth,
        orientation: (n = (r = window.screen.orientation) == null ? void 0 : r.angle) != null ? n : 0
      });
    }, 500);
  };
  return window.addEventListener("resize", i), i(), () => window.removeEventListener("resize", i);
};
var Ue, Lt, ac, Qi, Yr, cc = -1, Ae = function(s) {
  addEventListener("pageshow", function(e) {
    e.persisted && (cc = e.timeStamp, s(e));
  }, !0);
}, cn = function() {
  return window.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
}, ds = function() {
  var s = cn();
  return s && s.activationStart || 0;
}, be = function(s, e) {
  var t = cn(), i = "navigate";
  return cc >= 0 ? i = "back-forward-cache" : t && (document.prerendering || ds() > 0 ? i = "prerender" : document.wasDiscarded ? i = "restore" : t.type && (i = t.type.replace(/_/g, "-"))), { name: s, value: e === void 0 ? -1 : e, rating: "good", delta: 0, entries: [], id: "v3-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12), navigationType: i };
}, mt = function(s, e, t) {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(s)) {
      var i = new PerformanceObserver(function(r) {
        Promise.resolve().then(function() {
          e(r.getEntries());
        });
      });
      return i.observe(Object.assign({ type: s, buffered: !0 }, t || {})), i;
    }
  } catch (r) {
  }
}, ye = function(s, e, t, i) {
  var r, n;
  return function(l) {
    e.value >= 0 && (l || i) && ((n = e.value - (r || 0)) || r === void 0) && (r = e.value, e.delta = n, e.rating = function(a, o) {
      return a > o[1] ? "poor" : a > o[0] ? "needs-improvement" : "good";
    }(e.value, t), s(e));
  };
}, un = function(s) {
  requestAnimationFrame(function() {
    return requestAnimationFrame(function() {
      return s();
    });
  });
}, hs = function(s) {
  var e = function(t) {
    t.type !== "pagehide" && document.visibilityState !== "hidden" || s(t);
  };
  addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0);
}, dn = function(s) {
  var e = !1;
  return function(t) {
    e || (s(t), e = !0);
  };
}, rt = -1, Ho = function() {
  return document.visibilityState !== "hidden" || document.prerendering ? 1 / 0 : 0;
}, _i = function(s) {
  document.visibilityState === "hidden" && rt > -1 && (rt = s.type === "visibilitychange" ? s.timeStamp : 0, Fb());
}, Mo = function() {
  addEventListener("visibilitychange", _i, !0), addEventListener("prerenderingchange", _i, !0);
}, Fb = function() {
  removeEventListener("visibilitychange", _i, !0), removeEventListener("prerenderingchange", _i, !0);
}, hn = function() {
  return rt < 0 && (rt = Ho(), Mo(), Ae(function() {
    setTimeout(function() {
      rt = Ho(), Mo();
    }, 0);
  })), { get firstHiddenTime() {
    return rt;
  } };
}, At = function(s) {
  document.prerendering ? addEventListener("prerenderingchange", function() {
    return s();
  }, !0) : s();
}, zo = [1800, 3e3], uc = function(s, e) {
  e = e || {}, At(function() {
    var t, i = hn(), r = be("FCP"), n = mt("paint", function(l) {
      l.forEach(function(a) {
        a.name === "first-contentful-paint" && (n.disconnect(), a.startTime < i.firstHiddenTime && (r.value = Math.max(a.startTime - ds(), 0), r.entries.push(a), t(!0)));
      });
    });
    n && (t = ye(s, r, zo, e.reportAllChanges), Ae(function(l) {
      r = be("FCP"), t = ye(s, r, zo, e.reportAllChanges), un(function() {
        r.value = performance.now() - l.timeStamp, t(!0);
      });
    }));
  });
}, Oo = [0.1, 0.25], Kb = function(s, e) {
  e = e || {}, uc(dn(function() {
    var t, i = be("CLS", 0), r = 0, n = [], l = function(o) {
      o.forEach(function(c) {
        if (!c.hadRecentInput) {
          var u = n[0], d = n[n.length - 1];
          r && c.startTime - d.startTime < 1e3 && c.startTime - u.startTime < 5e3 ? (r += c.value, n.push(c)) : (r = c.value, n = [c]);
        }
      }), r > i.value && (i.value = r, i.entries = n, t());
    }, a = mt("layout-shift", l);
    a && (t = ye(s, i, Oo, e.reportAllChanges), hs(function() {
      l(a.takeRecords()), t(!0);
    }), Ae(function() {
      r = 0, i = be("CLS", 0), t = ye(s, i, Oo, e.reportAllChanges), un(function() {
        return t();
      });
    }), setTimeout(t, 0));
  }));
}, Rt = { passive: !0, capture: !0 }, Hb = /* @__PURE__ */ new Date(), Eo = function(s, e) {
  Ue || (Ue = e, Lt = s, ac = /* @__PURE__ */ new Date(), hc(removeEventListener), dc());
}, dc = function() {
  if (Lt >= 0 && Lt < ac - Hb) {
    var s = { entryType: "first-input", name: Ue.type, target: Ue.target, cancelable: Ue.cancelable, startTime: Ue.timeStamp, processingStart: Ue.timeStamp + Lt };
    Qi.forEach(function(e) {
      e(s);
    }), Qi = [];
  }
}, Mb = function(s) {
  if (s.cancelable) {
    var e = (s.timeStamp > 1e12 ? /* @__PURE__ */ new Date() : performance.now()) - s.timeStamp;
    s.type == "pointerdown" ? function(t, i) {
      var r = function() {
        Eo(t, i), l();
      }, n = function() {
        l();
      }, l = function() {
        removeEventListener("pointerup", r, Rt), removeEventListener("pointercancel", n, Rt);
      };
      addEventListener("pointerup", r, Rt), addEventListener("pointercancel", n, Rt);
    }(e, s) : Eo(e, s);
  }
}, hc = function(s) {
  ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function(e) {
    return s(e, Mb, Rt);
  });
}, Po = [100, 300], zb = function(s, e) {
  e = e || {}, At(function() {
    var t, i = hn(), r = be("FID"), n = function(o) {
      o.startTime < i.firstHiddenTime && (r.value = o.processingStart - o.startTime, r.entries.push(o), t(!0));
    }, l = function(o) {
      o.forEach(n);
    }, a = mt("first-input", l);
    t = ye(s, r, Po, e.reportAllChanges), a && hs(dn(function() {
      l(a.takeRecords()), a.disconnect();
    })), a && Ae(function() {
      var o;
      r = be("FID"), t = ye(s, r, Po, e.reportAllChanges), Qi = [], Lt = -1, Ue = null, hc(addEventListener), o = n, Qi.push(o), dc();
    });
  });
}, pc = 0, Ps = 1 / 0, Si = 0, Ob = function(s) {
  s.forEach(function(e) {
    e.interactionId && (Ps = Math.min(Ps, e.interactionId), Si = Math.max(Si, e.interactionId), pc = Si ? (Si - Ps) / 7 + 1 : 0);
  });
}, mc = function() {
  return Yr ? pc : performance.interactionCount || 0;
}, Eb = function() {
  "interactionCount" in performance || Yr || (Yr = mt("event", Ob, { type: "event", buffered: !0, durationThreshold: 0 }));
}, Bo = [200, 500], fc = 0, Do = function() {
  return mc() - fc;
}, ve = [], Bs = {}, Ao = function(s) {
  var e = ve[ve.length - 1], t = Bs[s.interactionId];
  if (t || ve.length < 10 || s.duration > e.latency) {
    if (t) t.entries.push(s), t.latency = Math.max(t.latency, s.duration);
    else {
      var i = { id: s.interactionId, latency: s.duration, entries: [s] };
      Bs[i.id] = i, ve.push(i);
    }
    ve.sort(function(r, n) {
      return n.latency - r.latency;
    }), ve.splice(10).forEach(function(r) {
      delete Bs[r.id];
    });
  }
}, Pb = function(s, e) {
  e = e || {}, At(function() {
    var t;
    Eb();
    var i, r = be("INP"), n = function(a) {
      a.forEach(function(u) {
        u.interactionId && Ao(u), u.entryType === "first-input" && !ve.some(function(d) {
          return d.entries.some(function(h) {
            return u.duration === h.duration && u.startTime === h.startTime;
          });
        }) && Ao(u);
      });
      var o, c = (o = Math.min(ve.length - 1, Math.floor(Do() / 50)), ve[o]);
      c && c.latency !== r.value && (r.value = c.latency, r.entries = c.entries, i());
    }, l = mt("event", n, { durationThreshold: (t = e.durationThreshold) !== null && t !== void 0 ? t : 40 });
    i = ye(s, r, Bo, e.reportAllChanges), l && ("interactionId" in PerformanceEventTiming.prototype && l.observe({ type: "first-input", buffered: !0 }), hs(function() {
      n(l.takeRecords()), r.value < 0 && Do() > 0 && (r.value = 0, r.entries = []), i(!0);
    }), Ae(function() {
      ve = [], fc = mc(), r = be("INP"), i = ye(s, r, Bo, e.reportAllChanges);
    }));
  });
}, jo = [2500, 4e3], Ds = {}, Bb = function(s, e) {
  e = e || {}, At(function() {
    var t, i = hn(), r = be("LCP"), n = function(o) {
      var c = o[o.length - 1];
      c && c.startTime < i.firstHiddenTime && (r.value = Math.max(c.startTime - ds(), 0), r.entries = [c], t());
    }, l = mt("largest-contentful-paint", n);
    if (l) {
      t = ye(s, r, jo, e.reportAllChanges);
      var a = dn(function() {
        Ds[r.id] || (n(l.takeRecords()), l.disconnect(), Ds[r.id] = !0, t(!0));
      });
      ["keydown", "click"].forEach(function(o) {
        addEventListener(o, function() {
          return setTimeout(a, 0);
        }, !0);
      }), hs(a), Ae(function(o) {
        r = be("LCP"), t = ye(s, r, jo, e.reportAllChanges), un(function() {
          r.value = performance.now() - o.timeStamp, Ds[r.id] = !0, t(!0);
        });
      });
    }
  });
}, Qo = [800, 1800], Db = function s(e) {
  document.prerendering ? At(function() {
    return s(e);
  }) : document.readyState !== "complete" ? addEventListener("load", function() {
    return s(e);
  }, !0) : setTimeout(e, 0);
}, Ab = function(s, e) {
  e = e || {};
  var t = be("TTFB"), i = ye(s, t, Qo, e.reportAllChanges);
  Db(function() {
    var r = cn();
    if (r) {
      var n = r.responseStart;
      if (n <= 0 || n > performance.now()) return;
      t.value = Math.max(n - ds(), 0), t.entries = [r], i(!0), Ae(function() {
        t = be("TTFB", 0), (i = ye(s, t, Qo, e.reportAllChanges))(!0);
      });
    }
  });
};
const jb = (s) => (Kb(s), uc(s), zb(s), Bb(s), Ab(s), Pb(s), () => {
});
class Qb {
  constructor(e, t) {
    Y(this, "debug");
    Y(this, "name");
    this.debug = e, this.name = t;
  }
  log(...e) {
    if (this.debug) {
      let t = `[${Date.now()}]`;
      this.name && (t += ` - ${this.name}`), console.log.apply(console, [t, ...e]);
    }
  }
}
const _o = "iframe parent ready", $o = "iframe ok", zt = "highlightLogs", _b = (s) => {
  let e = xe(zt) || "";
  e = e + "[" + (/* @__PURE__ */ new Date()).getTime() + "] " + s + `
`, Pe(zt, e);
}, $b = () => xe(zt) || "", qb = (s) => {
  if (!s)
    return;
  let e = xe(zt) || "";
  e && (e.startsWith(s) ? (e = e.slice(s.length), Pe(zt, e)) : _b("Unable to clear logs " + s.replace(`
`, " ") + " from " + e.replace(`
`, " ")));
}, ey = () => {
  if (!("performance" in window && "memory" in performance))
    return {
      getDeviceDetails: void 0,
      getCurrentDeviceDetails: void 0
    };
  const s = window.performance;
  return {
    getDeviceDetails: () => ({
      deviceMemory: ty(navigator.deviceMemory || 0)
    }),
    getCurrentDeviceDetails: () => {
      const i = As(s.memory.jsHeapSizeLimit), r = As(s.memory.totalJSHeapSize), n = As(s.memory.usedJSHeapSize);
      return {
        jsHeapSizeLimit: i,
        totalJSHeapSize: r,
        usedJSHeapSize: n
      };
    }
  };
}, As = (s) => s / Math.pow(1e3, 2), ty = (s) => 1024 * s, bc = "dmFyIFVyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxWcj1PYmplY3QuZGVmaW5lUHJvcGVydGllczt2YXIganI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7dmFyIE1lPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyIFF0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksWHQ9T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTt2YXIgdXQ9KEIsRCxDKT0+RCBpbiBCP1VyKEIsRCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q30pOkJbRF09QyxQPShCLEQpPT57Zm9yKHZhciBDIGluIER8fChEPXt9KSlRdC5jYWxsKEQsQykmJnV0KEIsQyxEW0NdKTtpZihNZSlmb3IodmFyIEMgb2YgTWUoRCkpWHQuY2FsbChELEMpJiZ1dChCLEMsRFtDXSk7cmV0dXJuIEJ9LFVlPShCLEQpPT5WcihCLGpyKEQpKTt2YXIgdmU9KEIsRCk9Pnt2YXIgQz17fTtmb3IodmFyIEogaW4gQilRdC5jYWxsKEIsSikmJkQuaW5kZXhPZihKKTwwJiYoQ1tKXT1CW0pdKTtpZihCIT1udWxsJiZNZSlmb3IodmFyIEogb2YgTWUoQikpRC5pbmRleE9mKEopPDAmJlh0LmNhbGwoQixKKSYmKENbSl09QltKXSk7cmV0dXJuIEN9O3ZhciBsdD0oQixELEMpPT51dChCLHR5cGVvZiBEIT0ic3ltYm9sIj9EKyIiOkQsQyk7dmFyIFg9KEIsRCxDKT0+bmV3IFByb21pc2UoKEosY2UpPT57dmFyIGdlPWVlPT57dHJ5e3VlKEMubmV4dChlZSkpfWNhdGNoKEVlKXtjZShFZSl9fSxJZT1lZT0+e3RyeXt1ZShDLnRocm93KGVlKSl9Y2F0Y2goRWUpe2NlKEVlKX19LHVlPWVlPT5lZS5kb25lP0ooZWUudmFsdWUpOlByb21pc2UucmVzb2x2ZShlZS52YWx1ZSkudGhlbihnZSxJZSk7dWUoKEM9Qy5hcHBseShCLEQpKS5uZXh0KCkpfSk7KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIEIoZSx0KXtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJnR5cGVvZiBuIT0ic3RyaW5nIiYmIUFycmF5LmlzQXJyYXkobikmJk9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oaSl7aWYoaSE9PSJkZWZhdWx0IiYmIShpIGluIGUpKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4saSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSxyLmdldD9yOntlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2ldfX0pfX0pfSksT2JqZWN0LmZyZWV6ZShlKX12YXIgRD1VaW50OEFycmF5LEM9VWludDE2QXJyYXksSj1JbnQzMkFycmF5LGNlPW5ldyBEKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxnZT1uZXcgRChbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxJZT1uZXcgRChbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLHVlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPW5ldyBDKDMxKSxpPTA7aTwzMTsrK2kpbltpXT10Kz0xPDxlW2ktMV07Zm9yKHZhciByPW5ldyBKKG5bMzBdKSxpPTE7aTwzMDsrK2kpZm9yKHZhciBzPW5baV07czxuW2krMV07KytzKXJbc109cy1uW2ldPDw1fGk7cmV0dXJue2I6bixyfX0sZWU9dWUoY2UsMiksRWU9ZWUuYixWZT1lZS5yO0VlWzI4XT0yNTgsVmVbMjU4XT0yODtmb3IodmFyIFd0PXVlKGdlLDApLGZ0PVd0LnIsamU9bmV3IEMoMzI3NjgpLEY9MDtGPDMyNzY4OysrRil7dmFyIGllPShGJjQzNjkwKT4+MXwoRiYyMTg0NSk8PDE7aWU9KGllJjUyNDI4KT4+MnwoaWUmMTMxMDcpPDwyLGllPShpZSY2MTY4MCk+PjR8KGllJjM4NTUpPDw0LGplW0ZdPSgoaWUmNjUyODApPj44fChpZSYyNTUpPDw4KT4+MX1mb3IodmFyIF9lPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIGk9ZS5sZW5ndGgscj0wLHM9bmV3IEModCk7cjxpOysrcillW3JdJiYrK3NbZVtyXS0xXTt2YXIgbz1uZXcgQyh0KTtmb3Iocj0xO3I8dDsrK3Ipb1tyXT1vW3ItMV0rc1tyLTFdPDwxO3ZhciBjO2lmKG4pe2M9bmV3IEMoMTw8dCk7dmFyIGY9MTUtdDtmb3Iocj0wO3I8aTsrK3IpaWYoZVtyXSlmb3IodmFyIGQ9cjw8NHxlW3JdLHU9dC1lW3JdLHk9b1tlW3JdLTFdKys8PHUsZz15fCgxPDx1KS0xO3k8PWc7Kyt5KWNbamVbeV0+PmZdPWR9ZWxzZSBmb3IoYz1uZXcgQyhpKSxyPTA7cjxpOysrcillW3JdJiYoY1tyXT1qZVtvW2Vbcl0tMV0rK10+PjE1LWVbcl0pO3JldHVybiBjfSxvZT1uZXcgRCgyODgpLEY9MDtGPDE0NDsrK0Ypb2VbRl09ODtmb3IodmFyIEY9MTQ0O0Y8MjU2OysrRilvZVtGXT05O2Zvcih2YXIgRj0yNTY7RjwyODA7KytGKW9lW0ZdPTc7Zm9yKHZhciBGPTI4MDtGPDI4ODsrK0Ypb2VbRl09ODtmb3IodmFyIE9lPW5ldyBEKDMyKSxGPTA7RjwzMjsrK0YpT2VbRl09NTt2YXIgWnQ9X2Uob2UsOSwwKSxLdD1fZShPZSw1LDApLGh0PWZ1bmN0aW9uKGUpe3JldHVybihlKzcpLzh8MH0sZHQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybihuPT1udWxsfHxuPmUubGVuZ3RoKSYmKG49ZS5sZW5ndGgpLG5ldyBEKGUuc3ViYXJyYXkodCxuKSl9LG5lPWZ1bmN0aW9uKGUsdCxuKXtuPDw9dCY3O3ZhciBpPXQvOHwwO2VbaV18PW4sZVtpKzFdfD1uPj44fSxUZT1mdW5jdGlvbihlLHQsbil7bjw8PXQmNzt2YXIgaT10Lzh8MDtlW2ldfD1uLGVbaSsxXXw9bj4+OCxlW2krMl18PW4+PjE2fSxxZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1bXSxpPTA7aTxlLmxlbmd0aDsrK2kpZVtpXSYmbi5wdXNoKHtzOmksZjplW2ldfSk7dmFyIHI9bi5sZW5ndGgscz1uLnNsaWNlKCk7aWYoIXIpcmV0dXJue3Q6dnQsbDowfTtpZihyPT0xKXt2YXIgbz1uZXcgRChuWzBdLnMrMSk7cmV0dXJuIG9bblswXS5zXT0xLHt0Om8sbDoxfX1uLnNvcnQoZnVuY3Rpb24oJCxxKXtyZXR1cm4gJC5mLXEuZn0pLG4ucHVzaCh7czotMSxmOjI1MDAxfSk7dmFyIGM9blswXSxmPW5bMV0sZD0wLHU9MSx5PTI7Zm9yKG5bMF09e3M6LTEsZjpjLmYrZi5mLGw6YyxyOmZ9O3UhPXItMTspYz1uW25bZF0uZjxuW3ldLmY/ZCsrOnkrK10sZj1uW2QhPXUmJm5bZF0uZjxuW3ldLmY/ZCsrOnkrK10sblt1KytdPXtzOi0xLGY6Yy5mK2YuZixsOmMscjpmfTtmb3IodmFyIGc9c1swXS5zLGk9MTtpPHI7KytpKXNbaV0ucz5nJiYoZz1zW2ldLnMpO3ZhciBiPW5ldyBDKGcrMSksbT1HZShuW3UtMV0sYiwwKTtpZihtPnQpe3ZhciBpPTAsTj0wLHY9bS10LEU9MTw8djtmb3Iocy5zb3J0KGZ1bmN0aW9uKHEsTSl7cmV0dXJuIGJbTS5zXS1iW3Euc118fHEuZi1NLmZ9KTtpPHI7KytpKXt2YXIgaz1zW2ldLnM7aWYoYltrXT50KU4rPUUtKDE8PG0tYltrXSksYltrXT10O2Vsc2UgYnJlYWt9Zm9yKE4+Pj12O04+MDspe3ZhciB3PXNbaV0ucztiW3ddPHQ/Ti09MTw8dC1iW3ddKystMTorK2l9Zm9yKDtpPj0wJiZOOy0taSl7dmFyIEw9c1tpXS5zO2JbTF09PXQmJigtLWJbTF0sKytOKX1tPXR9cmV0dXJue3Q6bmV3IEQoYiksbDptfX0sR2U9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnM9PS0xP01hdGgubWF4KEdlKGUubCx0LG4rMSksR2UoZS5yLHQsbisxKSk6dFtlLnNdPW59LHB0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aDt0JiYhZVstLXRdOyk7Zm9yKHZhciBuPW5ldyBDKCsrdCksaT0wLHI9ZVswXSxzPTEsbz1mdW5jdGlvbihmKXtuW2krK109Zn0sYz0xO2M8PXQ7KytjKWlmKGVbY109PXImJmMhPXQpKytzO2Vsc2V7aWYoIXImJnM+Mil7Zm9yKDtzPjEzODtzLT0xMzgpbygzMjc1NCk7cz4yJiYobyhzPjEwP3MtMTE8PDV8Mjg2OTA6cy0zPDw1fDEyMzA1KSxzPTApfWVsc2UgaWYocz4zKXtmb3IobyhyKSwtLXM7cz42O3MtPTYpbyg4MzA0KTtzPjImJihvKHMtMzw8NXw4MjA4KSxzPTApfWZvcig7cy0tOylvKHIpO3M9MSxyPWVbY119cmV0dXJue2M6bi5zdWJhcnJheSgwLGkpLG46dH19LGJlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTAsaT0wO2k8dC5sZW5ndGg7KytpKW4rPWVbaV0qdFtpXTtyZXR1cm4gbn0sbXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPW4ubGVuZ3RoLHI9aHQodCsyKTtlW3JdPWkmMjU1LGVbcisxXT1pPj44LGVbcisyXT1lW3JdXjI1NSxlW3IrM109ZVtyKzFdXjI1NTtmb3IodmFyIHM9MDtzPGk7KytzKWVbcitzKzRdPW5bc107cmV0dXJuKHIrNCtpKSo4fSx5dD1mdW5jdGlvbihlLHQsbixpLHIscyxvLGMsZixkLHUpe25lKHQsdSsrLG4pLCsrclsyNTZdO2Zvcih2YXIgeT1xZShyLDE1KSxnPXkudCxiPXkubCxtPXFlKHMsMTUpLE49bS50LHY9bS5sLEU9cHQoZyksaz1FLmMsdz1FLm4sTD1wdChOKSwkPUwuYyxxPUwubixNPW5ldyBDKDE5KSxJPTA7STxrLmxlbmd0aDsrK0kpKytNW2tbSV0mMzFdO2Zvcih2YXIgST0wO0k8JC5sZW5ndGg7KytJKSsrTVskW0ldJjMxXTtmb3IodmFyIE89cWUoTSw3KSxqPU8udCxVPU8ubCxIPTE5O0g+NCYmIWpbSWVbSC0xXV07LS1IKTt2YXIgUT1kKzU8PDMsYT1iZShyLG9lKStiZShzLE9lKStvLGg9YmUocixnKStiZShzLE4pK28rMTQrMypIK2JlKE0saikrMipNWzE2XSszKk1bMTddKzcqTVsxOF07aWYoZj49MCYmUTw9YSYmUTw9aClyZXR1cm4gbXQodCx1LGUuc3ViYXJyYXkoZixmK2QpKTt2YXIgXyxBLFIseDtpZihuZSh0LHUsMSsoaDxhKSksdSs9MixoPGEpe189X2UoZyxiLDApLEE9ZyxSPV9lKE4sdiwwKSx4PU47dmFyIHNlPV9lKGosVSwwKTtuZSh0LHUsdy0yNTcpLG5lKHQsdSs1LHEtMSksbmUodCx1KzEwLEgtNCksdSs9MTQ7Zm9yKHZhciBJPTA7STxIOysrSSluZSh0LHUrMypJLGpbSWVbSV1dKTt1Kz0zKkg7Zm9yKHZhciB6PVtrLCRdLHJlPTA7cmU8MjsrK3JlKWZvcih2YXIgbWU9eltyZV0sST0wO0k8bWUubGVuZ3RoOysrSSl7dmFyIHRlPW1lW0ldJjMxO25lKHQsdSxzZVt0ZV0pLHUrPWpbdGVdLHRlPjE1JiYobmUodCx1LG1lW0ldPj41JjEyNyksdSs9bWVbSV0+PjEyKX19ZWxzZSBfPVp0LEE9b2UsUj1LdCx4PU9lO2Zvcih2YXIgST0wO0k8YzsrK0kpe3ZhciBZPWlbSV07aWYoWT4yNTUpe3ZhciB0ZT1ZPj4xOCYzMTtUZSh0LHUsX1t0ZSsyNTddKSx1Kz1BW3RlKzI1N10sdGU+NyYmKG5lKHQsdSxZPj4yMyYzMSksdSs9Y2VbdGVdKTt2YXIgeWU9WSYzMTtUZSh0LHUsUlt5ZV0pLHUrPXhbeWVdLHllPjMmJihUZSh0LHUsWT4+NSY4MTkxKSx1Kz1nZVt5ZV0pfWVsc2UgVGUodCx1LF9bWV0pLHUrPUFbWV19cmV0dXJuIFRlKHQsdSxfWzI1Nl0pLHUrQVsyNTZdfSxlbj1uZXcgSihbNjU1NDAsMTMxMDgwLDEzMTA4OCwxMzExMDQsMjYyMTc2LDEwNDg3MDQsMTA0ODgzMiwyMTE0NTYwLDIxMTc2MzJdKSx2dD1uZXcgRCgwKSx0bj1mdW5jdGlvbihlLHQsbixpLHIscyl7dmFyIG89cy56fHxlLmxlbmd0aCxjPW5ldyBEKGkrbys1KigxK01hdGguY2VpbChvLzdlMykpK3IpLGY9Yy5zdWJhcnJheShpLGMubGVuZ3RoLXIpLGQ9cy5sLHU9KHMucnx8MCkmNztpZih0KXt1JiYoZlswXT1zLnI+PjMpO2Zvcih2YXIgeT1lblt0LTFdLGc9eT4+MTMsYj15JjgxOTEsbT0oMTw8biktMSxOPXMucHx8bmV3IEMoMzI3NjgpLHY9cy5ofHxuZXcgQyhtKzEpLEU9TWF0aC5jZWlsKG4vMyksaz0yKkUsdz1mdW5jdGlvbihjdCl7cmV0dXJuKGVbY3RdXmVbY3QrMV08PEVeZVtjdCsyXTw8aykmbX0sTD1uZXcgSigyNWUzKSwkPW5ldyBDKDI4OCkscT1uZXcgQygzMiksTT0wLEk9MCxPPXMuaXx8MCxqPTAsVT1zLnd8fDAsSD0wO08rMjxvOysrTyl7dmFyIFE9dyhPKSxhPU8mMzI3NjcsaD12W1FdO2lmKE5bYV09aCx2W1FdPWEsVTw9Tyl7dmFyIF89by1PO2lmKChNPjdlM3x8aj4yNDU3NikmJihfPjQyM3x8IWQpKXt1PXl0KGUsZiwwLEwsJCxxLEksaixILE8tSCx1KSxqPU09ST0wLEg9Tztmb3IodmFyIEE9MDtBPDI4NjsrK0EpJFtBXT0wO2Zvcih2YXIgQT0wO0E8MzA7KytBKXFbQV09MH12YXIgUj0yLHg9MCxzZT1iLHo9YS1oJjMyNzY3O2lmKF8+MiYmUT09dyhPLXopKWZvcih2YXIgcmU9TWF0aC5taW4oZyxfKS0xLG1lPU1hdGgubWluKDMyNzY3LE8pLHRlPU1hdGgubWluKDI1OCxfKTt6PD1tZSYmLS1zZSYmYSE9aDspe2lmKGVbTytSXT09ZVtPK1Itel0pe2Zvcih2YXIgWT0wO1k8dGUmJmVbTytZXT09ZVtPK1ktel07KytZKTtpZihZPlIpe2lmKFI9WSx4PXosWT5yZSlicmVhaztmb3IodmFyIHllPU1hdGgubWluKHosWS0yKSxIdD0wLEE9MDtBPHllOysrQSl7dmFyIG90PU8teitBJjMyNzY3LE1yPU5bb3RdLHp0PW90LU1yJjMyNzY3O3p0Pkh0JiYoSHQ9enQsaD1vdCl9fX1hPWgsaD1OW2FdLHorPWEtaCYzMjc2N31pZih4KXtMW2orK109MjY4NDM1NDU2fFZlW1JdPDwxOHxmdFt4XTt2YXIgWXQ9VmVbUl0mMzEsSnQ9ZnRbeF0mMzE7SSs9Y2VbWXRdK2dlW0p0XSwrKyRbMjU3K1l0XSwrK3FbSnRdLFU9TytSLCsrTX1lbHNlIExbaisrXT1lW09dLCsrJFtlW09dXX19Zm9yKE89TWF0aC5tYXgoTyxVKTtPPG87KytPKUxbaisrXT1lW09dLCsrJFtlW09dXTt1PXl0KGUsZixkLEwsJCxxLEksaixILE8tSCx1KSxkfHwocy5yPXUmN3xmW3UvOHwwXTw8Myx1LT03LHMuaD12LHMucD1OLHMuaT1PLHMudz1VKX1lbHNle2Zvcih2YXIgTz1zLnd8fDA7TzxvK2Q7Tys9NjU1MzUpe3ZhciBhdD1PKzY1NTM1O2F0Pj1vJiYoZlt1Lzh8MF09ZCxhdD1vKSx1PW10KGYsdSsxLGUuc3ViYXJyYXkoTyxhdCkpfXMuaT1vfXJldHVybiBkdChjLDAsaStodCh1KStyKX0sbm49ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkoMjU2KSx0PTA7dDwyNTY7Kyt0KXtmb3IodmFyIG49dCxpPTk7LS1pOyluPShuJjEmJi0zMDY2NzQ5MTIpXm4+Pj4xO2VbdF09bn1yZXR1cm4gZX0oKSxybj1mdW5jdGlvbigpe3ZhciBlPS0xO3JldHVybntwOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1lLGk9MDtpPHQubGVuZ3RoOysraSluPW5uW24mMjU1XnRbaV1dXm4+Pj44O2U9bn0sZDpmdW5jdGlvbigpe3JldHVybn5lfX19LHNuPWZ1bmN0aW9uKGUsdCxuLGkscil7aWYoIXImJihyPXtsOjF9LHQuZGljdGlvbmFyeSkpe3ZhciBzPXQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpLG89bmV3IEQocy5sZW5ndGgrZS5sZW5ndGgpO28uc2V0KHMpLG8uc2V0KGUscy5sZW5ndGgpLGU9byxyLnc9cy5sZW5ndGh9cmV0dXJuIHRuKGUsdC5sZXZlbD09bnVsbD82OnQubGV2ZWwsdC5tZW09PW51bGw/ci5sP01hdGguY2VpbChNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKGUubGVuZ3RoKSkpKjEuNSk6MjA6MTIrdC5tZW0sbixpLHIpfSxIZT1mdW5jdGlvbihlLHQsbil7Zm9yKDtuOysrdCllW3RdPW4sbj4+Pj04fSxvbj1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZmlsZW5hbWU7aWYoZVswXT0zMSxlWzFdPTEzOSxlWzJdPTgsZVs4XT10LmxldmVsPDI/NDp0LmxldmVsPT05PzI6MCxlWzldPTMsdC5tdGltZSE9MCYmSGUoZSw0LE1hdGguZmxvb3IobmV3IERhdGUodC5tdGltZXx8RGF0ZS5ub3coKSkvMWUzKSksbil7ZVszXT04O2Zvcih2YXIgaT0wO2k8PW4ubGVuZ3RoOysraSllW2krMTBdPW4uY2hhckNvZGVBdChpKX19LGFuPWZ1bmN0aW9uKGUpe3JldHVybiAxMCsoZS5maWxlbmFtZT9lLmZpbGVuYW1lLmxlbmd0aCsxOjApfTtmdW5jdGlvbiBjbihlLHQpe3R8fCh0PXt9KTt2YXIgbj1ybigpLGk9ZS5sZW5ndGg7bi5wKGUpO3ZhciByPXNuKGUsdCxhbih0KSw4KSxzPXIubGVuZ3RoO3JldHVybiBvbihyLHQpLEhlKHIscy04LG4uZCgpKSxIZShyLHMtNCxpKSxyfXZhciBndD10eXBlb2YgVGV4dEVuY29kZXIhPSJ1bmRlZmluZWQiJiZuZXcgVGV4dEVuY29kZXIsdW49dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIiYmbmV3IFRleHREZWNvZGVyLGxuPTA7dHJ5e3VuLmRlY29kZSh2dCx7c3RyZWFtOiEwfSksbG49MX1jYXRjaChlKXt9ZnVuY3Rpb24gZm4oZSx0KXt2YXIgbjtpZihndClyZXR1cm4gZ3QuZW5jb2RlKGUpO2Zvcih2YXIgaT1lLmxlbmd0aCxyPW5ldyBEKGUubGVuZ3RoKyhlLmxlbmd0aD4+MSkpLHM9MCxvPWZ1bmN0aW9uKGQpe3JbcysrXT1kfSxuPTA7bjxpOysrbil7aWYocys1PnIubGVuZ3RoKXt2YXIgYz1uZXcgRChzKzgrKGktbjw8MSkpO2Muc2V0KHIpLHI9Y312YXIgZj1lLmNoYXJDb2RlQXQobik7ZjwxMjh8fHQ/byhmKTpmPDIwNDg/KG8oMTkyfGY+PjYpLG8oMTI4fGYmNjMpKTpmPjU1Mjk1JiZmPDU3MzQ0PyhmPTY1NTM2KyhmJjEwNDc1NTIpfGUuY2hhckNvZGVBdCgrK24pJjEwMjMsbygyNDB8Zj4+MTgpLG8oMTI4fGY+PjEyJjYzKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSk6KG8oMjI0fGY+PjEyKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSl9cmV0dXJuIGR0KHIsMCxzKX1jb25zdCB6ZT1KU09OLGhuPWU9PmUudG9VcHBlckNhc2UoKSxkbj1lPT57Y29uc3QgdD17fTtyZXR1cm4gZS5mb3JFYWNoKChuLGkpPT57dFtpXT1ufSksdH0scG49KGUsdCxuKT0+ZS5kb2N1bWVudD9lOntkb2N1bWVudDplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0sbW49KGUsdCxuKT0+ZS5xdWVyeT9lOntxdWVyeTplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0seW49KGUsdCk9PmUuZG9jdW1lbnRzP2U6e2RvY3VtZW50czplLHJlcXVlc3RIZWFkZXJzOnQsc2lnbmFsOnZvaWQgMH07ZnVuY3Rpb24gU2UoZSx0KXtpZighISFlKXRocm93IG5ldyBFcnJvcih0KX1mdW5jdGlvbiB2bihlKXtyZXR1cm4gdHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbH1mdW5jdGlvbiBnbihlLHQpe2lmKCEhIWUpdGhyb3cgbmV3IEVycm9yKCJVbmV4cGVjdGVkIGludmFyaWFudCB0cmlnZ2VyZWQuIil9Y29uc3QgRW49L1xyXG58W1xuXHJdL2c7ZnVuY3Rpb24gWWUoZSx0KXtsZXQgbj0wLGk9MTtmb3IoY29uc3QgciBvZiBlLmJvZHkubWF0Y2hBbGwoRW4pKXtpZih0eXBlb2Ygci5pbmRleD09Im51bWJlciJ8fGduKCExKSxyLmluZGV4Pj10KWJyZWFrO249ci5pbmRleCtyWzBdLmxlbmd0aCxpKz0xfXJldHVybntsaW5lOmksY29sdW1uOnQrMS1ufX1mdW5jdGlvbiBfbihlKXtyZXR1cm4gRXQoZS5zb3VyY2UsWWUoZS5zb3VyY2UsZS5zdGFydCkpfWZ1bmN0aW9uIEV0KGUsdCl7Y29uc3Qgbj1lLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbi0xLGk9IiIucGFkU3RhcnQobikrZS5ib2R5LHI9dC5saW5lLTEscz1lLmxvY2F0aW9uT2Zmc2V0LmxpbmUtMSxvPXQubGluZStzLGM9dC5saW5lPT09MT9uOjAsZj10LmNvbHVtbitjLGQ9YCR7ZS5uYW1lfToke299OiR7Zn0KYCx1PWkuc3BsaXQoL1xyXG58W1xuXHJdL2cpLHk9dVtyXTtpZih5Lmxlbmd0aD4xMjApe2NvbnN0IGc9TWF0aC5mbG9vcihmLzgwKSxiPWYlODAsbT1bXTtmb3IobGV0IE49MDtOPHkubGVuZ3RoO04rPTgwKW0ucHVzaCh5LnNsaWNlKE4sTis4MCkpO3JldHVybiBkK190KFtbYCR7b30gfGAsbVswXV0sLi4ubS5zbGljZSgxLGcrMSkubWFwKE49PlsifCIsTl0pLFsifCIsIl4iLnBhZFN0YXJ0KGIpXSxbInwiLG1bZysxXV1dKX1yZXR1cm4gZCtfdChbW2Ake28tMX0gfGAsdVtyLTFdXSxbYCR7b30gfGAseV0sWyJ8IiwiXiIucGFkU3RhcnQoZildLFtgJHtvKzF9IHxgLHVbcisxXV1dKX1mdW5jdGlvbiBfdChlKXtjb25zdCB0PWUuZmlsdGVyKChbaSxyXSk9PnIhPT12b2lkIDApLG49TWF0aC5tYXgoLi4udC5tYXAoKFtpXSk9PmkubGVuZ3RoKSk7cmV0dXJuIHQubWFwKChbaSxyXSk9PmkucGFkU3RhcnQobikrKHI/IiAiK3I6IiIpKS5qb2luKGAKYCl9ZnVuY3Rpb24gVG4oZSl7Y29uc3QgdD1lWzBdO3JldHVybiB0PT1udWxsfHwia2luZCJpbiB0fHwibGVuZ3RoImluIHQ/e25vZGVzOnQsc291cmNlOmVbMV0scG9zaXRpb25zOmVbMl0scGF0aDplWzNdLG9yaWdpbmFsRXJyb3I6ZVs0XSxleHRlbnNpb25zOmVbNV19OnR9Y2xhc3MgSmUgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0LC4uLm4pe3ZhciBpLHIscztjb25zdHtub2RlczpvLHNvdXJjZTpjLHBvc2l0aW9uczpmLHBhdGg6ZCxvcmlnaW5hbEVycm9yOnUsZXh0ZW5zaW9uczp5fT1UbihuKTtzdXBlcih0KSx0aGlzLm5hbWU9IkdyYXBoUUxFcnJvciIsdGhpcy5wYXRoPWQhPW51bGw/ZDp2b2lkIDAsdGhpcy5vcmlnaW5hbEVycm9yPXUhPW51bGw/dTp2b2lkIDAsdGhpcy5ub2Rlcz1UdChBcnJheS5pc0FycmF5KG8pP286bz9bb106dm9pZCAwKTtjb25zdCBnPVR0KChpPXRoaXMubm9kZXMpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5tYXAobT0+bS5sb2MpLmZpbHRlcihtPT5tIT1udWxsKSk7dGhpcy5zb3VyY2U9YyE9bnVsbD9jOmc9PW51bGx8fChyPWdbMF0pPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5zb3VyY2UsdGhpcy5wb3NpdGlvbnM9ZiE9bnVsbD9mOmc9PW51bGw/dm9pZCAwOmcubWFwKG09Pm0uc3RhcnQpLHRoaXMubG9jYXRpb25zPWYmJmM/Zi5tYXAobT0+WWUoYyxtKSk6Zz09bnVsbD92b2lkIDA6Zy5tYXAobT0+WWUobS5zb3VyY2UsbS5zdGFydCkpO2NvbnN0IGI9dm4odT09bnVsbD92b2lkIDA6dS5leHRlbnNpb25zKT91PT1udWxsP3ZvaWQgMDp1LmV4dGVuc2lvbnM6dm9pZCAwO3RoaXMuZXh0ZW5zaW9ucz0ocz15IT1udWxsP3k6YikhPT1udWxsJiZzIT09dm9pZCAwP3M6T2JqZWN0LmNyZWF0ZShudWxsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHttZXNzYWdlOnt3cml0YWJsZTohMCxlbnVtZXJhYmxlOiEwfSxuYW1lOntlbnVtZXJhYmxlOiExfSxub2Rlczp7ZW51bWVyYWJsZTohMX0sc291cmNlOntlbnVtZXJhYmxlOiExfSxwb3NpdGlvbnM6e2VudW1lcmFibGU6ITF9LG9yaWdpbmFsRXJyb3I6e2VudW1lcmFibGU6ITF9fSksdSE9bnVsbCYmdS5zdGFjaz9PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RhY2siLHt2YWx1ZTp1LnN0YWNrLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pOkVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsSmUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdGFjayIse3ZhbHVlOkVycm9yKCkuc3RhY2ssd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iR3JhcGhRTEVycm9yIn10b1N0cmluZygpe2xldCB0PXRoaXMubWVzc2FnZTtpZih0aGlzLm5vZGVzKWZvcihjb25zdCBuIG9mIHRoaXMubm9kZXMpbi5sb2MmJih0Kz1gCgpgK19uKG4ubG9jKSk7ZWxzZSBpZih0aGlzLnNvdXJjZSYmdGhpcy5sb2NhdGlvbnMpZm9yKGNvbnN0IG4gb2YgdGhpcy5sb2NhdGlvbnMpdCs9YAoKYCtFdCh0aGlzLnNvdXJjZSxuKTtyZXR1cm4gdH10b0pTT04oKXtjb25zdCB0PXttZXNzYWdlOnRoaXMubWVzc2FnZX07cmV0dXJuIHRoaXMubG9jYXRpb25zIT1udWxsJiYodC5sb2NhdGlvbnM9dGhpcy5sb2NhdGlvbnMpLHRoaXMucGF0aCE9bnVsbCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuZXh0ZW5zaW9ucyE9bnVsbCYmT2JqZWN0LmtleXModGhpcy5leHRlbnNpb25zKS5sZW5ndGg+MCYmKHQuZXh0ZW5zaW9ucz10aGlzLmV4dGVuc2lvbnMpLHR9fWZ1bmN0aW9uIFR0KGUpe3JldHVybiBlPT09dm9pZCAwfHxlLmxlbmd0aD09PTA/dm9pZCAwOmV9ZnVuY3Rpb24gRyhlLHQsbil7cmV0dXJuIG5ldyBKZShgU3ludGF4IEVycm9yOiAke259YCx7c291cmNlOmUscG9zaXRpb25zOlt0XX0pfWNsYXNzIGJue2NvbnN0cnVjdG9yKHQsbixpKXt0aGlzLnN0YXJ0PXQuc3RhcnQsdGhpcy5lbmQ9bi5lbmQsdGhpcy5zdGFydFRva2VuPXQsdGhpcy5lbmRUb2tlbj1uLHRoaXMuc291cmNlPWl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTG9jYXRpb24ifXRvSlNPTigpe3JldHVybntzdGFydDp0aGlzLnN0YXJ0LGVuZDp0aGlzLmVuZH19fWNsYXNzIGJ0e2NvbnN0cnVjdG9yKHQsbixpLHIscyxvKXt0aGlzLmtpbmQ9dCx0aGlzLnN0YXJ0PW4sdGhpcy5lbmQ9aSx0aGlzLmxpbmU9cix0aGlzLmNvbHVtbj1zLHRoaXMudmFsdWU9byx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiJUb2tlbiJ9dG9KU09OKCl7cmV0dXJue2tpbmQ6dGhpcy5raW5kLHZhbHVlOnRoaXMudmFsdWUsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1ufX19Y29uc3QgTnQ9e05hbWU6W10sRG9jdW1lbnQ6WyJkZWZpbml0aW9ucyJdLE9wZXJhdGlvbkRlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxWYXJpYWJsZURlZmluaXRpb246WyJ2YXJpYWJsZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sVmFyaWFibGU6WyJuYW1lIl0sU2VsZWN0aW9uU2V0Olsic2VsZWN0aW9ucyJdLEZpZWxkOlsiYWxpYXMiLCJuYW1lIiwiYXJndW1lbnRzIiwiZGlyZWN0aXZlcyIsInNlbGVjdGlvblNldCJdLEFyZ3VtZW50OlsibmFtZSIsInZhbHVlIl0sRnJhZ21lbnRTcHJlYWQ6WyJuYW1lIiwiZGlyZWN0aXZlcyJdLElubGluZUZyYWdtZW50OlsidHlwZUNvbmRpdGlvbiIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxGcmFnbWVudERlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsInR5cGVDb25kaXRpb24iLCJkaXJlY3RpdmVzIiwic2VsZWN0aW9uU2V0Il0sSW50VmFsdWU6W10sRmxvYXRWYWx1ZTpbXSxTdHJpbmdWYWx1ZTpbXSxCb29sZWFuVmFsdWU6W10sTnVsbFZhbHVlOltdLEVudW1WYWx1ZTpbXSxMaXN0VmFsdWU6WyJ2YWx1ZXMiXSxPYmplY3RWYWx1ZTpbImZpZWxkcyJdLE9iamVjdEZpZWxkOlsibmFtZSIsInZhbHVlIl0sRGlyZWN0aXZlOlsibmFtZSIsImFyZ3VtZW50cyJdLE5hbWVkVHlwZTpbIm5hbWUiXSxMaXN0VHlwZTpbInR5cGUiXSxOb25OdWxsVHlwZTpbInR5cGUiXSxTY2hlbWFEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjpbInR5cGUiXSxTY2FsYXJUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sRmllbGREZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiYXJndW1lbnRzIiwidHlwZSIsImRpcmVjdGl2ZXMiXSxJbnB1dFZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sSW50ZXJmYWNlVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sRW51bVZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLERpcmVjdGl2ZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJhcmd1bWVudHMiLCJsb2NhdGlvbnMiXSxTY2hlbWFFeHRlbnNpb246WyJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxTY2FsYXJUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiLCJmaWVsZHMiXX0sTm49bmV3IFNldChPYmplY3Qua2V5cyhOdCkpO2Z1bmN0aW9uIHh0KGUpe2NvbnN0IHQ9ZT09bnVsbD92b2lkIDA6ZS5raW5kO3JldHVybiB0eXBlb2YgdD09InN0cmluZyImJk5uLmhhcyh0KX12YXIgbGU7KGZ1bmN0aW9uKGUpe2UuUVVFUlk9InF1ZXJ5IixlLk1VVEFUSU9OPSJtdXRhdGlvbiIsZS5TVUJTQ1JJUFRJT049InN1YnNjcmlwdGlvbiJ9KShsZXx8KGxlPXt9KSk7dmFyIFFlOyhmdW5jdGlvbihlKXtlLlFVRVJZPSJRVUVSWSIsZS5NVVRBVElPTj0iTVVUQVRJT04iLGUuU1VCU0NSSVBUSU9OPSJTVUJTQ1JJUFRJT04iLGUuRklFTEQ9IkZJRUxEIixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZSQUdNRU5UX0RFRklOSVRJT04iLGUuRlJBR01FTlRfU1BSRUFEPSJGUkFHTUVOVF9TUFJFQUQiLGUuSU5MSU5FX0ZSQUdNRU5UPSJJTkxJTkVfRlJBR01FTlQiLGUuVkFSSUFCTEVfREVGSU5JVElPTj0iVkFSSUFCTEVfREVGSU5JVElPTiIsZS5TQ0hFTUE9IlNDSEVNQSIsZS5TQ0FMQVI9IlNDQUxBUiIsZS5PQkpFQ1Q9Ik9CSkVDVCIsZS5GSUVMRF9ERUZJTklUSU9OPSJGSUVMRF9ERUZJTklUSU9OIixlLkFSR1VNRU5UX0RFRklOSVRJT049IkFSR1VNRU5UX0RFRklOSVRJT04iLGUuSU5URVJGQUNFPSJJTlRFUkZBQ0UiLGUuVU5JT049IlVOSU9OIixlLkVOVU09IkVOVU0iLGUuRU5VTV9WQUxVRT0iRU5VTV9WQUxVRSIsZS5JTlBVVF9PQkpFQ1Q9IklOUFVUX09CSkVDVCIsZS5JTlBVVF9GSUVMRF9ERUZJTklUSU9OPSJJTlBVVF9GSUVMRF9ERUZJTklUSU9OIn0pKFFlfHwoUWU9e30pKTt2YXIgVDsoZnVuY3Rpb24oZSl7ZS5OQU1FPSJOYW1lIixlLkRPQ1VNRU5UPSJEb2N1bWVudCIsZS5PUEVSQVRJT05fREVGSU5JVElPTj0iT3BlcmF0aW9uRGVmaW5pdGlvbiIsZS5WQVJJQUJMRV9ERUZJTklUSU9OPSJWYXJpYWJsZURlZmluaXRpb24iLGUuU0VMRUNUSU9OX1NFVD0iU2VsZWN0aW9uU2V0IixlLkZJRUxEPSJGaWVsZCIsZS5BUkdVTUVOVD0iQXJndW1lbnQiLGUuRlJBR01FTlRfU1BSRUFEPSJGcmFnbWVudFNwcmVhZCIsZS5JTkxJTkVfRlJBR01FTlQ9IklubGluZUZyYWdtZW50IixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZyYWdtZW50RGVmaW5pdGlvbiIsZS5WQVJJQUJMRT0iVmFyaWFibGUiLGUuSU5UPSJJbnRWYWx1ZSIsZS5GTE9BVD0iRmxvYXRWYWx1ZSIsZS5TVFJJTkc9IlN0cmluZ1ZhbHVlIixlLkJPT0xFQU49IkJvb2xlYW5WYWx1ZSIsZS5OVUxMPSJOdWxsVmFsdWUiLGUuRU5VTT0iRW51bVZhbHVlIixlLkxJU1Q9Ikxpc3RWYWx1ZSIsZS5PQkpFQ1Q9Ik9iamVjdFZhbHVlIixlLk9CSkVDVF9GSUVMRD0iT2JqZWN0RmllbGQiLGUuRElSRUNUSVZFPSJEaXJlY3RpdmUiLGUuTkFNRURfVFlQRT0iTmFtZWRUeXBlIixlLkxJU1RfVFlQRT0iTGlzdFR5cGUiLGUuTk9OX05VTExfVFlQRT0iTm9uTnVsbFR5cGUiLGUuU0NIRU1BX0RFRklOSVRJT049IlNjaGVtYURlZmluaXRpb24iLGUuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTj0iT3BlcmF0aW9uVHlwZURlZmluaXRpb24iLGUuU0NBTEFSX1RZUEVfREVGSU5JVElPTj0iU2NhbGFyVHlwZURlZmluaXRpb24iLGUuT0JKRUNUX1RZUEVfREVGSU5JVElPTj0iT2JqZWN0VHlwZURlZmluaXRpb24iLGUuRklFTERfREVGSU5JVElPTj0iRmllbGREZWZpbml0aW9uIixlLklOUFVUX1ZBTFVFX0RFRklOSVRJT049IklucHV0VmFsdWVEZWZpbml0aW9uIixlLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT049IkludGVyZmFjZVR5cGVEZWZpbml0aW9uIixlLlVOSU9OX1RZUEVfREVGSU5JVElPTj0iVW5pb25UeXBlRGVmaW5pdGlvbiIsZS5FTlVNX1RZUEVfREVGSU5JVElPTj0iRW51bVR5cGVEZWZpbml0aW9uIixlLkVOVU1fVkFMVUVfREVGSU5JVElPTj0iRW51bVZhbHVlRGVmaW5pdGlvbiIsZS5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OPSJJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uIixlLkRJUkVDVElWRV9ERUZJTklUSU9OPSJEaXJlY3RpdmVEZWZpbml0aW9uIixlLlNDSEVNQV9FWFRFTlNJT049IlNjaGVtYUV4dGVuc2lvbiIsZS5TQ0FMQVJfVFlQRV9FWFRFTlNJT049IlNjYWxhclR5cGVFeHRlbnNpb24iLGUuT0JKRUNUX1RZUEVfRVhURU5TSU9OPSJPYmplY3RUeXBlRXh0ZW5zaW9uIixlLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTj0iSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiIsZS5VTklPTl9UWVBFX0VYVEVOU0lPTj0iVW5pb25UeXBlRXh0ZW5zaW9uIixlLkVOVU1fVFlQRV9FWFRFTlNJT049IkVudW1UeXBlRXh0ZW5zaW9uIixlLklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTj0iSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIn0pKFR8fChUPXt9KSk7ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIGU9PT05fHxlPT09MzJ9ZnVuY3Rpb24gTmUoZSl7cmV0dXJuIGU+PTQ4JiZlPD01N31mdW5jdGlvbiBBdChlKXtyZXR1cm4gZT49OTcmJmU8PTEyMnx8ZT49NjUmJmU8PTkwfWZ1bmN0aW9uIEl0KGUpe3JldHVybiBBdChlKXx8ZT09PTk1fWZ1bmN0aW9uIHhuKGUpe3JldHVybiBBdChlKXx8TmUoZSl8fGU9PT05NX1mdW5jdGlvbiBBbihlKXt2YXIgdDtsZXQgbj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixpPW51bGwscj0tMTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7dmFyIHM7Y29uc3QgYz1lW29dLGY9SW4oYyk7ZiE9PWMubGVuZ3RoJiYoaT0ocz1pKSE9PW51bGwmJnMhPT12b2lkIDA/czpvLHI9byxvIT09MCYmZjxuJiYobj1mKSl9cmV0dXJuIGUubWFwKChvLGMpPT5jPT09MD9vOm8uc2xpY2UobikpLnNsaWNlKCh0PWkpIT09bnVsbCYmdCE9PXZvaWQgMD90OjAscisxKX1mdW5jdGlvbiBJbihlKXtsZXQgdD0wO2Zvcig7dDxlLmxlbmd0aCYmWGUoZS5jaGFyQ29kZUF0KHQpKTspKyt0O3JldHVybiB0fWZ1bmN0aW9uIE9uKGUsdCl7Y29uc3Qgbj1lLnJlcGxhY2UoLyIiIi9nLCdcXCIiIicpLGk9bi5zcGxpdCgvXHJcbnxbXG5ccl0vZykscj1pLmxlbmd0aD09PTEscz1pLmxlbmd0aD4xJiZpLnNsaWNlKDEpLmV2ZXJ5KGI9PmIubGVuZ3RoPT09MHx8WGUoYi5jaGFyQ29kZUF0KDApKSksbz1uLmVuZHNXaXRoKCdcXCIiIicpLGM9ZS5lbmRzV2l0aCgnIicpJiYhbyxmPWUuZW5kc1dpdGgoIlxcIiksZD1jfHxmLHU9IXJ8fGUubGVuZ3RoPjcwfHxkfHxzfHxvO2xldCB5PSIiO2NvbnN0IGc9ciYmWGUoZS5jaGFyQ29kZUF0KDApKTtyZXR1cm4odSYmIWd8fHMpJiYoeSs9YApgKSx5Kz1uLCh1fHxkKSYmKHkrPWAKYCksJyIiIicreSsnIiIiJ312YXIgbDsoZnVuY3Rpb24oZSl7ZS5TT0Y9IjxTT0Y+IixlLkVPRj0iPEVPRj4iLGUuQkFORz0iISIsZS5ET0xMQVI9IiQiLGUuQU1QPSImIixlLlBBUkVOX0w9IigiLGUuUEFSRU5fUj0iKSIsZS5TUFJFQUQ9Ii4uLiIsZS5DT0xPTj0iOiIsZS5FUVVBTFM9Ij0iLGUuQVQ9IkAiLGUuQlJBQ0tFVF9MPSJbIixlLkJSQUNLRVRfUj0iXSIsZS5CUkFDRV9MPSJ7IixlLlBJUEU9InwiLGUuQlJBQ0VfUj0ifSIsZS5OQU1FPSJOYW1lIixlLklOVD0iSW50IixlLkZMT0FUPSJGbG9hdCIsZS5TVFJJTkc9IlN0cmluZyIsZS5CTE9DS19TVFJJTkc9IkJsb2NrU3RyaW5nIixlLkNPTU1FTlQ9IkNvbW1lbnQifSkobHx8KGw9e30pKTtjbGFzcyBTbntjb25zdHJ1Y3Rvcih0KXtjb25zdCBuPW5ldyBidChsLlNPRiwwLDAsMCwwKTt0aGlzLnNvdXJjZT10LHRoaXMubGFzdFRva2VuPW4sdGhpcy50b2tlbj1uLHRoaXMubGluZT0xLHRoaXMubGluZVN0YXJ0PTB9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTGV4ZXIifWFkdmFuY2UoKXtyZXR1cm4gdGhpcy5sYXN0VG9rZW49dGhpcy50b2tlbix0aGlzLnRva2VuPXRoaXMubG9va2FoZWFkKCl9bG9va2FoZWFkKCl7bGV0IHQ9dGhpcy50b2tlbjtpZih0LmtpbmQhPT1sLkVPRilkbyBpZih0Lm5leHQpdD10Lm5leHQ7ZWxzZXtjb25zdCBuPURuKHRoaXMsdC5lbmQpO3QubmV4dD1uLG4ucHJldj10LHQ9bn13aGlsZSh0LmtpbmQ9PT1sLkNPTU1FTlQpO3JldHVybiB0fX1mdW5jdGlvbiB3bihlKXtyZXR1cm4gZT09PWwuQkFOR3x8ZT09PWwuRE9MTEFSfHxlPT09bC5BTVB8fGU9PT1sLlBBUkVOX0x8fGU9PT1sLlBBUkVOX1J8fGU9PT1sLlNQUkVBRHx8ZT09PWwuQ09MT058fGU9PT1sLkVRVUFMU3x8ZT09PWwuQVR8fGU9PT1sLkJSQUNLRVRfTHx8ZT09PWwuQlJBQ0tFVF9SfHxlPT09bC5CUkFDRV9MfHxlPT09bC5QSVBFfHxlPT09bC5CUkFDRV9SfWZ1bmN0aW9uIGZlKGUpe3JldHVybiBlPj0wJiZlPD01NTI5NXx8ZT49NTczNDQmJmU8PTExMTQxMTF9ZnVuY3Rpb24gd2UoZSx0KXtyZXR1cm4gT3QoZS5jaGFyQ29kZUF0KHQpKSYmU3QoZS5jaGFyQ29kZUF0KHQrMSkpfWZ1bmN0aW9uIE90KGUpe3JldHVybiBlPj01NTI5NiYmZTw9NTYzMTl9ZnVuY3Rpb24gU3QoZSl7cmV0dXJuIGU+PTU2MzIwJiZlPD01NzM0M31mdW5jdGlvbiBhZShlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keS5jb2RlUG9pbnRBdCh0KTtpZihuPT09dm9pZCAwKXJldHVybiBsLkVPRjtpZihuPj0zMiYmbjw9MTI2KXtjb25zdCBpPVN0cmluZy5mcm9tQ29kZVBvaW50KG4pO3JldHVybiBpPT09JyInP2AnIidgOmAiJHtpfSJgfXJldHVybiJVKyIrbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCIwIil9ZnVuY3Rpb24gVihlLHQsbixpLHIpe2NvbnN0IHM9ZS5saW5lLG89MStuLWUubGluZVN0YXJ0O3JldHVybiBuZXcgYnQodCxuLGkscyxvLHIpfWZ1bmN0aW9uIERuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dDtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO3N3aXRjaChzKXtjYXNlIDY1Mjc5OmNhc2UgOTpjYXNlIDMyOmNhc2UgNDQ6KytyO2NvbnRpbnVlO2Nhc2UgMTA6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAxMzpuLmNoYXJDb2RlQXQocisxKT09PTEwP3IrPTI6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAzNTpyZXR1cm4gQ24oZSxyKTtjYXNlIDMzOnJldHVybiBWKGUsbC5CQU5HLHIscisxKTtjYXNlIDM2OnJldHVybiBWKGUsbC5ET0xMQVIscixyKzEpO2Nhc2UgMzg6cmV0dXJuIFYoZSxsLkFNUCxyLHIrMSk7Y2FzZSA0MDpyZXR1cm4gVihlLGwuUEFSRU5fTCxyLHIrMSk7Y2FzZSA0MTpyZXR1cm4gVihlLGwuUEFSRU5fUixyLHIrMSk7Y2FzZSA0NjppZihuLmNoYXJDb2RlQXQocisxKT09PTQ2JiZuLmNoYXJDb2RlQXQocisyKT09PTQ2KXJldHVybiBWKGUsbC5TUFJFQUQscixyKzMpO2JyZWFrO2Nhc2UgNTg6cmV0dXJuIFYoZSxsLkNPTE9OLHIscisxKTtjYXNlIDYxOnJldHVybiBWKGUsbC5FUVVBTFMscixyKzEpO2Nhc2UgNjQ6cmV0dXJuIFYoZSxsLkFULHIscisxKTtjYXNlIDkxOnJldHVybiBWKGUsbC5CUkFDS0VUX0wscixyKzEpO2Nhc2UgOTM6cmV0dXJuIFYoZSxsLkJSQUNLRVRfUixyLHIrMSk7Y2FzZSAxMjM6cmV0dXJuIFYoZSxsLkJSQUNFX0wscixyKzEpO2Nhc2UgMTI0OnJldHVybiBWKGUsbC5QSVBFLHIscisxKTtjYXNlIDEyNTpyZXR1cm4gVihlLGwuQlJBQ0VfUixyLHIrMSk7Y2FzZSAzNDpyZXR1cm4gbi5jaGFyQ29kZUF0KHIrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHIrMik9PT0zND9CbihlLHIpOlJuKGUscil9aWYoTmUocyl8fHM9PT00NSlyZXR1cm4ga24oZSxyLHMpO2lmKEl0KHMpKXJldHVybiAkbihlLHIpO3Rocm93IEcoZS5zb3VyY2UscixzPT09Mzk/YFVuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoJyksIGRpZCB5b3UgbWVhbiB0byB1c2UgYSBkb3VibGUgcXVvdGUgKCIpP2A6ZmUocyl8fHdlKG4scik/YFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke2FlKGUscil9LmA6YEludmFsaWQgY2hhcmFjdGVyOiAke2FlKGUscil9LmApfXJldHVybiBWKGUsbC5FT0YsaSxpKX1mdW5jdGlvbiBDbihlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keSxpPW4ubGVuZ3RoO2xldCByPXQrMTtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO2lmKHM9PT0xMHx8cz09PTEzKWJyZWFrO2lmKGZlKHMpKSsrcjtlbHNlIGlmKHdlKG4scikpcis9MjtlbHNlIGJyZWFrfXJldHVybiBWKGUsbC5DT01NRU5ULHQscixuLnNsaWNlKHQrMSxyKSl9ZnVuY3Rpb24ga24oZSx0LG4pe2NvbnN0IGk9ZS5zb3VyY2UuYm9keTtsZXQgcj10LHM9bixvPSExO2lmKHM9PT00NSYmKHM9aS5jaGFyQ29kZUF0KCsrcikpLHM9PT00OCl7aWYocz1pLmNoYXJDb2RlQXQoKytyKSxOZShzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCB1bmV4cGVjdGVkIGRpZ2l0IGFmdGVyIDA6ICR7YWUoZSxyKX0uYCl9ZWxzZSByPVdlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKTtpZihzPT09NDYmJihvPSEwLHM9aS5jaGFyQ29kZUF0KCsrcikscj1XZShlLHIscykscz1pLmNoYXJDb2RlQXQocikpLChzPT09Njl8fHM9PT0xMDEpJiYobz0hMCxzPWkuY2hhckNvZGVBdCgrK3IpLChzPT09NDN8fHM9PT00NSkmJihzPWkuY2hhckNvZGVBdCgrK3IpKSxyPVdlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKSkscz09PTQ2fHxJdChzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke2FlKGUscil9LmApO3JldHVybiBWKGUsbz9sLkZMT0FUOmwuSU5ULHQscixpLnNsaWNlKHQscikpfWZ1bmN0aW9uIFdlKGUsdCxuKXtpZighTmUobikpdGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogJHthZShlLHQpfS5gKTtjb25zdCBpPWUuc291cmNlLmJvZHk7bGV0IHI9dCsxO2Zvcig7TmUoaS5jaGFyQ29kZUF0KHIpKTspKytyO3JldHVybiByfWZ1bmN0aW9uIFJuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxLHM9cixvPSIiO2Zvcig7cjxpOyl7Y29uc3QgYz1uLmNoYXJDb2RlQXQocik7aWYoYz09PTM0KXJldHVybiBvKz1uLnNsaWNlKHMsciksVihlLGwuU1RSSU5HLHQscisxLG8pO2lmKGM9PT05Mil7bys9bi5zbGljZShzLHIpO2NvbnN0IGY9bi5jaGFyQ29kZUF0KHIrMSk9PT0xMTc/bi5jaGFyQ29kZUF0KHIrMik9PT0xMjM/TG4oZSxyKTpQbihlLHIpOkZuKGUscik7bys9Zi52YWx1ZSxyKz1mLnNpemUscz1yO2NvbnRpbnVlfWlmKGM9PT0xMHx8Yz09PTEzKWJyZWFrO2lmKGZlKGMpKSsrcjtlbHNlIGlmKHdlKG4scikpcis9MjtlbHNlIHRocm93IEcoZS5zb3VyY2UscixgSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogJHthZShlLHIpfS5gKX10aHJvdyBHKGUuc291cmNlLHIsIlVudGVybWluYXRlZCBzdHJpbmcuIil9ZnVuY3Rpb24gTG4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7bGV0IGk9MCxyPTM7Zm9yKDtyPDEyOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQodCtyKyspO2lmKHM9PT0xMjUpe2lmKHI8NXx8IWZlKGkpKWJyZWFrO3JldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOnJ9fWlmKGk9aTw8NHx4ZShzKSxpPDApYnJlYWt9dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCtyKX0iLmApfWZ1bmN0aW9uIFBuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9d3Qobix0KzIpO2lmKGZlKGkpKXJldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOjZ9O2lmKE90KGkpJiZuLmNoYXJDb2RlQXQodCs2KT09PTkyJiZuLmNoYXJDb2RlQXQodCs3KT09PTExNyl7Y29uc3Qgcj13dChuLHQrOCk7aWYoU3QocikpcmV0dXJue3ZhbHVlOlN0cmluZy5mcm9tQ29kZVBvaW50KGksciksc2l6ZToxMn19dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCs2KX0iLmApfWZ1bmN0aW9uIHd0KGUsdCl7cmV0dXJuIHhlKGUuY2hhckNvZGVBdCh0KSk8PDEyfHhlKGUuY2hhckNvZGVBdCh0KzEpKTw8OHx4ZShlLmNoYXJDb2RlQXQodCsyKSk8PDR8eGUoZS5jaGFyQ29kZUF0KHQrMykpfWZ1bmN0aW9uIHhlKGUpe3JldHVybiBlPj00OCYmZTw9NTc/ZS00ODplPj02NSYmZTw9NzA/ZS01NTplPj05NyYmZTw9MTAyP2UtODc6LTF9ZnVuY3Rpb24gRm4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7c3dpdGNoKG4uY2hhckNvZGVBdCh0KzEpKXtjYXNlIDM0OnJldHVybnt2YWx1ZTonIicsc2l6ZToyfTtjYXNlIDkyOnJldHVybnt2YWx1ZToiXFwiLHNpemU6Mn07Y2FzZSA0NzpyZXR1cm57dmFsdWU6Ii8iLHNpemU6Mn07Y2FzZSA5ODpyZXR1cm57dmFsdWU6IlxiIixzaXplOjJ9O2Nhc2UgMTAyOnJldHVybnt2YWx1ZToiXGYiLHNpemU6Mn07Y2FzZSAxMTA6cmV0dXJue3ZhbHVlOmAKYCxzaXplOjJ9O2Nhc2UgMTE0OnJldHVybnt2YWx1ZToiXHIiLHNpemU6Mn07Y2FzZSAxMTY6cmV0dXJue3ZhbHVlOiIJIixzaXplOjJ9fXRocm93IEcoZS5zb3VyY2UsdCxgSW52YWxpZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCsyKX0iLmApfWZ1bmN0aW9uIEJuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9ZS5saW5lU3RhcnQscz10KzMsbz1zLGM9IiI7Y29uc3QgZj1bXTtmb3IoO3M8aTspe2NvbnN0IGQ9bi5jaGFyQ29kZUF0KHMpO2lmKGQ9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCl7Yys9bi5zbGljZShvLHMpLGYucHVzaChjKTtjb25zdCB1PVYoZSxsLkJMT0NLX1NUUklORyx0LHMrMyxBbihmKS5qb2luKGAKYCkpO3JldHVybiBlLmxpbmUrPWYubGVuZ3RoLTEsZS5saW5lU3RhcnQ9cix1fWlmKGQ9PT05MiYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMyk9PT0zNCl7Yys9bi5zbGljZShvLHMpLG89cysxLHMrPTQ7Y29udGludWV9aWYoZD09PTEwfHxkPT09MTMpe2MrPW4uc2xpY2UobyxzKSxmLnB1c2goYyksZD09PTEzJiZuLmNoYXJDb2RlQXQocysxKT09PTEwP3MrPTI6KytzLGM9IiIsbz1zLHI9cztjb250aW51ZX1pZihmZShkKSkrK3M7ZWxzZSBpZih3ZShuLHMpKXMrPTI7ZWxzZSB0aHJvdyBHKGUuc291cmNlLHMsYEludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6ICR7YWUoZSxzKX0uYCl9dGhyb3cgRyhlLnNvdXJjZSxzLCJVbnRlcm1pbmF0ZWQgc3RyaW5nLiIpfWZ1bmN0aW9uICRuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxO2Zvcig7cjxpOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQocik7aWYoeG4ocykpKytyO2Vsc2UgYnJlYWt9cmV0dXJuIFYoZSxsLk5BTUUsdCxyLG4uc2xpY2UodCxyKSl9Y29uc3QgTW49MTAsRHQ9MjtmdW5jdGlvbiBaZShlKXtyZXR1cm4gRGUoZSxbXSl9ZnVuY3Rpb24gRGUoZSx0KXtzd2l0Y2godHlwZW9mIGUpe2Nhc2Uic3RyaW5nIjpyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSk7Y2FzZSJmdW5jdGlvbiI6cmV0dXJuIGUubmFtZT9gW2Z1bmN0aW9uICR7ZS5uYW1lfV1gOiJbZnVuY3Rpb25dIjtjYXNlIm9iamVjdCI6cmV0dXJuIFVuKGUsdCk7ZGVmYXVsdDpyZXR1cm4gU3RyaW5nKGUpfX1mdW5jdGlvbiBVbihlLHQpe2lmKGU9PT1udWxsKXJldHVybiJudWxsIjtpZih0LmluY2x1ZGVzKGUpKXJldHVybiJbQ2lyY3VsYXJdIjtjb25zdCBuPVsuLi50LGVdO2lmKFZuKGUpKXtjb25zdCBpPWUudG9KU09OKCk7aWYoaSE9PWUpcmV0dXJuIHR5cGVvZiBpPT0ic3RyaW5nIj9pOkRlKGksbil9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBxbihlLG4pO3JldHVybiBqbihlLG4pfWZ1bmN0aW9uIFZuKGUpe3JldHVybiB0eXBlb2YgZS50b0pTT049PSJmdW5jdGlvbiJ9ZnVuY3Rpb24gam4oZSx0KXtjb25zdCBuPU9iamVjdC5lbnRyaWVzKGUpO3JldHVybiBuLmxlbmd0aD09PTA/Int9Ijp0Lmxlbmd0aD5EdD8iWyIrR24oZSkrIl0iOiJ7ICIrbi5tYXAoKFtyLHNdKT0+cisiOiAiK0RlKHMsdCkpLmpvaW4oIiwgIikrIiB9In1mdW5jdGlvbiBxbihlLHQpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4iW10iO2lmKHQubGVuZ3RoPkR0KXJldHVybiJbQXJyYXldIjtjb25zdCBuPU1hdGgubWluKE1uLGUubGVuZ3RoKSxpPWUubGVuZ3RoLW4scj1bXTtmb3IobGV0IHM9MDtzPG47KytzKXIucHVzaChEZShlW3NdLHQpKTtyZXR1cm4gaT09PTE/ci5wdXNoKCIuLi4gMSBtb3JlIGl0ZW0iKTppPjEmJnIucHVzaChgLi4uICR7aX0gbW9yZSBpdGVtc2ApLCJbIityLmpvaW4oIiwgIikrIl0ifWZ1bmN0aW9uIEduKGUpe2NvbnN0IHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnJlcGxhY2UoL15cW29iamVjdCAvLCIiKS5yZXBsYWNlKC9dJC8sIiIpO2lmKHQ9PT0iT2JqZWN0IiYmdHlwZW9mIGUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiIpe2NvbnN0IG49ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKHR5cGVvZiBuPT0ic3RyaW5nIiYmbiE9PSIiKXJldHVybiBufXJldHVybiB0fWNvbnN0IEhuPWdsb2JhbFRoaXMucHJvY2VzcyYmZ2xvYmFsVGhpcy5wcm9jZXNzLmVudi5OT0RFX0VOVj09PSJwcm9kdWN0aW9uIj9mdW5jdGlvbih0LG4pe3JldHVybiB0IGluc3RhbmNlb2Ygbn06ZnVuY3Rpb24odCxuKXtpZih0IGluc3RhbmNlb2YgbilyZXR1cm4hMDtpZih0eXBlb2YgdD09Im9iamVjdCImJnQhPT1udWxsKXt2YXIgaTtjb25zdCByPW4ucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10scz1TeW1ib2wudG9TdHJpbmdUYWcgaW4gdD90W1N5bWJvbC50b1N0cmluZ1RhZ106KGk9dC5jb25zdHJ1Y3Rvcik9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLm5hbWU7aWYocj09PXMpe2NvbnN0IG89WmUodCk7dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlICR7cn0gIiR7b30iIGZyb20gYW5vdGhlciBtb2R1bGUgb3IgcmVhbG0uCgpFbnN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiAiZ3JhcGhxbCIgaW4gdGhlIG5vZGVfbW9kdWxlcwpkaXJlY3RvcnkuIElmIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiAiZ3JhcGhxbCIgYXJlIHRoZSBkZXBlbmRlbmNpZXMgb2Ygb3RoZXIKcmVsaWVkIG9uIG1vZHVsZXMsIHVzZSAicmVzb2x1dGlvbnMiIHRvIGVuc3VyZSBvbmx5IG9uZSB2ZXJzaW9uIGlzIGluc3RhbGxlZC4KCmh0dHBzOi8veWFybnBrZy5jb20vZW4vZG9jcy9zZWxlY3RpdmUtdmVyc2lvbi1yZXNvbHV0aW9ucwoKRHVwbGljYXRlICJncmFwaHFsIiBtb2R1bGVzIGNhbm5vdCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUgc2luY2UgZGlmZmVyZW50CnZlcnNpb25zIG1heSBoYXZlIGRpZmZlcmVudCBjYXBhYmlsaXRpZXMgYW5kIGJlaGF2aW9yLiBUaGUgZGF0YSBmcm9tIG9uZQp2ZXJzaW9uIHVzZWQgaW4gdGhlIGZ1bmN0aW9uIGZyb20gYW5vdGhlciBjb3VsZCBwcm9kdWNlIGNvbmZ1c2luZyBhbmQKc3B1cmlvdXMgcmVzdWx0cy5gKX19cmV0dXJuITF9O2NsYXNzIEN0e2NvbnN0cnVjdG9yKHQsbj0iR3JhcGhRTCByZXF1ZXN0IixpPXtsaW5lOjEsY29sdW1uOjF9KXt0eXBlb2YgdD09InN0cmluZyJ8fFNlKCExLGBCb2R5IG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkOiAke1plKHQpfS5gKSx0aGlzLmJvZHk9dCx0aGlzLm5hbWU9bix0aGlzLmxvY2F0aW9uT2Zmc2V0PWksdGhpcy5sb2NhdGlvbk9mZnNldC5saW5lPjB8fFNlKCExLCJsaW5lIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS4iKSx0aGlzLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbj4wfHxTZSghMSwiY29sdW1uIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS4iKX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiJTb3VyY2UifX1mdW5jdGlvbiB6bihlKXtyZXR1cm4gSG4oZSxDdCl9ZnVuY3Rpb24ga3QoZSx0KXtyZXR1cm4gbmV3IFluKGUsdCkucGFyc2VEb2N1bWVudCgpfWNsYXNzIFlue2NvbnN0cnVjdG9yKHQsbj17fSl7Y29uc3QgaT16bih0KT90Om5ldyBDdCh0KTt0aGlzLl9sZXhlcj1uZXcgU24oaSksdGhpcy5fb3B0aW9ucz1uLHRoaXMuX3Rva2VuQ291bnRlcj0wfXBhcnNlTmFtZSgpe2NvbnN0IHQ9dGhpcy5leHBlY3RUb2tlbihsLk5BTUUpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk5BTUUsdmFsdWU6dC52YWx1ZX0pfXBhcnNlRG9jdW1lbnQoKXtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuRE9DVU1FTlQsZGVmaW5pdGlvbnM6dGhpcy5tYW55KGwuU09GLHRoaXMucGFyc2VEZWZpbml0aW9uLGwuRU9GKX0pfXBhcnNlRGVmaW5pdGlvbigpe2lmKHRoaXMucGVlayhsLkJSQUNFX0wpKXJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO2NvbnN0IHQ9dGhpcy5wZWVrRGVzY3JpcHRpb24oKSxuPXQ/dGhpcy5fbGV4ZXIubG9va2FoZWFkKCk6dGhpcy5fbGV4ZXIudG9rZW47aWYobi5raW5kPT09bC5OQU1FKXtzd2l0Y2gobi52YWx1ZSl7Y2FzZSJzY2hlbWEiOnJldHVybiB0aGlzLnBhcnNlU2NoZW1hRGVmaW5pdGlvbigpO2Nhc2Uic2NhbGFyIjpyZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCk7Y2FzZSJ0eXBlIjpyZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCk7Y2FzZSJpbnRlcmZhY2UiOnJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKTtjYXNlInVuaW9uIjpyZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKTtjYXNlImVudW0iOnJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCk7Y2FzZSJpbnB1dCI6cmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uKCk7Y2FzZSJkaXJlY3RpdmUiOnJldHVybiB0aGlzLnBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpfWlmKHQpdGhyb3cgRyh0aGlzLl9sZXhlci5zb3VyY2UsdGhpcy5fbGV4ZXIudG9rZW4uc3RhcnQsIlVuZXhwZWN0ZWQgZGVzY3JpcHRpb24sIGRlc2NyaXB0aW9ucyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gdHlwZSBkZWZpbml0aW9ucy4iKTtzd2l0Y2gobi52YWx1ZSl7Y2FzZSJxdWVyeSI6Y2FzZSJtdXRhdGlvbiI6Y2FzZSJzdWJzY3JpcHRpb24iOnJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO2Nhc2UiZnJhZ21lbnQiOnJldHVybiB0aGlzLnBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCk7Y2FzZSJleHRlbmQiOnJldHVybiB0aGlzLnBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpfX10aHJvdyB0aGlzLnVuZXhwZWN0ZWQobil9cGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtpZih0aGlzLnBlZWsobC5CUkFDRV9MKSlyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5PUEVSQVRJT05fREVGSU5JVElPTixvcGVyYXRpb246bGUuUVVFUlksbmFtZTp2b2lkIDAsdmFyaWFibGVEZWZpbml0aW9uczpbXSxkaXJlY3RpdmVzOltdLHNlbGVjdGlvblNldDp0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCl9KTtjb25zdCBuPXRoaXMucGFyc2VPcGVyYXRpb25UeXBlKCk7bGV0IGk7cmV0dXJuIHRoaXMucGVlayhsLk5BTUUpJiYoaT10aGlzLnBhcnNlTmFtZSgpKSx0aGlzLm5vZGUodCx7a2luZDpULk9QRVJBVElPTl9ERUZJTklUSU9OLG9wZXJhdGlvbjpuLG5hbWU6aSx2YXJpYWJsZURlZmluaXRpb25zOnRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKX0pfXBhcnNlT3BlcmF0aW9uVHlwZSgpe2NvbnN0IHQ9dGhpcy5leHBlY3RUb2tlbihsLk5BTUUpO3N3aXRjaCh0LnZhbHVlKXtjYXNlInF1ZXJ5IjpyZXR1cm4gbGUuUVVFUlk7Y2FzZSJtdXRhdGlvbiI6cmV0dXJuIGxlLk1VVEFUSU9OO2Nhc2Uic3Vic2NyaXB0aW9uIjpyZXR1cm4gbGUuU1VCU0NSSVBUSU9OfXRocm93IHRoaXMudW5leHBlY3RlZCh0KX1wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5QQVJFTl9MLHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb24sbC5QQVJFTl9SKX1wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbigpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5WQVJJQUJMRV9ERUZJTklUSU9OLHZhcmlhYmxlOnRoaXMucGFyc2VWYXJpYWJsZSgpLHR5cGU6KHRoaXMuZXhwZWN0VG9rZW4obC5DT0xPTiksdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKSksZGVmYXVsdFZhbHVlOnRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihsLkVRVUFMUyk/dGhpcy5wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCk6dm9pZCAwLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpfSl9cGFyc2VWYXJpYWJsZSgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4obC5ET0xMQVIpLHRoaXMubm9kZSh0LHtraW5kOlQuVkFSSUFCTEUsbmFtZTp0aGlzLnBhcnNlTmFtZSgpfSl9cGFyc2VTZWxlY3Rpb25TZXQoKXtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuU0VMRUNUSU9OX1NFVCxzZWxlY3Rpb25zOnRoaXMubWFueShsLkJSQUNFX0wsdGhpcy5wYXJzZVNlbGVjdGlvbixsLkJSQUNFX1IpfSl9cGFyc2VTZWxlY3Rpb24oKXtyZXR1cm4gdGhpcy5wZWVrKGwuU1BSRUFEKT90aGlzLnBhcnNlRnJhZ21lbnQoKTp0aGlzLnBhcnNlRmllbGQoKX1wYXJzZUZpZWxkKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VOYW1lKCk7bGV0IGkscjtyZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuQ09MT04pPyhpPW4scj10aGlzLnBhcnNlTmFtZSgpKTpyPW4sdGhpcy5ub2RlKHQse2tpbmQ6VC5GSUVMRCxhbGlhczppLG5hbWU6cixhcmd1bWVudHM6dGhpcy5wYXJzZUFyZ3VtZW50cyghMSksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGVlayhsLkJSQUNFX0wpP3RoaXMucGFyc2VTZWxlY3Rpb25TZXQoKTp2b2lkIDB9KX1wYXJzZUFyZ3VtZW50cyh0KXtjb25zdCBuPXQ/dGhpcy5wYXJzZUNvbnN0QXJndW1lbnQ6dGhpcy5wYXJzZUFyZ3VtZW50O3JldHVybiB0aGlzLm9wdGlvbmFsTWFueShsLlBBUkVOX0wsbixsLlBBUkVOX1IpfXBhcnNlQXJndW1lbnQodD0hMSl7Y29uc3Qgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VOYW1lKCk7cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4obC5DT0xPTiksdGhpcy5ub2RlKG4se2tpbmQ6VC5BUkdVTUVOVCxuYW1lOmksdmFsdWU6dGhpcy5wYXJzZVZhbHVlTGl0ZXJhbCh0KX0pfXBhcnNlQ29uc3RBcmd1bWVudCgpe3JldHVybiB0aGlzLnBhcnNlQXJndW1lbnQoITApfXBhcnNlRnJhZ21lbnQoKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0VG9rZW4obC5TUFJFQUQpO2NvbnN0IG49dGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoIm9uIik7cmV0dXJuIW4mJnRoaXMucGVlayhsLk5BTUUpP3RoaXMubm9kZSh0LHtraW5kOlQuRlJBR01FTlRfU1BSRUFELG5hbWU6dGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZURpcmVjdGl2ZXMoITEpfSk6dGhpcy5ub2RlKHQse2tpbmQ6VC5JTkxJTkVfRlJBR01FTlQsdHlwZUNvbmRpdGlvbjpuP3RoaXMucGFyc2VOYW1lZFR5cGUoKTp2b2lkIDAsZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKX0pfXBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtyZXR1cm4gdGhpcy5leHBlY3RLZXl3b3JkKCJmcmFnbWVudCIpLHRoaXMuX29wdGlvbnMuYWxsb3dMZWdhY3lGcmFnbWVudFZhcmlhYmxlcz09PSEwP3RoaXMubm9kZSh0LHtraW5kOlQuRlJBR01FTlRfREVGSU5JVElPTixuYW1lOnRoaXMucGFyc2VGcmFnbWVudE5hbWUoKSx2YXJpYWJsZURlZmluaXRpb25zOnRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksdHlwZUNvbmRpdGlvbjoodGhpcy5leHBlY3RLZXl3b3JkKCJvbiIpLHRoaXMucGFyc2VOYW1lZFR5cGUoKSksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKX0pOnRoaXMubm9kZSh0LHtraW5kOlQuRlJBR01FTlRfREVGSU5JVElPTixuYW1lOnRoaXMucGFyc2VGcmFnbWVudE5hbWUoKSx0eXBlQ29uZGl0aW9uOih0aGlzLmV4cGVjdEtleXdvcmQoIm9uIiksdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSl9cGFyc2VGcmFnbWVudE5hbWUoKXtpZih0aGlzLl9sZXhlci50b2tlbi52YWx1ZT09PSJvbiIpdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMucGFyc2VOYW1lKCl9cGFyc2VWYWx1ZUxpdGVyYWwodCl7Y29uc3Qgbj10aGlzLl9sZXhlci50b2tlbjtzd2l0Y2gobi5raW5kKXtjYXNlIGwuQlJBQ0tFVF9MOnJldHVybiB0aGlzLnBhcnNlTGlzdCh0KTtjYXNlIGwuQlJBQ0VfTDpyZXR1cm4gdGhpcy5wYXJzZU9iamVjdCh0KTtjYXNlIGwuSU5UOnJldHVybiB0aGlzLmFkdmFuY2VMZXhlcigpLHRoaXMubm9kZShuLHtraW5kOlQuSU5ULHZhbHVlOm4udmFsdWV9KTtjYXNlIGwuRkxPQVQ6cmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksdGhpcy5ub2RlKG4se2tpbmQ6VC5GTE9BVCx2YWx1ZTpuLnZhbHVlfSk7Y2FzZSBsLlNUUklORzpjYXNlIGwuQkxPQ0tfU1RSSU5HOnJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO2Nhc2UgbC5OQU1FOnN3aXRjaCh0aGlzLmFkdmFuY2VMZXhlcigpLG4udmFsdWUpe2Nhc2UidHJ1ZSI6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuQk9PTEVBTix2YWx1ZTohMH0pO2Nhc2UiZmFsc2UiOnJldHVybiB0aGlzLm5vZGUobix7a2luZDpULkJPT0xFQU4sdmFsdWU6ITF9KTtjYXNlIm51bGwiOnJldHVybiB0aGlzLm5vZGUobix7a2luZDpULk5VTEx9KTtkZWZhdWx0OnJldHVybiB0aGlzLm5vZGUobix7a2luZDpULkVOVU0sdmFsdWU6bi52YWx1ZX0pfWNhc2UgbC5ET0xMQVI6aWYodClpZih0aGlzLmV4cGVjdFRva2VuKGwuRE9MTEFSKSx0aGlzLl9sZXhlci50b2tlbi5raW5kPT09bC5OQU1FKXtjb25zdCBpPXRoaXMuX2xleGVyLnRva2VuLnZhbHVlO3Rocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYFVuZXhwZWN0ZWQgdmFyaWFibGUgIiQke2l9IiBpbiBjb25zdGFudCB2YWx1ZS5gKX1lbHNlIHRocm93IHRoaXMudW5leHBlY3RlZChuKTtyZXR1cm4gdGhpcy5wYXJzZVZhcmlhYmxlKCk7ZGVmYXVsdDp0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKX19cGFyc2VDb25zdFZhbHVlTGl0ZXJhbCgpe3JldHVybiB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKCEwKX1wYXJzZVN0cmluZ0xpdGVyYWwoKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3JldHVybiB0aGlzLmFkdmFuY2VMZXhlcigpLHRoaXMubm9kZSh0LHtraW5kOlQuU1RSSU5HLHZhbHVlOnQudmFsdWUsYmxvY2s6dC5raW5kPT09bC5CTE9DS19TVFJJTkd9KX1wYXJzZUxpc3QodCl7Y29uc3Qgbj0oKT0+dGhpcy5wYXJzZVZhbHVlTGl0ZXJhbCh0KTtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuTElTVCx2YWx1ZXM6dGhpcy5hbnkobC5CUkFDS0VUX0wsbixsLkJSQUNLRVRfUil9KX1wYXJzZU9iamVjdCh0KXtjb25zdCBuPSgpPT50aGlzLnBhcnNlT2JqZWN0RmllbGQodCk7cmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbix7a2luZDpULk9CSkVDVCxmaWVsZHM6dGhpcy5hbnkobC5CUkFDRV9MLG4sbC5CUkFDRV9SKX0pfXBhcnNlT2JqZWN0RmllbGQodCl7Y29uc3Qgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VOYW1lKCk7cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4obC5DT0xPTiksdGhpcy5ub2RlKG4se2tpbmQ6VC5PQkpFQ1RfRklFTEQsbmFtZTppLHZhbHVlOnRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodCl9KX1wYXJzZURpcmVjdGl2ZXModCl7Y29uc3Qgbj1bXTtmb3IoO3RoaXMucGVlayhsLkFUKTspbi5wdXNoKHRoaXMucGFyc2VEaXJlY3RpdmUodCkpO3JldHVybiBufXBhcnNlQ29uc3REaXJlY3RpdmVzKCl7cmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVzKCEwKX1wYXJzZURpcmVjdGl2ZSh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO3JldHVybiB0aGlzLmV4cGVjdFRva2VuKGwuQVQpLHRoaXMubm9kZShuLHtraW5kOlQuRElSRUNUSVZFLG5hbWU6dGhpcy5wYXJzZU5hbWUoKSxhcmd1bWVudHM6dGhpcy5wYXJzZUFyZ3VtZW50cyh0KX0pfXBhcnNlVHlwZVJlZmVyZW5jZSgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47bGV0IG47aWYodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuQlJBQ0tFVF9MKSl7Y29uc3QgaT10aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpO3RoaXMuZXhwZWN0VG9rZW4obC5CUkFDS0VUX1IpLG49dGhpcy5ub2RlKHQse2tpbmQ6VC5MSVNUX1RZUEUsdHlwZTppfSl9ZWxzZSBuPXRoaXMucGFyc2VOYW1lZFR5cGUoKTtyZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuQkFORyk/dGhpcy5ub2RlKHQse2tpbmQ6VC5OT05fTlVMTF9UWVBFLHR5cGU6bn0pOm59cGFyc2VOYW1lZFR5cGUoKXtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuTkFNRURfVFlQRSxuYW1lOnRoaXMucGFyc2VOYW1lKCl9KX1wZWVrRGVzY3JpcHRpb24oKXtyZXR1cm4gdGhpcy5wZWVrKGwuU1RSSU5HKXx8dGhpcy5wZWVrKGwuQkxPQ0tfU1RSSU5HKX1wYXJzZURlc2NyaXB0aW9uKCl7aWYodGhpcy5wZWVrRGVzY3JpcHRpb24oKSlyZXR1cm4gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoKX1wYXJzZVNjaGVtYURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJzY2hlbWEiKTtjb25zdCBpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxyPXRoaXMubWFueShsLkJSQUNFX0wsdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLGwuQlJBQ0VfUik7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuU0NIRU1BX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixkaXJlY3RpdmVzOmksb3BlcmF0aW9uVHlwZXM6cn0pfXBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTt0aGlzLmV4cGVjdFRva2VuKGwuQ09MT04pO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWVkVHlwZSgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk9QRVJBVElPTl9UWVBFX0RFRklOSVRJT04sb3BlcmF0aW9uOm4sdHlwZTppfSl9cGFyc2VTY2FsYXJUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInNjYWxhciIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5TQ0FMQVJfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cn0pfXBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJ0eXBlIik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkscz10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCksbz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk9CSkVDVF9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksaW50ZXJmYWNlczpyLGRpcmVjdGl2ZXM6cyxmaWVsZHM6b30pfXBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKXtyZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoImltcGxlbWVudHMiKT90aGlzLmRlbGltaXRlZE1hbnkobC5BTVAsdGhpcy5wYXJzZU5hbWVkVHlwZSk6W119cGFyc2VGaWVsZHNEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlRmllbGREZWZpbml0aW9uLGwuQlJBQ0VfUil9cGFyc2VGaWVsZERlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCksaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUFyZ3VtZW50RGVmcygpO3RoaXMuZXhwZWN0VG9rZW4obC5DT0xPTik7Y29uc3Qgcz10aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpLG89dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULkZJRUxEX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksYXJndW1lbnRzOnIsdHlwZTpzLGRpcmVjdGl2ZXM6b30pfXBhcnNlQXJndW1lbnREZWZzKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuUEFSRU5fTCx0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixsLlBBUkVOX1IpfXBhcnNlSW5wdXRWYWx1ZURlZigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKSxpPXRoaXMucGFyc2VOYW1lKCk7dGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKTtjb25zdCByPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7bGV0IHM7dGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuRVFVQUxTKSYmKHM9dGhpcy5wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCkpO2NvbnN0IG89dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOUFVUX1ZBTFVFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksdHlwZTpyLGRlZmF1bHRWYWx1ZTpzLGRpcmVjdGl2ZXM6b30pfXBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJpbnRlcmZhY2UiKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKSxzPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxvPXRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuSU5URVJGQUNFX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxpbnRlcmZhY2VzOnIsZGlyZWN0aXZlczpzLGZpZWxkczpvfSl9cGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgidW5pb24iKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlVOSU9OX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxkaXJlY3RpdmVzOnIsdHlwZXM6c30pfXBhcnNlVW5pb25NZW1iZXJUeXBlcygpe3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5FUVVBTFMpP3RoaXMuZGVsaW1pdGVkTWFueShsLlBJUEUsdGhpcy5wYXJzZU5hbWVkVHlwZSk6W119cGFyc2VFbnVtVHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJlbnVtIik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHM9dGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRU5VTV9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksZGlyZWN0aXZlczpyLHZhbHVlczpzfSl9cGFyc2VFbnVtVmFsdWVzRGVmaW5pdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbmFsTWFueShsLkJSQUNFX0wsdGhpcy5wYXJzZUVudW1WYWx1ZURlZmluaXRpb24sbC5CUkFDRV9SKX1wYXJzZUVudW1WYWx1ZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCksaT10aGlzLnBhcnNlRW51bVZhbHVlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULkVOVU1fVkFMVUVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxkaXJlY3RpdmVzOnJ9KX1wYXJzZUVudW1WYWx1ZU5hbWUoKXtpZih0aGlzLl9sZXhlci50b2tlbi52YWx1ZT09PSJ0cnVlInx8dGhpcy5fbGV4ZXIudG9rZW4udmFsdWU9PT0iZmFsc2UifHx0aGlzLl9sZXhlci50b2tlbi52YWx1ZT09PSJudWxsIil0aHJvdyBHKHRoaXMuX2xleGVyLnNvdXJjZSx0aGlzLl9sZXhlci50b2tlbi5zdGFydCxgJHtDZSh0aGlzLl9sZXhlci50b2tlbil9IGlzIHJlc2VydmVkIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgYW4gZW51bSB2YWx1ZS5gKTtyZXR1cm4gdGhpcy5wYXJzZU5hbWUoKX1wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJpbnB1dCIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxzPXRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cixmaWVsZHM6c30pfXBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixsLkJSQUNFX1IpfXBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIubG9va2FoZWFkKCk7aWYodC5raW5kPT09bC5OQU1FKXN3aXRjaCh0LnZhbHVlKXtjYXNlInNjaGVtYSI6cmV0dXJuIHRoaXMucGFyc2VTY2hlbWFFeHRlbnNpb24oKTtjYXNlInNjYWxhciI6cmV0dXJuIHRoaXMucGFyc2VTY2FsYXJUeXBlRXh0ZW5zaW9uKCk7Y2FzZSJ0eXBlIjpyZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKTtjYXNlImludGVyZmFjZSI6cmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKCk7Y2FzZSJ1bmlvbiI6cmV0dXJuIHRoaXMucGFyc2VVbmlvblR5cGVFeHRlbnNpb24oKTtjYXNlImVudW0iOnJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVFeHRlbnNpb24oKTtjYXNlImlucHV0IjpyZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbigpfXRocm93IHRoaXMudW5leHBlY3RlZCh0KX1wYXJzZVNjaGVtYUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoInNjaGVtYSIpO2NvbnN0IG49dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLGk9dGhpcy5vcHRpb25hbE1hbnkobC5CUkFDRV9MLHRoaXMucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbixsLkJSQUNFX1IpO2lmKG4ubGVuZ3RoPT09MCYmaS5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlNDSEVNQV9FWFRFTlNJT04sZGlyZWN0aXZlczpuLG9wZXJhdGlvblR5cGVzOml9KX1wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJzY2FsYXIiKTtjb25zdCBuPXRoaXMucGFyc2VOYW1lKCksaT10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7aWYoaS5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlNDQUxBUl9UWVBFX0VYVEVOU0lPTixuYW1lOm4sZGlyZWN0aXZlczppfSl9cGFyc2VPYmplY3RUeXBlRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgidHlwZSIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHM9dGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtpZihpLmxlbmd0aD09PTAmJnIubGVuZ3RoPT09MCYmcy5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk9CSkVDVF9UWVBFX0VYVEVOU0lPTixuYW1lOm4saW50ZXJmYWNlczppLGRpcmVjdGl2ZXM6cixmaWVsZHM6c30pfXBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImludGVyZmFjZSIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHM9dGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtpZihpLmxlbmd0aD09PTAmJnIubGVuZ3RoPT09MCYmcy5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTixuYW1lOm4saW50ZXJmYWNlczppLGRpcmVjdGl2ZXM6cixmaWVsZHM6c30pfXBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgidW5pb24iKTtjb25zdCBuPXRoaXMucGFyc2VOYW1lKCksaT10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscj10aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlVOSU9OX1RZUEVfRVhURU5TSU9OLG5hbWU6bixkaXJlY3RpdmVzOmksdHlwZXM6cn0pfXBhcnNlRW51bVR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJlbnVtIik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHI9dGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7aWYoaS5sZW5ndGg9PT0wJiZyLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRU5VTV9UWVBFX0VYVEVOU0lPTixuYW1lOm4sZGlyZWN0aXZlczppLHZhbHVlczpyfSl9cGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJpbnB1dCIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxyPXRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtpZihpLmxlbmd0aD09PTAmJnIubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT04sbmFtZTpuLGRpcmVjdGl2ZXM6aSxmaWVsZHM6cn0pfXBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImRpcmVjdGl2ZSIpLHRoaXMuZXhwZWN0VG9rZW4obC5BVCk7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUFyZ3VtZW50RGVmcygpLHM9dGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoInJlcGVhdGFibGUiKTt0aGlzLmV4cGVjdEtleXdvcmQoIm9uIik7Y29uc3Qgbz10aGlzLnBhcnNlRGlyZWN0aXZlTG9jYXRpb25zKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRElSRUNUSVZFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksYXJndW1lbnRzOnIscmVwZWF0YWJsZTpzLGxvY2F0aW9uczpvfSl9cGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5kZWxpbWl0ZWRNYW55KGwuUElQRSx0aGlzLnBhcnNlRGlyZWN0aXZlTG9jYXRpb24pfXBhcnNlRGlyZWN0aXZlTG9jYXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZU5hbWUoKTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUWUsbi52YWx1ZSkpcmV0dXJuIG47dGhyb3cgdGhpcy51bmV4cGVjdGVkKHQpfW5vZGUodCxuKXtyZXR1cm4gdGhpcy5fb3B0aW9ucy5ub0xvY2F0aW9uIT09ITAmJihuLmxvYz1uZXcgYm4odCx0aGlzLl9sZXhlci5sYXN0VG9rZW4sdGhpcy5fbGV4ZXIuc291cmNlKSksbn1wZWVrKHQpe3JldHVybiB0aGlzLl9sZXhlci50b2tlbi5raW5kPT09dH1leHBlY3RUb2tlbih0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO2lmKG4ua2luZD09PXQpcmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksbjt0aHJvdyBHKHRoaXMuX2xleGVyLnNvdXJjZSxuLnN0YXJ0LGBFeHBlY3RlZCAke1J0KHQpfSwgZm91bmQgJHtDZShuKX0uYCl9ZXhwZWN0T3B0aW9uYWxUb2tlbih0KXtyZXR1cm4gdGhpcy5fbGV4ZXIudG9rZW4ua2luZD09PXQ/KHRoaXMuYWR2YW5jZUxleGVyKCksITApOiExfWV4cGVjdEtleXdvcmQodCl7Y29uc3Qgbj10aGlzLl9sZXhlci50b2tlbjtpZihuLmtpbmQ9PT1sLk5BTUUmJm4udmFsdWU9PT10KXRoaXMuYWR2YW5jZUxleGVyKCk7ZWxzZSB0aHJvdyBHKHRoaXMuX2xleGVyLnNvdXJjZSxuLnN0YXJ0LGBFeHBlY3RlZCAiJHt0fSIsIGZvdW5kICR7Q2Uobil9LmApfWV4cGVjdE9wdGlvbmFsS2V5d29yZCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO3JldHVybiBuLmtpbmQ9PT1sLk5BTUUmJm4udmFsdWU9PT10Pyh0aGlzLmFkdmFuY2VMZXhlcigpLCEwKTohMX11bmV4cGVjdGVkKHQpe2NvbnN0IG49dCE9bnVsbD90OnRoaXMuX2xleGVyLnRva2VuO3JldHVybiBHKHRoaXMuX2xleGVyLnNvdXJjZSxuLnN0YXJ0LGBVbmV4cGVjdGVkICR7Q2Uobil9LmApfWFueSh0LG4saSl7dGhpcy5leHBlY3RUb2tlbih0KTtjb25zdCByPVtdO2Zvcig7IXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihpKTspci5wdXNoKG4uY2FsbCh0aGlzKSk7cmV0dXJuIHJ9b3B0aW9uYWxNYW55KHQsbixpKXtpZih0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4odCkpe2NvbnN0IHI9W107ZG8gci5wdXNoKG4uY2FsbCh0aGlzKSk7d2hpbGUoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihpKSk7cmV0dXJuIHJ9cmV0dXJuW119bWFueSh0LG4saSl7dGhpcy5leHBlY3RUb2tlbih0KTtjb25zdCByPVtdO2RvIHIucHVzaChuLmNhbGwodGhpcykpO3doaWxlKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oaSkpO3JldHVybiByfWRlbGltaXRlZE1hbnkodCxuKXt0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4odCk7Y29uc3QgaT1bXTtkbyBpLnB1c2gobi5jYWxsKHRoaXMpKTt3aGlsZSh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4odCkpO3JldHVybiBpfWFkdmFuY2VMZXhlcigpe2NvbnN0e21heFRva2Vuczp0fT10aGlzLl9vcHRpb25zLG49dGhpcy5fbGV4ZXIuYWR2YW5jZSgpO2lmKHQhPT12b2lkIDAmJm4ua2luZCE9PWwuRU9GJiYoKyt0aGlzLl90b2tlbkNvdW50ZXIsdGhpcy5fdG9rZW5Db3VudGVyPnQpKXRocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYERvY3VtZW50IGNvbnRhaW5zIG1vcmUgdGhhdCAke3R9IHRva2Vucy4gUGFyc2luZyBhYm9ydGVkLmApfX1mdW5jdGlvbiBDZShlKXtjb25zdCB0PWUudmFsdWU7cmV0dXJuIFJ0KGUua2luZCkrKHQhPW51bGw/YCAiJHt0fSJgOiIiKX1mdW5jdGlvbiBSdChlKXtyZXR1cm4gd24oZSk/YCIke2V9ImA6ZX1mdW5jdGlvbiBKbihlKXtyZXR1cm5gIiR7ZS5yZXBsYWNlKFFuLFhuKX0iYH1jb25zdCBRbj0vW1x4MDAtXHgxZlx4MjJceDVjXHg3Zi1ceDlmXS9nO2Z1bmN0aW9uIFhuKGUpe3JldHVybiBXbltlLmNoYXJDb2RlQXQoMCldfWNvbnN0IFduPVsiXFx1MDAwMCIsIlxcdTAwMDEiLCJcXHUwMDAyIiwiXFx1MDAwMyIsIlxcdTAwMDQiLCJcXHUwMDA1IiwiXFx1MDAwNiIsIlxcdTAwMDciLCJcXGIiLCJcXHQiLCJcXG4iLCJcXHUwMDBCIiwiXFxmIiwiXFxyIiwiXFx1MDAwRSIsIlxcdTAwMEYiLCJcXHUwMDEwIiwiXFx1MDAxMSIsIlxcdTAwMTIiLCJcXHUwMDEzIiwiXFx1MDAxNCIsIlxcdTAwMTUiLCJcXHUwMDE2IiwiXFx1MDAxNyIsIlxcdTAwMTgiLCJcXHUwMDE5IiwiXFx1MDAxQSIsIlxcdTAwMUIiLCJcXHUwMDFDIiwiXFx1MDAxRCIsIlxcdTAwMUUiLCJcXHUwMDFGIiwiIiwiIiwnXFwiJywiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiXFxcXCIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIlxcdTAwN0YiLCJcXHUwMDgwIiwiXFx1MDA4MSIsIlxcdTAwODIiLCJcXHUwMDgzIiwiXFx1MDA4NCIsIlxcdTAwODUiLCJcXHUwMDg2IiwiXFx1MDA4NyIsIlxcdTAwODgiLCJcXHUwMDg5IiwiXFx1MDA4QSIsIlxcdTAwOEIiLCJcXHUwMDhDIiwiXFx1MDA4RCIsIlxcdTAwOEUiLCJcXHUwMDhGIiwiXFx1MDA5MCIsIlxcdTAwOTEiLCJcXHUwMDkyIiwiXFx1MDA5MyIsIlxcdTAwOTQiLCJcXHUwMDk1IiwiXFx1MDA5NiIsIlxcdTAwOTciLCJcXHUwMDk4IiwiXFx1MDA5OSIsIlxcdTAwOUEiLCJcXHUwMDlCIiwiXFx1MDA5QyIsIlxcdTAwOUQiLCJcXHUwMDlFIiwiXFx1MDA5RiJdLFpuPU9iamVjdC5mcmVlemUoe30pO2Z1bmN0aW9uIEtuKGUsdCxuPU50KXtjb25zdCBpPW5ldyBNYXA7Zm9yKGNvbnN0IEUgb2YgT2JqZWN0LnZhbHVlcyhUKSlpLnNldChFLGVyKHQsRSkpO2xldCByLHM9QXJyYXkuaXNBcnJheShlKSxvPVtlXSxjPS0xLGY9W10sZD1lLHUseTtjb25zdCBnPVtdLGI9W107ZG97YysrO2NvbnN0IEU9Yz09PW8ubGVuZ3RoLGs9RSYmZi5sZW5ndGghPT0wO2lmKEUpe2lmKHU9Yi5sZW5ndGg9PT0wP3ZvaWQgMDpnW2cubGVuZ3RoLTFdLGQ9eSx5PWIucG9wKCksaylpZihzKXtkPWQuc2xpY2UoKTtsZXQgTD0wO2Zvcihjb25zdFskLHFdb2YgZil7Y29uc3QgTT0kLUw7cT09PW51bGw/KGQuc3BsaWNlKE0sMSksTCsrKTpkW01dPXF9fWVsc2V7ZD1PYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhkKSk7Zm9yKGNvbnN0W0wsJF1vZiBmKWRbTF09JH1jPXIuaW5kZXgsbz1yLmtleXMsZj1yLmVkaXRzLHM9ci5pbkFycmF5LHI9ci5wcmV2fWVsc2UgaWYoeSl7aWYodT1zP2M6b1tjXSxkPXlbdV0sZD09bnVsbCljb250aW51ZTtnLnB1c2godSl9bGV0IHc7aWYoIUFycmF5LmlzQXJyYXkoZCkpe3ZhciBtLE47eHQoZCl8fFNlKCExLGBJbnZhbGlkIEFTVCBOb2RlOiAke1plKGQpfS5gKTtjb25zdCBMPUU/KG09aS5nZXQoZC5raW5kKSk9PT1udWxsfHxtPT09dm9pZCAwP3ZvaWQgMDptLmxlYXZlOihOPWkuZ2V0KGQua2luZCkpPT09bnVsbHx8Tj09PXZvaWQgMD92b2lkIDA6Ti5lbnRlcjtpZih3PUw9PW51bGw/dm9pZCAwOkwuY2FsbCh0LGQsdSx5LGcsYiksdz09PVpuKWJyZWFrO2lmKHc9PT0hMSl7aWYoIUUpe2cucG9wKCk7Y29udGludWV9fWVsc2UgaWYodyE9PXZvaWQgMCYmKGYucHVzaChbdSx3XSksIUUpKWlmKHh0KHcpKWQ9dztlbHNle2cucG9wKCk7Y29udGludWV9fWlmKHc9PT12b2lkIDAmJmsmJmYucHVzaChbdSxkXSksRSlnLnBvcCgpO2Vsc2V7dmFyIHY7cj17aW5BcnJheTpzLGluZGV4OmMsa2V5czpvLGVkaXRzOmYscHJldjpyfSxzPUFycmF5LmlzQXJyYXkoZCksbz1zP2Q6KHY9bltkLmtpbmRdKSE9PW51bGwmJnYhPT12b2lkIDA/djpbXSxjPS0xLGY9W10seSYmYi5wdXNoKHkpLHk9ZH19d2hpbGUociE9PXZvaWQgMCk7cmV0dXJuIGYubGVuZ3RoIT09MD9mW2YubGVuZ3RoLTFdWzFdOmV9ZnVuY3Rpb24gZXIoZSx0KXtjb25zdCBuPWVbdF07cmV0dXJuIHR5cGVvZiBuPT0ib2JqZWN0Ij9uOnR5cGVvZiBuPT0iZnVuY3Rpb24iP3tlbnRlcjpuLGxlYXZlOnZvaWQgMH06e2VudGVyOmUuZW50ZXIsbGVhdmU6ZS5sZWF2ZX19ZnVuY3Rpb24gdHIoZSl7cmV0dXJuIEtuKGUscnIpfWNvbnN0IG5yPTgwLHJyPXtOYW1lOntsZWF2ZTplPT5lLnZhbHVlfSxWYXJpYWJsZTp7bGVhdmU6ZT0+IiQiK2UubmFtZX0sRG9jdW1lbnQ6e2xlYXZlOmU9PnAoZS5kZWZpbml0aW9ucyxgCgpgKX0sT3BlcmF0aW9uRGVmaW5pdGlvbjp7bGVhdmUoZSl7Y29uc3QgdD1TKCIoIixwKGUudmFyaWFibGVEZWZpbml0aW9ucywiLCAiKSwiKSIpLG49cChbZS5vcGVyYXRpb24scChbZS5uYW1lLHRdKSxwKGUuZGlyZWN0aXZlcywiICIpXSwiICIpO3JldHVybihuPT09InF1ZXJ5Ij8iIjpuKyIgIikrZS5zZWxlY3Rpb25TZXR9fSxWYXJpYWJsZURlZmluaXRpb246e2xlYXZlOih7dmFyaWFibGU6ZSx0eXBlOnQsZGVmYXVsdFZhbHVlOm4sZGlyZWN0aXZlczppfSk9PmUrIjogIit0K1MoIiA9ICIsbikrUygiICIscChpLCIgIikpfSxTZWxlY3Rpb25TZXQ6e2xlYXZlOih7c2VsZWN0aW9uczplfSk9PksoZSl9LEZpZWxkOntsZWF2ZSh7YWxpYXM6ZSxuYW1lOnQsYXJndW1lbnRzOm4sZGlyZWN0aXZlczppLHNlbGVjdGlvblNldDpyfSl7Y29uc3Qgcz1TKCIiLGUsIjogIikrdDtsZXQgbz1zK1MoIigiLHAobiwiLCAiKSwiKSIpO3JldHVybiBvLmxlbmd0aD5uciYmKG89cytTKGAoCmAsa2UocChuLGAKYCkpLGAKKWApKSxwKFtvLHAoaSwiICIpLHJdLCIgIil9fSxBcmd1bWVudDp7bGVhdmU6KHtuYW1lOmUsdmFsdWU6dH0pPT5lKyI6ICIrdH0sRnJhZ21lbnRTcHJlYWQ6e2xlYXZlOih7bmFtZTplLGRpcmVjdGl2ZXM6dH0pPT4iLi4uIitlK1MoIiAiLHAodCwiICIpKX0sSW5saW5lRnJhZ21lbnQ6e2xlYXZlOih7dHlwZUNvbmRpdGlvbjplLGRpcmVjdGl2ZXM6dCxzZWxlY3Rpb25TZXQ6bn0pPT5wKFsiLi4uIixTKCJvbiAiLGUpLHAodCwiICIpLG5dLCIgIil9LEZyYWdtZW50RGVmaW5pdGlvbjp7bGVhdmU6KHtuYW1lOmUsdHlwZUNvbmRpdGlvbjp0LHZhcmlhYmxlRGVmaW5pdGlvbnM6bixkaXJlY3RpdmVzOmksc2VsZWN0aW9uU2V0OnJ9KT0+YGZyYWdtZW50ICR7ZX0ke1MoIigiLHAobiwiLCAiKSwiKSIpfSBvbiAke3R9ICR7UygiIixwKGksIiAiKSwiICIpfWArcn0sSW50VmFsdWU6e2xlYXZlOih7dmFsdWU6ZX0pPT5lfSxGbG9hdFZhbHVlOntsZWF2ZTooe3ZhbHVlOmV9KT0+ZX0sU3RyaW5nVmFsdWU6e2xlYXZlOih7dmFsdWU6ZSxibG9jazp0fSk9PnQ/T24oZSk6Sm4oZSl9LEJvb2xlYW5WYWx1ZTp7bGVhdmU6KHt2YWx1ZTplfSk9PmU/InRydWUiOiJmYWxzZSJ9LE51bGxWYWx1ZTp7bGVhdmU6KCk9PiJudWxsIn0sRW51bVZhbHVlOntsZWF2ZTooe3ZhbHVlOmV9KT0+ZX0sTGlzdFZhbHVlOntsZWF2ZTooe3ZhbHVlczplfSk9PiJbIitwKGUsIiwgIikrIl0ifSxPYmplY3RWYWx1ZTp7bGVhdmU6KHtmaWVsZHM6ZX0pPT4ieyIrcChlLCIsICIpKyJ9In0sT2JqZWN0RmllbGQ6e2xlYXZlOih7bmFtZTplLHZhbHVlOnR9KT0+ZSsiOiAiK3R9LERpcmVjdGl2ZTp7bGVhdmU6KHtuYW1lOmUsYXJndW1lbnRzOnR9KT0+IkAiK2UrUygiKCIscCh0LCIsICIpLCIpIil9LE5hbWVkVHlwZTp7bGVhdmU6KHtuYW1lOmV9KT0+ZX0sTGlzdFR5cGU6e2xlYXZlOih7dHlwZTplfSk9PiJbIitlKyJdIn0sTm9uTnVsbFR5cGU6e2xlYXZlOih7dHlwZTplfSk9PmUrIiEifSxTY2hlbWFEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsZGlyZWN0aXZlczp0LG9wZXJhdGlvblR5cGVzOm59KT0+UygiIixlLGAKYCkrcChbInNjaGVtYSIscCh0LCIgIiksSyhuKV0sIiAiKX0sT3BlcmF0aW9uVHlwZURlZmluaXRpb246e2xlYXZlOih7b3BlcmF0aW9uOmUsdHlwZTp0fSk9PmUrIjogIit0fSxTY2FsYXJUeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm59KT0+UygiIixlLGAKYCkrcChbInNjYWxhciIsdCxwKG4sIiAiKV0sIiAiKX0sT2JqZWN0VHlwZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsaW50ZXJmYWNlczpuLGRpcmVjdGl2ZXM6aSxmaWVsZHM6cn0pPT5TKCIiLGUsYApgKStwKFsidHlwZSIsdCxTKCJpbXBsZW1lbnRzICIscChuLCIgJiAiKSkscChpLCIgIiksSyhyKV0sIiAiKX0sRmllbGREZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHR5cGU6aSxkaXJlY3RpdmVzOnJ9KT0+UygiIixlLGAKYCkrdCsoTHQobik/UyhgKApgLGtlKHAobixgCmApKSxgCilgKTpTKCIoIixwKG4sIiwgIiksIikiKSkrIjogIitpK1MoIiAiLHAociwiICIpKX0sSW5wdXRWYWx1ZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsdHlwZTpuLGRlZmF1bHRWYWx1ZTppLGRpcmVjdGl2ZXM6cn0pPT5TKCIiLGUsYApgKStwKFt0KyI6ICIrbixTKCI9ICIsaSkscChyLCIgIildLCIgIil9LEludGVyZmFjZVR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGludGVyZmFjZXM6bixkaXJlY3RpdmVzOmksZmllbGRzOnJ9KT0+UygiIixlLGAKYCkrcChbImludGVyZmFjZSIsdCxTKCJpbXBsZW1lbnRzICIscChuLCIgJiAiKSkscChpLCIgIiksSyhyKV0sIiAiKX0sVW5pb25UeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm4sdHlwZXM6aX0pPT5TKCIiLGUsYApgKStwKFsidW5pb24iLHQscChuLCIgIiksUygiPSAiLHAoaSwiIHwgIikpXSwiICIpfSxFbnVtVHlwZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsZGlyZWN0aXZlczpuLHZhbHVlczppfSk9PlMoIiIsZSxgCmApK3AoWyJlbnVtIix0LHAobiwiICIpLEsoaSldLCIgIil9LEVudW1WYWx1ZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsZGlyZWN0aXZlczpufSk9PlMoIiIsZSxgCmApK3AoW3QscChuLCIgIildLCIgIil9LElucHV0T2JqZWN0VHlwZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsZGlyZWN0aXZlczpuLGZpZWxkczppfSk9PlMoIiIsZSxgCmApK3AoWyJpbnB1dCIsdCxwKG4sIiAiKSxLKGkpXSwiICIpfSxEaXJlY3RpdmVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHJlcGVhdGFibGU6aSxsb2NhdGlvbnM6cn0pPT5TKCIiLGUsYApgKSsiZGlyZWN0aXZlIEAiK3QrKEx0KG4pP1MoYCgKYCxrZShwKG4sYApgKSksYAopYCk6UygiKCIscChuLCIsICIpLCIpIikpKyhpPyIgcmVwZWF0YWJsZSI6IiIpKyIgb24gIitwKHIsIiB8ICIpfSxTY2hlbWFFeHRlbnNpb246e2xlYXZlOih7ZGlyZWN0aXZlczplLG9wZXJhdGlvblR5cGVzOnR9KT0+cChbImV4dGVuZCBzY2hlbWEiLHAoZSwiICIpLEsodCldLCIgIil9LFNjYWxhclR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGRpcmVjdGl2ZXM6dH0pPT5wKFsiZXh0ZW5kIHNjYWxhciIsZSxwKHQsIiAiKV0sIiAiKX0sT2JqZWN0VHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsaW50ZXJmYWNlczp0LGRpcmVjdGl2ZXM6bixmaWVsZHM6aX0pPT5wKFsiZXh0ZW5kIHR5cGUiLGUsUygiaW1wbGVtZW50cyAiLHAodCwiICYgIikpLHAobiwiICIpLEsoaSldLCIgIil9LEludGVyZmFjZVR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGludGVyZmFjZXM6dCxkaXJlY3RpdmVzOm4sZmllbGRzOml9KT0+cChbImV4dGVuZCBpbnRlcmZhY2UiLGUsUygiaW1wbGVtZW50cyAiLHAodCwiICYgIikpLHAobiwiICIpLEsoaSldLCIgIil9LFVuaW9uVHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsZGlyZWN0aXZlczp0LHR5cGVzOm59KT0+cChbImV4dGVuZCB1bmlvbiIsZSxwKHQsIiAiKSxTKCI9ICIscChuLCIgfCAiKSldLCIgIil9LEVudW1UeXBlRXh0ZW5zaW9uOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnQsdmFsdWVzOm59KT0+cChbImV4dGVuZCBlbnVtIixlLHAodCwiICIpLEsobildLCIgIil9LElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsZGlyZWN0aXZlczp0LGZpZWxkczpufSk9PnAoWyJleHRlbmQgaW5wdXQiLGUscCh0LCIgIiksSyhuKV0sIiAiKX19O2Z1bmN0aW9uIHAoZSx0PSIiKXt2YXIgbjtyZXR1cm4obj1lPT1udWxsP3ZvaWQgMDplLmZpbHRlcihpPT5pKS5qb2luKHQpKSE9PW51bGwmJm4hPT12b2lkIDA/bjoiIn1mdW5jdGlvbiBLKGUpe3JldHVybiBTKGB7CmAsa2UocChlLGAKYCkpLGAKfWApfWZ1bmN0aW9uIFMoZSx0LG49IiIpe3JldHVybiB0IT1udWxsJiZ0IT09IiI/ZSt0K246IiJ9ZnVuY3Rpb24ga2UoZSl7cmV0dXJuIFMoIiAgIixlLnJlcGxhY2UoL1xuL2csYAogIGApKX1mdW5jdGlvbiBMdChlKXt2YXIgdDtyZXR1cm4odD1lPT1udWxsP3ZvaWQgMDplLnNvbWUobj0+bi5pbmNsdWRlcyhgCmApKSkhPT1udWxsJiZ0IT09dm9pZCAwP3Q6ITF9Y29uc3QgUHQ9ZT0+e3ZhciBpLHI7bGV0IHQ7Y29uc3Qgbj1lLmRlZmluaXRpb25zLmZpbHRlcihzPT5zLmtpbmQ9PT0iT3BlcmF0aW9uRGVmaW5pdGlvbiIpO3JldHVybiBuLmxlbmd0aD09PTEmJih0PShyPShpPW5bMF0pPT1udWxsP3ZvaWQgMDppLm5hbWUpPT1udWxsP3ZvaWQgMDpyLnZhbHVlKSx0fSxLZT1lPT57aWYodHlwZW9mIGU9PSJzdHJpbmciKXtsZXQgbjt0cnl7Y29uc3QgaT1rdChlKTtuPVB0KGkpfWNhdGNoKGkpe31yZXR1cm57cXVlcnk6ZSxvcGVyYXRpb25OYW1lOm59fWNvbnN0IHQ9UHQoZSk7cmV0dXJue3F1ZXJ5OnRyKGUpLG9wZXJhdGlvbk5hbWU6dH19O2NsYXNzIGhlIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCxuKXtjb25zdCBpPWAke2hlLmV4dHJhY3RNZXNzYWdlKHQpfTogJHtKU09OLnN0cmluZ2lmeSh7cmVzcG9uc2U6dCxyZXF1ZXN0Om59KX1gO3N1cGVyKGkpLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLGhlLnByb3RvdHlwZSksdGhpcy5yZXNwb25zZT10LHRoaXMucmVxdWVzdD1uLHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT09ImZ1bmN0aW9uIiYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxoZSl9c3RhdGljIGV4dHJhY3RNZXNzYWdlKHQpe3ZhciBuLGkscjtyZXR1cm4ocj0oaT0obj10LmVycm9ycyk9PW51bGw/dm9pZCAwOm5bMF0pPT1udWxsP3ZvaWQgMDppLm1lc3NhZ2UpIT1udWxsP3I6YEdyYXBoUUwgRXJyb3IgKENvZGU6ICR7dC5zdGF0dXN9KWB9fXZhciBpcj10eXBlb2YgZ2xvYmFsVGhpcyE9InVuZGVmaW5lZCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT0idW5kZWZpbmVkIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9InVuZGVmaW5lZCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT0idW5kZWZpbmVkIj9zZWxmOnt9O2Z1bmN0aW9uIEZ0KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCJkZWZhdWx0Iik/ZS5kZWZhdWx0OmV9dmFyIGV0PXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2Ygc2VsZiE9InVuZGVmaW5lZCI/c2VsZjppcixpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcygpe3RoaXMuZmV0Y2g9ITEsdGhpcy5ET01FeGNlcHRpb249bi5ET01FeGNlcHRpb259cmV0dXJuIHMucHJvdG90eXBlPW4sbmV3IHN9KCk7KGZ1bmN0aW9uKHMpeyhmdW5jdGlvbihvKXt2YXIgYz17c2VhcmNoUGFyYW1zOiJVUkxTZWFyY2hQYXJhbXMiaW4gcyxpdGVyYWJsZToiU3ltYm9sImluIHMmJiJpdGVyYXRvciJpbiBTeW1ib2wsYmxvYjoiRmlsZVJlYWRlciJpbiBzJiYiQmxvYiJpbiBzJiZmdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEJsb2IsITB9Y2F0Y2goYSl7cmV0dXJuITF9fSgpLGZvcm1EYXRhOiJGb3JtRGF0YSJpbiBzLGFycmF5QnVmZmVyOiJBcnJheUJ1ZmZlciJpbiBzfTtmdW5jdGlvbiBmKGEpe3JldHVybiBhJiZEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKX1pZihjLmFycmF5QnVmZmVyKXZhciBkPVsiW29iamVjdCBJbnQ4QXJyYXldIiwiW29iamVjdCBVaW50OEFycmF5XSIsIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIiwiW29iamVjdCBJbnQxNkFycmF5XSIsIltvYmplY3QgVWludDE2QXJyYXldIiwiW29iamVjdCBJbnQzMkFycmF5XSIsIltvYmplY3QgVWludDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDY0QXJyYXldIl0sdT1BcnJheUJ1ZmZlci5pc1ZpZXd8fGZ1bmN0aW9uKGEpe3JldHVybiBhJiZkLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpKT4tMX07ZnVuY3Rpb24geShhKXtpZih0eXBlb2YgYSE9InN0cmluZyImJihhPVN0cmluZyhhKSksL1teYS16MC05XC0jJCUmJyorLl5fYHx+XS9pLnRlc3QoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUiKTtyZXR1cm4gYS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIHR5cGVvZiBhIT0ic3RyaW5nIiYmKGE9U3RyaW5nKGEpKSxhfWZ1bmN0aW9uIGIoYSl7dmFyIGg9e25leHQ6ZnVuY3Rpb24oKXt2YXIgXz1hLnNoaWZ0KCk7cmV0dXJue2RvbmU6Xz09PXZvaWQgMCx2YWx1ZTpffX19O3JldHVybiBjLml0ZXJhYmxlJiYoaFtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGh9KSxofWZ1bmN0aW9uIG0oYSl7dGhpcy5tYXA9e30sYSBpbnN0YW5jZW9mIG0/YS5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7dGhpcy5hcHBlbmQoXyxoKX0sdGhpcyk6QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goZnVuY3Rpb24oaCl7dGhpcy5hcHBlbmQoaFswXSxoWzFdKX0sdGhpcyk6YSYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSkuZm9yRWFjaChmdW5jdGlvbihoKXt0aGlzLmFwcGVuZChoLGFbaF0pfSx0aGlzKX1tLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oYSxoKXthPXkoYSksaD1nKGgpO3ZhciBfPXRoaXMubWFwW2FdO3RoaXMubWFwW2FdPV8/XysiLCAiK2g6aH0sbS5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLm1hcFt5KGEpXX0sbS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBhPXkoYSksdGhpcy5oYXMoYSk/dGhpcy5tYXBbYV06bnVsbH0sbS5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eSh5KGEpKX0sbS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsaCl7dGhpcy5tYXBbeShhKV09ZyhoKX0sbS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihhLGgpe2Zvcih2YXIgXyBpbiB0aGlzLm1hcCl0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShfKSYmYS5jYWxsKGgsdGhpcy5tYXBbX10sXyx0aGlzKX0sbS5wcm90b3R5cGUua2V5cz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oaCxfKXthLnB1c2goXyl9KSxiKGEpfSxtLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgpe2EucHVzaChoKX0pLGIoYSl9LG0ucHJvdG90eXBlLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7YS5wdXNoKFtfLGhdKX0pLGIoYSl9LGMuaXRlcmFibGUmJihtLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdPW0ucHJvdG90eXBlLmVudHJpZXMpO2Z1bmN0aW9uIE4oYSl7aWYoYS5ib2R5VXNlZClyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIikpO2EuYm9keVVzZWQ9ITB9ZnVuY3Rpb24gdihhKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaCxfKXthLm9ubG9hZD1mdW5jdGlvbigpe2goYS5yZXN1bHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oKXtfKGEuZXJyb3IpfX0pfWZ1bmN0aW9uIEUoYSl7dmFyIGg9bmV3IEZpbGVSZWFkZXIsXz12KGgpO3JldHVybiBoLnJlYWRBc0FycmF5QnVmZmVyKGEpLF99ZnVuY3Rpb24gayhhKXt2YXIgaD1uZXcgRmlsZVJlYWRlcixfPXYoaCk7cmV0dXJuIGgucmVhZEFzVGV4dChhKSxffWZ1bmN0aW9uIHcoYSl7Zm9yKHZhciBoPW5ldyBVaW50OEFycmF5KGEpLF89bmV3IEFycmF5KGgubGVuZ3RoKSxBPTA7QTxoLmxlbmd0aDtBKyspX1tBXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGhbQV0pO3JldHVybiBfLmpvaW4oIiIpfWZ1bmN0aW9uIEwoYSl7aWYoYS5zbGljZSlyZXR1cm4gYS5zbGljZSgwKTt2YXIgaD1uZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO3JldHVybiBoLnNldChuZXcgVWludDhBcnJheShhKSksaC5idWZmZXJ9ZnVuY3Rpb24gJCgpe3JldHVybiB0aGlzLmJvZHlVc2VkPSExLHRoaXMuX2luaXRCb2R5PWZ1bmN0aW9uKGEpe3RoaXMuX2JvZHlJbml0PWEsYT90eXBlb2YgYT09InN0cmluZyI/dGhpcy5fYm9keVRleHQ9YTpjLmJsb2ImJkJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYSk/dGhpcy5fYm9keUJsb2I9YTpjLmZvcm1EYXRhJiZGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKT90aGlzLl9ib2R5Rm9ybURhdGE9YTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpP3RoaXMuX2JvZHlUZXh0PWEudG9TdHJpbmcoKTpjLmFycmF5QnVmZmVyJiZjLmJsb2ImJmYoYSk/KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcj1MKGEuYnVmZmVyKSx0aGlzLl9ib2R5SW5pdD1uZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpOmMuYXJyYXlCdWZmZXImJihBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKXx8dShhKSk/dGhpcy5fYm9keUFycmF5QnVmZmVyPUwoYSk6dGhpcy5fYm9keVRleHQ9YT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk6dGhpcy5fYm9keVRleHQ9IiIsdGhpcy5oZWFkZXJzLmdldCgiY29udGVudC10eXBlIil8fCh0eXBlb2YgYT09InN0cmluZyI/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Iik6dGhpcy5fYm9keUJsb2ImJnRoaXMuX2JvZHlCbG9iLnR5cGU/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIix0aGlzLl9ib2R5QmxvYi50eXBlKTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpJiZ0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCIpKX0sYy5ibG9iJiYodGhpcy5ibG9iPWZ1bmN0aW9uKCl7dmFyIGE9Tih0aGlzKTtpZihhKXJldHVybiBhO2lmKHRoaXMuX2JvZHlCbG9iKXJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iIik7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSl9LHRoaXMuYXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keUFycmF5QnVmZmVyP04odGhpcyl8fFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpOnRoaXMuYmxvYigpLnRoZW4oRSl9KSx0aGlzLnRleHQ9ZnVuY3Rpb24oKXt2YXIgYT1OKHRoaXMpO2lmKGEpcmV0dXJuIGE7aWYodGhpcy5fYm9keUJsb2IpcmV0dXJuIGsodGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHcodGhpcy5fYm9keUFycmF5QnVmZmVyKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0Iik7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dCl9LGMuZm9ybURhdGEmJih0aGlzLmZvcm1EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oTyl9KSx0aGlzLmpzb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKX0sdGhpc312YXIgcT1bIkRFTEVURSIsIkdFVCIsIkhFQUQiLCJPUFRJT05TIiwiUE9TVCIsIlBVVCJdO2Z1bmN0aW9uIE0oYSl7dmFyIGg9YS50b1VwcGVyQ2FzZSgpO3JldHVybiBxLmluZGV4T2YoaCk+LTE/aDphfWZ1bmN0aW9uIEkoYSxoKXtoPWh8fHt9O3ZhciBfPWguYm9keTtpZihhIGluc3RhbmNlb2YgSSl7aWYoYS5ib2R5VXNlZCl0aHJvdyBuZXcgVHlwZUVycm9yKCJBbHJlYWR5IHJlYWQiKTt0aGlzLnVybD1hLnVybCx0aGlzLmNyZWRlbnRpYWxzPWEuY3JlZGVudGlhbHMsaC5oZWFkZXJzfHwodGhpcy5oZWFkZXJzPW5ldyBtKGEuaGVhZGVycykpLHRoaXMubWV0aG9kPWEubWV0aG9kLHRoaXMubW9kZT1hLm1vZGUsdGhpcy5zaWduYWw9YS5zaWduYWwsIV8mJmEuX2JvZHlJbml0IT1udWxsJiYoXz1hLl9ib2R5SW5pdCxhLmJvZHlVc2VkPSEwKX1lbHNlIHRoaXMudXJsPVN0cmluZyhhKTtpZih0aGlzLmNyZWRlbnRpYWxzPWguY3JlZGVudGlhbHN8fHRoaXMuY3JlZGVudGlhbHN8fCJzYW1lLW9yaWdpbiIsKGguaGVhZGVyc3x8IXRoaXMuaGVhZGVycykmJih0aGlzLmhlYWRlcnM9bmV3IG0oaC5oZWFkZXJzKSksdGhpcy5tZXRob2Q9TShoLm1ldGhvZHx8dGhpcy5tZXRob2R8fCJHRVQiKSx0aGlzLm1vZGU9aC5tb2RlfHx0aGlzLm1vZGV8fG51bGwsdGhpcy5zaWduYWw9aC5zaWduYWx8fHRoaXMuc2lnbmFsLHRoaXMucmVmZXJyZXI9bnVsbCwodGhpcy5tZXRob2Q9PT0iR0VUInx8dGhpcy5tZXRob2Q9PT0iSEVBRCIpJiZfKXRocm93IG5ldyBUeXBlRXJyb3IoIkJvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzIik7dGhpcy5faW5pdEJvZHkoXyl9SS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEkodGhpcyx7Ym9keTp0aGlzLl9ib2R5SW5pdH0pfTtmdW5jdGlvbiBPKGEpe3ZhciBoPW5ldyBGb3JtRGF0YTtyZXR1cm4gYS50cmltKCkuc3BsaXQoIiYiKS5mb3JFYWNoKGZ1bmN0aW9uKF8pe2lmKF8pe3ZhciBBPV8uc3BsaXQoIj0iKSxSPUEuc2hpZnQoKS5yZXBsYWNlKC9cKy9nLCIgIikseD1BLmpvaW4oIj0iKS5yZXBsYWNlKC9cKy9nLCIgIik7aC5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KFIpLGRlY29kZVVSSUNvbXBvbmVudCh4KSl9fSksaH1mdW5jdGlvbiBqKGEpe3ZhciBoPW5ldyBtLF89YS5yZXBsYWNlKC9ccj9cbltcdCBdKy9nLCIgIik7cmV0dXJuIF8uc3BsaXQoL1xyP1xuLykuZm9yRWFjaChmdW5jdGlvbihBKXt2YXIgUj1BLnNwbGl0KCI6IikseD1SLnNoaWZ0KCkudHJpbSgpO2lmKHgpe3ZhciBzZT1SLmpvaW4oIjoiKS50cmltKCk7aC5hcHBlbmQoeCxzZSl9fSksaH0kLmNhbGwoSS5wcm90b3R5cGUpO2Z1bmN0aW9uIFUoYSxoKXtofHwoaD17fSksdGhpcy50eXBlPSJkZWZhdWx0Iix0aGlzLnN0YXR1cz1oLnN0YXR1cz09PXZvaWQgMD8yMDA6aC5zdGF0dXMsdGhpcy5vaz10aGlzLnN0YXR1cz49MjAwJiZ0aGlzLnN0YXR1czwzMDAsdGhpcy5zdGF0dXNUZXh0PSJzdGF0dXNUZXh0ImluIGg/aC5zdGF0dXNUZXh0OiJPSyIsdGhpcy5oZWFkZXJzPW5ldyBtKGguaGVhZGVycyksdGhpcy51cmw9aC51cmx8fCIiLHRoaXMuX2luaXRCb2R5KGEpfSQuY2FsbChVLnByb3RvdHlwZSksVS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFUodGhpcy5fYm9keUluaXQse3N0YXR1czp0aGlzLnN0YXR1cyxzdGF0dXNUZXh0OnRoaXMuc3RhdHVzVGV4dCxoZWFkZXJzOm5ldyBtKHRoaXMuaGVhZGVycyksdXJsOnRoaXMudXJsfSl9LFUuZXJyb3I9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVShudWxsLHtzdGF0dXM6MCxzdGF0dXNUZXh0OiIifSk7cmV0dXJuIGEudHlwZT0iZXJyb3IiLGF9O3ZhciBIPVszMDEsMzAyLDMwMywzMDcsMzA4XTtVLnJlZGlyZWN0PWZ1bmN0aW9uKGEsaCl7aWYoSC5pbmRleE9mKGgpPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgc3RhdHVzIGNvZGUiKTtyZXR1cm4gbmV3IFUobnVsbCx7c3RhdHVzOmgsaGVhZGVyczp7bG9jYXRpb246YX19KX0sby5ET01FeGNlcHRpb249cy5ET01FeGNlcHRpb247dHJ5e25ldyBvLkRPTUV4Y2VwdGlvbn1jYXRjaChhKXtvLkRPTUV4Y2VwdGlvbj1mdW5jdGlvbihoLF8pe3RoaXMubWVzc2FnZT1oLHRoaXMubmFtZT1fO3ZhciBBPUVycm9yKGgpO3RoaXMuc3RhY2s9QS5zdGFja30sby5ET01FeGNlcHRpb24ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxvLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I9by5ET01FeGNlcHRpb259ZnVuY3Rpb24gUShhLGgpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihfLEEpe3ZhciBSPW5ldyBJKGEsaCk7aWYoUi5zaWduYWwmJlIuc2lnbmFsLmFib3J0ZWQpcmV0dXJuIEEobmV3IG8uRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwiQWJvcnRFcnJvciIpKTt2YXIgeD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZnVuY3Rpb24gc2UoKXt4LmFib3J0KCl9eC5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgej17c3RhdHVzOnguc3RhdHVzLHN0YXR1c1RleHQ6eC5zdGF0dXNUZXh0LGhlYWRlcnM6aih4LmdldEFsbFJlc3BvbnNlSGVhZGVycygpfHwiIil9O3oudXJsPSJyZXNwb25zZVVSTCJpbiB4P3gucmVzcG9uc2VVUkw6ei5oZWFkZXJzLmdldCgiWC1SZXF1ZXN0LVVSTCIpO3ZhciByZT0icmVzcG9uc2UiaW4geD94LnJlc3BvbnNlOngucmVzcG9uc2VUZXh0O18obmV3IFUocmUseikpfSx4Lm9uZXJyb3I9ZnVuY3Rpb24oKXtBKG5ldyBUeXBlRXJyb3IoIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQiKSl9LHgub250aW1lb3V0PWZ1bmN0aW9uKCl7QShuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpfSx4Lm9uYWJvcnQ9ZnVuY3Rpb24oKXtBKG5ldyBvLkRPTUV4Y2VwdGlvbigiQWJvcnRlZCIsIkFib3J0RXJyb3IiKSl9LHgub3BlbihSLm1ldGhvZCxSLnVybCwhMCksUi5jcmVkZW50aWFscz09PSJpbmNsdWRlIj94LndpdGhDcmVkZW50aWFscz0hMDpSLmNyZWRlbnRpYWxzPT09Im9taXQiJiYoeC53aXRoQ3JlZGVudGlhbHM9ITEpLCJyZXNwb25zZVR5cGUiaW4geCYmYy5ibG9iJiYoeC5yZXNwb25zZVR5cGU9ImJsb2IiKSxSLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih6LHJlKXt4LnNldFJlcXVlc3RIZWFkZXIocmUseil9KSxSLnNpZ25hbCYmKFIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IixzZSkseC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt4LnJlYWR5U3RhdGU9PT00JiZSLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCJhYm9ydCIsc2UpfSkseC5zZW5kKHR5cGVvZiBSLl9ib2R5SW5pdD09InVuZGVmaW5lZCI/bnVsbDpSLl9ib2R5SW5pdCl9KX1yZXR1cm4gUS5wb2x5ZmlsbD0hMCxzLmZldGNofHwocy5mZXRjaD1RLHMuSGVhZGVycz1tLHMuUmVxdWVzdD1JLHMuUmVzcG9uc2U9VSksby5IZWFkZXJzPW0sby5SZXF1ZXN0PUksby5SZXNwb25zZT1VLG8uZmV0Y2g9USxPYmplY3QuZGVmaW5lUHJvcGVydHkobywiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksb30pKHt9KX0pKGkpLGkuZmV0Y2gucG9ueWZpbGw9ITAsZGVsZXRlIGkuZmV0Y2gucG9seWZpbGw7dmFyIHI9aTt0PXIuZmV0Y2gsdC5kZWZhdWx0PXIuZmV0Y2gsdC5mZXRjaD1yLmZldGNoLHQuSGVhZGVycz1yLkhlYWRlcnMsdC5SZXF1ZXN0PXIuUmVxdWVzdCx0LlJlc3BvbnNlPXIuUmVzcG9uc2UsZS5leHBvcnRzPXR9KShldCxldC5leHBvcnRzKTt2YXIgUmU9ZXQuZXhwb3J0cyxMZT1GdChSZSksc3I9Qih7X19wcm90b19fOm51bGwsZGVmYXVsdDpMZX0sW1JlXSk7Y29uc3QgZGU9ZT0+e2xldCB0PXt9O3JldHVybiBlJiYodHlwZW9mIEhlYWRlcnMhPSJ1bmRlZmluZWQiJiZlIGluc3RhbmNlb2YgSGVhZGVyc3x8c3ImJlJlLkhlYWRlcnMmJmUgaW5zdGFuY2VvZiBSZS5IZWFkZXJzP3Q9ZG4oZSk6QXJyYXkuaXNBcnJheShlKT9lLmZvckVhY2goKFtuLGldKT0+e24mJmkhPT12b2lkIDAmJih0W25dPWkpfSk6dD1lKSx0fSxCdD1lPT5lLnJlcGxhY2UoLyhbXHMsXXwjW15cblxyXSspKy9nLCIgIikudHJpbSgpLG9yPWU9PntpZighQXJyYXkuaXNBcnJheShlLnF1ZXJ5KSl7Y29uc3QgaT1lLHI9W2BxdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChCdChpLnF1ZXJ5KSl9YF07cmV0dXJuIGUudmFyaWFibGVzJiZyLnB1c2goYHZhcmlhYmxlcz0ke2VuY29kZVVSSUNvbXBvbmVudChpLmpzb25TZXJpYWxpemVyLnN0cmluZ2lmeShpLnZhcmlhYmxlcykpfWApLGkub3BlcmF0aW9uTmFtZSYmci5wdXNoKGBvcGVyYXRpb25OYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGkub3BlcmF0aW9uTmFtZSl9YCksci5qb2luKCImIil9aWYodHlwZW9mIGUudmFyaWFibGVzIT0idW5kZWZpbmVkIiYmIUFycmF5LmlzQXJyYXkoZS52YXJpYWJsZXMpKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IGNyZWF0ZSBxdWVyeSB3aXRoIGdpdmVuIHZhcmlhYmxlIHR5cGUsIGFycmF5IGV4cGVjdGVkIik7Y29uc3QgdD1lLG49ZS5xdWVyeS5yZWR1Y2UoKGkscixzKT0+KGkucHVzaCh7cXVlcnk6QnQociksdmFyaWFibGVzOnQudmFyaWFibGVzP3QuanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KHQudmFyaWFibGVzW3NdKTp2b2lkIDB9KSxpKSxbXSk7cmV0dXJuYHF1ZXJ5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHQuanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KG4pKX1gfSxhcj1lPT50PT5YKHRoaXMsbnVsbCxmdW5jdGlvbiooKXt2YXIgTjtjb25zdHt1cmw6bixxdWVyeTppLHZhcmlhYmxlczpyLG9wZXJhdGlvbk5hbWU6cyxmZXRjaDpvLGZldGNoT3B0aW9uczpjLG1pZGRsZXdhcmU6Zn09dCxkPVAoe30sdC5oZWFkZXJzKTtsZXQgdT0iIix5O2U9PT0iUE9TVCI/KHk9dXIoaSxyLHMsYy5qc29uU2VyaWFsaXplciksdHlwZW9mIHk9PSJzdHJpbmciJiYoZFsiQ29udGVudC1UeXBlIl09ImFwcGxpY2F0aW9uL2pzb24iKSk6dT1vcih7cXVlcnk6aSx2YXJpYWJsZXM6cixvcGVyYXRpb25OYW1lOnMsanNvblNlcmlhbGl6ZXI6KE49Yy5qc29uU2VyaWFsaXplcikhPW51bGw/Tjp6ZX0pO2NvbnN0IGc9UCh7bWV0aG9kOmUsaGVhZGVyczpkLGJvZHk6eX0sYyk7bGV0IGI9bixtPWc7aWYoZil7Y29uc3Qgdj15aWVsZCBQcm9taXNlLnJlc29sdmUoZihVZShQKHt9LGcpLHt1cmw6bixvcGVyYXRpb25OYW1lOnMsdmFyaWFibGVzOnJ9KSkpLHt1cmw6a309dix3PXZlKHYsWyJ1cmwiXSk7Yj1rLG09d31yZXR1cm4gdSYmKGI9YCR7Yn0/JHt1fWApLHlpZWxkIG8oYixtKX0pO2NsYXNzIGNye2NvbnN0cnVjdG9yKHQsbj17fSl7dGhpcy51cmw9dCx0aGlzLnJlcXVlc3RDb25maWc9bix0aGlzLnJhd1JlcXVlc3Q9KC4uLmkpPT5YKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdFtyLHMsb109aSxjPW1uKHIscyxvKSx2PXRoaXMucmVxdWVzdENvbmZpZyx7aGVhZGVyczpmLGZldGNoOmQ9TGUsbWV0aG9kOnU9IlBPU1QiLHJlcXVlc3RNaWRkbGV3YXJlOnkscmVzcG9uc2VNaWRkbGV3YXJlOmd9PXYsYj12ZSh2LFsiaGVhZGVycyIsImZldGNoIiwibWV0aG9kIiwicmVxdWVzdE1pZGRsZXdhcmUiLCJyZXNwb25zZU1pZGRsZXdhcmUiXSkse3VybDptfT10aGlzO2Muc2lnbmFsIT09dm9pZCAwJiYoYi5zaWduYWw9Yy5zaWduYWwpO2NvbnN0e29wZXJhdGlvbk5hbWU6Tn09S2UoYy5xdWVyeSk7cmV0dXJuIHR0KHt1cmw6bSxxdWVyeTpjLnF1ZXJ5LHZhcmlhYmxlczpjLnZhcmlhYmxlcyxoZWFkZXJzOlAoUCh7fSxkZShudChmKSkpLGRlKGMucmVxdWVzdEhlYWRlcnMpKSxvcGVyYXRpb25OYW1lOk4sZmV0Y2g6ZCxtZXRob2Q6dSxmZXRjaE9wdGlvbnM6YixtaWRkbGV3YXJlOnl9KS50aGVuKEU9PihnJiZnKEUpLEUpKS5jYXRjaChFPT57dGhyb3cgZyYmZyhFKSxFfSl9KX1yZXF1ZXN0KHQsLi4ubil7cmV0dXJuIFgodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0W2kscl09bixzPXBuKHQsaSxyKSxOPXRoaXMucmVxdWVzdENvbmZpZyx7aGVhZGVyczpvLGZldGNoOmM9TGUsbWV0aG9kOmY9IlBPU1QiLHJlcXVlc3RNaWRkbGV3YXJlOmQscmVzcG9uc2VNaWRkbGV3YXJlOnV9PU4seT12ZShOLFsiaGVhZGVycyIsImZldGNoIiwibWV0aG9kIiwicmVxdWVzdE1pZGRsZXdhcmUiLCJyZXNwb25zZU1pZGRsZXdhcmUiXSkse3VybDpnfT10aGlzO3Muc2lnbmFsIT09dm9pZCAwJiYoeS5zaWduYWw9cy5zaWduYWwpO2NvbnN0e3F1ZXJ5OmIsb3BlcmF0aW9uTmFtZTptfT1LZShzLmRvY3VtZW50KTtyZXR1cm4gdHQoe3VybDpnLHF1ZXJ5OmIsdmFyaWFibGVzOnMudmFyaWFibGVzLGhlYWRlcnM6UChQKHt9LGRlKG50KG8pKSksZGUocy5yZXF1ZXN0SGVhZGVycykpLG9wZXJhdGlvbk5hbWU6bSxmZXRjaDpjLG1ldGhvZDpmLGZldGNoT3B0aW9uczp5LG1pZGRsZXdhcmU6ZH0pLnRoZW4odj0+KHUmJnUodiksdi5kYXRhKSkuY2F0Y2godj0+e3Rocm93IHUmJnUodiksdn0pfSl9YmF0Y2hSZXF1ZXN0cyh0LG4pe3ZhciBkO2NvbnN0IGk9eW4odCxuKSxmPXRoaXMucmVxdWVzdENvbmZpZyx7aGVhZGVyczpyfT1mLHM9dmUoZixbImhlYWRlcnMiXSk7aS5zaWduYWwhPT12b2lkIDAmJihzLnNpZ25hbD1pLnNpZ25hbCk7Y29uc3Qgbz1pLmRvY3VtZW50cy5tYXAoKHtkb2N1bWVudDp1fSk9PktlKHUpLnF1ZXJ5KSxjPWkuZG9jdW1lbnRzLm1hcCgoe3ZhcmlhYmxlczp1fSk9PnUpO3JldHVybiB0dCh7dXJsOnRoaXMudXJsLHF1ZXJ5Om8sdmFyaWFibGVzOmMsaGVhZGVyczpQKFAoe30sZGUobnQocikpKSxkZShpLnJlcXVlc3RIZWFkZXJzKSksb3BlcmF0aW9uTmFtZTp2b2lkIDAsZmV0Y2g6KGQ9dGhpcy5yZXF1ZXN0Q29uZmlnLmZldGNoKSE9bnVsbD9kOkxlLG1ldGhvZDp0aGlzLnJlcXVlc3RDb25maWcubWV0aG9kfHwiUE9TVCIsZmV0Y2hPcHRpb25zOnMsbWlkZGxld2FyZTp0aGlzLnJlcXVlc3RDb25maWcucmVxdWVzdE1pZGRsZXdhcmV9KS50aGVuKHU9Pih0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlJiZ0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlKHUpLHUuZGF0YSkpLmNhdGNoKHU9Pnt0aHJvdyB0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlJiZ0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlKHUpLHV9KX1zZXRIZWFkZXJzKHQpe3JldHVybiB0aGlzLnJlcXVlc3RDb25maWcuaGVhZGVycz10LHRoaXN9c2V0SGVhZGVyKHQsbil7Y29uc3R7aGVhZGVyczppfT10aGlzLnJlcXVlc3RDb25maWc7cmV0dXJuIGk/aVt0XT1uOnRoaXMucmVxdWVzdENvbmZpZy5oZWFkZXJzPXtbdF06bn0sdGhpc31zZXRFbmRwb2ludCh0KXtyZXR1cm4gdGhpcy51cmw9dCx0aGlzfX1jb25zdCB0dD1lPT5YKHRoaXMsbnVsbCxmdW5jdGlvbiooKXt2YXIgdSx5O2NvbnN0e3F1ZXJ5OnQsdmFyaWFibGVzOm4sZmV0Y2hPcHRpb25zOml9PWUscj1hcihobigodT1lLm1ldGhvZCkhPW51bGw/dToicG9zdCIpKSxzPUFycmF5LmlzQXJyYXkoZS5xdWVyeSksbz15aWVsZCByKGUpLGM9eWllbGQgbHIobywoeT1pLmpzb25TZXJpYWxpemVyKSE9bnVsbD95OnplKSxmPUFycmF5LmlzQXJyYXkoYyk/IWMuc29tZSgoe2RhdGE6Yn0pPT4hYik6ISFjLmRhdGEsZD1BcnJheS5pc0FycmF5KGMpfHwhYy5lcnJvcnN8fEFycmF5LmlzQXJyYXkoYy5lcnJvcnMpJiYhYy5lcnJvcnMubGVuZ3RofHxpLmVycm9yUG9saWN5PT09ImFsbCJ8fGkuZXJyb3JQb2xpY3k9PT0iaWdub3JlIjtpZihvLm9rJiZkJiZmKXtjb25zdCBnPShBcnJheS5pc0FycmF5KGMpLGMpLHtlcnJvcnM6Yn09ZyxtPXZlKGcsWyJlcnJvcnMiXSksTj1pLmVycm9yUG9saWN5PT09Imlnbm9yZSI/bTpjO3JldHVybiBVZShQKHt9LHM/e2RhdGE6Tn06Tikse2hlYWRlcnM6by5oZWFkZXJzLHN0YXR1czpvLnN0YXR1c30pfWVsc2V7Y29uc3QgYj10eXBlb2YgYz09InN0cmluZyI/e2Vycm9yOmN9OmM7dGhyb3cgbmV3IGhlKFVlKFAoe30sYikse3N0YXR1czpvLnN0YXR1cyxoZWFkZXJzOm8uaGVhZGVyc30pLHtxdWVyeTp0LHZhcmlhYmxlczpufSl9fSksdXI9KGUsdCxuLGkpPT57Y29uc3Qgcj1pIT1udWxsP2k6emU7aWYoIUFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIHIuc3RyaW5naWZ5KHtxdWVyeTplLHZhcmlhYmxlczp0LG9wZXJhdGlvbk5hbWU6bn0pO2lmKHR5cGVvZiB0IT0idW5kZWZpbmVkIiYmIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgY3JlYXRlIHJlcXVlc3QgYm9keSB3aXRoIGdpdmVuIHZhcmlhYmxlIHR5cGUsIGFycmF5IGV4cGVjdGVkIik7Y29uc3Qgcz1lLnJlZHVjZSgobyxjLGYpPT4oby5wdXNoKHtxdWVyeTpjLHZhcmlhYmxlczp0P3RbZl06dm9pZCAwfSksbyksW10pO3JldHVybiByLnN0cmluZ2lmeShzKX0sbHI9KGUsdCk9PlgodGhpcyxudWxsLGZ1bmN0aW9uKigpe2xldCBuO3JldHVybiBlLmhlYWRlcnMuZm9yRWFjaCgoaSxyKT0+e3IudG9Mb3dlckNhc2UoKT09PSJjb250ZW50LXR5cGUiJiYobj1pKX0pLG4mJihuLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgiYXBwbGljYXRpb24vanNvbiIpfHxuLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgiYXBwbGljYXRpb24vZ3JhcGhxbCtqc29uIil8fG4udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCJhcHBsaWNhdGlvbi9ncmFwaHFsLXJlc3BvbnNlK2pzb24iKSk/dC5wYXJzZSh5aWVsZCBlLnRleHQoKSk6ZS50ZXh0KCl9KSxudD1lPT50eXBlb2YgZT09ImZ1bmN0aW9uIj9lKCk6ZTt2YXIgcnQ9e2V4cG9ydHM6e319OyhmdW5jdGlvbihlLHQpe3Q9ZS5leHBvcnRzPW4sdC5nZXRTZXJpYWxpemU9aTtmdW5jdGlvbiBuKHIscyxvLGMpe3JldHVybiBKU09OLnN0cmluZ2lmeShyLGkocyxjKSxvKX1mdW5jdGlvbiBpKHIscyl7dmFyIG89W10sYz1bXTtyZXR1cm4gcz09bnVsbCYmKHM9ZnVuY3Rpb24oZixkKXtyZXR1cm4gb1swXT09PWQ/IltDaXJjdWxhciB+XSI6IltDaXJjdWxhciB+LiIrYy5zbGljZSgwLG8uaW5kZXhPZihkKSkuam9pbigiLiIpKyJdIn0pLGZ1bmN0aW9uKGYsZCl7aWYoby5sZW5ndGg+MCl7dmFyIHU9by5pbmRleE9mKHRoaXMpO351P28uc3BsaWNlKHUrMSk6by5wdXNoKHRoaXMpLH51P2Muc3BsaWNlKHUsMS8wLGYpOmMucHVzaChmKSx+by5pbmRleE9mKGQpJiYoZD1zLmNhbGwodGhpcyxmLGQpKX1lbHNlIG8ucHVzaChkKTtyZXR1cm4gcj09bnVsbD9kOnIuY2FsbCh0aGlzLGYsZCl9fX0pKHJ0LHJ0LmV4cG9ydHMpO3ZhciBmcj1ydC5leHBvcnRzLHBlPUZ0KGZyKTtjb25zdCAkdD0xZTMqMTU7dmFyIFBlPWZ1bmN0aW9uKCl7cmV0dXJuIFBlPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgbixpPTEscj1hcmd1bWVudHMubGVuZ3RoO2k8cjtpKyspe249YXJndW1lbnRzW2ldO2Zvcih2YXIgcyBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHMpJiYodFtzXT1uW3NdKX1yZXR1cm4gdH0sUGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0eXBlb2YgU3VwcHJlc3NlZEVycm9yPT0iZnVuY3Rpb24iJiZTdXBwcmVzc2VkRXJyb3I7dmFyIEZlPW5ldyBNYXAsaXQ9bmV3IE1hcCxNdD0hMCxCZT0hMTtmdW5jdGlvbiBVdChlKXtyZXR1cm4gZS5yZXBsYWNlKC9bXHMsXSsvZywiICIpLnRyaW0oKX1mdW5jdGlvbiBocihlKXtyZXR1cm4gVXQoZS5zb3VyY2UuYm9keS5zdWJzdHJpbmcoZS5zdGFydCxlLmVuZCkpfWZ1bmN0aW9uIGRyKGUpe3ZhciB0PW5ldyBTZXQsbj1bXTtyZXR1cm4gZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGkpe2lmKGkua2luZD09PSJGcmFnbWVudERlZmluaXRpb24iKXt2YXIgcj1pLm5hbWUudmFsdWUscz1ocihpLmxvYyksbz1pdC5nZXQocik7byYmIW8uaGFzKHMpP010JiZjb25zb2xlLndhcm4oIldhcm5pbmc6IGZyYWdtZW50IHdpdGggbmFtZSAiK3IrYCBhbHJlYWR5IGV4aXN0cy4KZ3JhcGhxbC10YWcgZW5mb3JjZXMgYWxsIGZyYWdtZW50IG5hbWVzIGFjcm9zcyB5b3VyIGFwcGxpY2F0aW9uIHRvIGJlIHVuaXF1ZTsgcmVhZCBtb3JlIGFib3V0CnRoaXMgaW4gdGhlIGRvY3M6IGh0dHA6Ly9kZXYuYXBvbGxvZGF0YS5jb20vY29yZS9mcmFnbWVudHMuaHRtbCN1bmlxdWUtbmFtZXNgKTpvfHxpdC5zZXQocixvPW5ldyBTZXQpLG8uYWRkKHMpLHQuaGFzKHMpfHwodC5hZGQocyksbi5wdXNoKGkpKX1lbHNlIG4ucHVzaChpKX0pLFBlKFBlKHt9LGUpLHtkZWZpbml0aW9uczpufSl9ZnVuY3Rpb24gcHIoZSl7dmFyIHQ9bmV3IFNldChlLmRlZmluaXRpb25zKTt0LmZvckVhY2goZnVuY3Rpb24oaSl7aS5sb2MmJmRlbGV0ZSBpLmxvYyxPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKHIpe3ZhciBzPWlbcl07cyYmdHlwZW9mIHM9PSJvYmplY3QiJiZ0LmFkZChzKX0pfSk7dmFyIG49ZS5sb2M7cmV0dXJuIG4mJihkZWxldGUgbi5zdGFydFRva2VuLGRlbGV0ZSBuLmVuZFRva2VuKSxlfWZ1bmN0aW9uIG1yKGUpe3ZhciB0PVV0KGUpO2lmKCFGZS5oYXModCkpe3ZhciBuPWt0KGUse2V4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzOkJlLGFsbG93TGVnYWN5RnJhZ21lbnRWYXJpYWJsZXM6QmV9KTtpZighbnx8bi5raW5kIT09IkRvY3VtZW50Iil0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIHZhbGlkIEdyYXBoUUwgZG9jdW1lbnQuIik7RmUuc2V0KHQscHIoZHIobikpKX1yZXR1cm4gRmUuZ2V0KHQpfWZ1bmN0aW9uIFcoZSl7Zm9yKHZhciB0PVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbi0xXT1hcmd1bWVudHNbbl07dHlwZW9mIGU9PSJzdHJpbmciJiYoZT1bZV0pO3ZhciBpPWVbMF07cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbihyLHMpe3ImJnIua2luZD09PSJEb2N1bWVudCI/aSs9ci5sb2Muc291cmNlLmJvZHk6aSs9cixpKz1lW3MrMV19KSxtcihpKX1mdW5jdGlvbiB5cigpe0ZlLmNsZWFyKCksaXQuY2xlYXIoKX1mdW5jdGlvbiB2cigpe010PSExfWZ1bmN0aW9uIGdyKCl7QmU9ITB9ZnVuY3Rpb24gRXIoKXtCZT0hMX12YXIgQWU9e2dxbDpXLHJlc2V0Q2FjaGVzOnlyLGRpc2FibGVGcmFnbWVudFdhcm5pbmdzOnZyLGVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzOmdyLGRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczpFcn07KGZ1bmN0aW9uKGUpe2UuZ3FsPUFlLmdxbCxlLnJlc2V0Q2FjaGVzPUFlLnJlc2V0Q2FjaGVzLGUuZGlzYWJsZUZyYWdtZW50V2FybmluZ3M9QWUuZGlzYWJsZUZyYWdtZW50V2FybmluZ3MsZS5lbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcz1BZS5lbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyxlLmRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcz1BZS5kaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXN9KShXfHwoVz17fSkpLFcuZGVmYXVsdD1XO3ZhciBWdDsoZnVuY3Rpb24oZSl7ZS5CaWxsaW5nUXVvdGFFeGNlZWRlZD0iQmlsbGluZ1F1b3RhRXhjZWVkZWQifSkoVnR8fChWdD17fSkpO2NvbnN0IF9yPVdgCgltdXRhdGlvbiBQdXNoUGF5bG9hZCgKCQkkc2Vzc2lvbl9zZWN1cmVfaWQ6IFN0cmluZyEKCQkkcGF5bG9hZF9pZDogSUQhCgkJJGV2ZW50czogUmVwbGF5RXZlbnRzSW5wdXQhCgkJJG1lc3NhZ2VzOiBTdHJpbmchCgkJJHJlc291cmNlczogU3RyaW5nIQoJCSR3ZWJfc29ja2V0X2V2ZW50czogU3RyaW5nIQoJCSRlcnJvcnM6IFtFcnJvck9iamVjdElucHV0XSEKCQkkaXNfYmVhY29uOiBCb29sZWFuCgkJJGhhc19zZXNzaW9uX3VubG9hZGVkOiBCb29sZWFuCgkJJGhpZ2hsaWdodF9sb2dzOiBTdHJpbmcKCSkgewoJCXB1c2hQYXlsb2FkKAoJCQlzZXNzaW9uX3NlY3VyZV9pZDogJHNlc3Npb25fc2VjdXJlX2lkCgkJCXBheWxvYWRfaWQ6ICRwYXlsb2FkX2lkCgkJCWV2ZW50czogJGV2ZW50cwoJCQltZXNzYWdlczogJG1lc3NhZ2VzCgkJCXJlc291cmNlczogJHJlc291cmNlcwoJCQl3ZWJfc29ja2V0X2V2ZW50czogJHdlYl9zb2NrZXRfZXZlbnRzCgkJCWVycm9yczogJGVycm9ycwoJCQlpc19iZWFjb246ICRpc19iZWFjb24KCQkJaGFzX3Nlc3Npb25fdW5sb2FkZWQ6ICRoYXNfc2Vzc2lvbl91bmxvYWRlZAoJCQloaWdobGlnaHRfbG9nczogJGhpZ2hsaWdodF9sb2dzCgkJKQoJfQpgLFRyPVdgCgltdXRhdGlvbiBQdXNoUGF5bG9hZENvbXByZXNzZWQoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHBheWxvYWRfaWQ6IElEIQoJCSRkYXRhOiBTdHJpbmchCgkpIHsKCQlwdXNoUGF5bG9hZENvbXByZXNzZWQoCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJcGF5bG9hZF9pZDogJHBheWxvYWRfaWQKCQkJZGF0YTogJGRhdGEKCQkpCgl9CmAsYnI9V2AKCW11dGF0aW9uIGlkZW50aWZ5U2Vzc2lvbigKCQkkc2Vzc2lvbl9zZWN1cmVfaWQ6IFN0cmluZyEKCQkkdXNlcl9pZGVudGlmaWVyOiBTdHJpbmchCgkJJHVzZXJfb2JqZWN0OiBBbnkKCSkgewoJCWlkZW50aWZ5U2Vzc2lvbigKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQl1c2VyX2lkZW50aWZpZXI6ICR1c2VyX2lkZW50aWZpZXIKCQkJdXNlcl9vYmplY3Q6ICR1c2VyX29iamVjdAoJCSkKCX0KYCxOcj1XYAoJbXV0YXRpb24gYWRkU2Vzc2lvblByb3BlcnRpZXMoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHByb3BlcnRpZXNfb2JqZWN0OiBBbnkKCSkgewoJCWFkZFNlc3Npb25Qcm9wZXJ0aWVzKAoJCQlzZXNzaW9uX3NlY3VyZV9pZDogJHNlc3Npb25fc2VjdXJlX2lkCgkJCXByb3BlcnRpZXNfb2JqZWN0OiAkcHJvcGVydGllc19vYmplY3QKCQkpCgl9CmAseHI9V2AKCW11dGF0aW9uIHB1c2hNZXRyaWNzKCRtZXRyaWNzOiBbTWV0cmljSW5wdXRdISkgewoJCXB1c2hNZXRyaWNzKG1ldHJpY3M6ICRtZXRyaWNzKQoJfQpgLEFyPVdgCgltdXRhdGlvbiBhZGRTZXNzaW9uRmVlZGJhY2soCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHVzZXJfbmFtZTogU3RyaW5nCgkJJHVzZXJfZW1haWw6IFN0cmluZwoJCSR2ZXJiYXRpbTogU3RyaW5nIQoJCSR0aW1lc3RhbXA6IFRpbWVzdGFtcCEKCSkgewoJCWFkZFNlc3Npb25GZWVkYmFjaygKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQl1c2VyX25hbWU6ICR1c2VyX25hbWUKCQkJdXNlcl9lbWFpbDogJHVzZXJfZW1haWwKCQkJdmVyYmF0aW06ICR2ZXJiYXRpbQoJCQl0aW1lc3RhbXA6ICR0aW1lc3RhbXAKCQkpCgl9CmAsSXI9V2AKCW11dGF0aW9uIGluaXRpYWxpemVTZXNzaW9uKAoJCSRzZXNzaW9uX3NlY3VyZV9pZDogU3RyaW5nIQoJCSRvcmdhbml6YXRpb25fdmVyYm9zZV9pZDogU3RyaW5nIQoJCSRlbmFibGVfc3RyaWN0X3ByaXZhY3k6IEJvb2xlYW4hCgkJJHByaXZhY3lfc2V0dGluZzogU3RyaW5nIQoJCSRlbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHM6IEJvb2xlYW4hCgkJJGNsaWVudFZlcnNpb246IFN0cmluZyEKCQkkZmlyc3Rsb2FkVmVyc2lvbjogU3RyaW5nIQoJCSRjbGllbnRDb25maWc6IFN0cmluZyEKCQkkZW52aXJvbm1lbnQ6IFN0cmluZyEKCQkkaWQ6IFN0cmluZyEKCQkkYXBwVmVyc2lvbjogU3RyaW5nCgkJJHNlcnZpY2VOYW1lOiBTdHJpbmchCgkJJGNsaWVudF9pZDogU3RyaW5nIQoJCSRuZXR3b3JrX3JlY29yZGluZ19kb21haW5zOiBbU3RyaW5nIV0KCQkkZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZzogQm9vbGVhbgoJKSB7CgkJaW5pdGlhbGl6ZVNlc3Npb24oCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJb3JnYW5pemF0aW9uX3ZlcmJvc2VfaWQ6ICRvcmdhbml6YXRpb25fdmVyYm9zZV9pZAoJCQllbmFibGVfc3RyaWN0X3ByaXZhY3k6ICRlbmFibGVfc3RyaWN0X3ByaXZhY3kKCQkJZW5hYmxlX3JlY29yZGluZ19uZXR3b3JrX2NvbnRlbnRzOiAkZW5hYmxlX3JlY29yZGluZ19uZXR3b3JrX2NvbnRlbnRzCgkJCWNsaWVudFZlcnNpb246ICRjbGllbnRWZXJzaW9uCgkJCWZpcnN0bG9hZFZlcnNpb246ICRmaXJzdGxvYWRWZXJzaW9uCgkJCWNsaWVudENvbmZpZzogJGNsaWVudENvbmZpZwoJCQllbnZpcm9ubWVudDogJGVudmlyb25tZW50CgkJCWFwcFZlcnNpb246ICRhcHBWZXJzaW9uCgkJCXNlcnZpY2VOYW1lOiAkc2VydmljZU5hbWUKCQkJZmluZ2VycHJpbnQ6ICRpZAoJCQljbGllbnRfaWQ6ICRjbGllbnRfaWQKCQkJbmV0d29ya19yZWNvcmRpbmdfZG9tYWluczogJG5ldHdvcmtfcmVjb3JkaW5nX2RvbWFpbnMKCQkJZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZzogJGRpc2FibGVfc2Vzc2lvbl9yZWNvcmRpbmcKCQkJcHJpdmFjeV9zZXR0aW5nOiAkcHJpdmFjeV9zZXR0aW5nCgkJKSB7CgkJCXNlY3VyZV9pZAoJCQlwcm9qZWN0X2lkCgkJfQoJfQpgLE9yPVdgCglxdWVyeSBJZ25vcmUoJGlkOiBJRCEpIHsKCQlpZ25vcmUoaWQ6ICRpZCkKCX0KYCxTcj0oZSx0LG4saSk9PmUoKTtmdW5jdGlvbiB3cihlLHQ9U3Ipe3JldHVybntQdXNoUGF5bG9hZChuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChfcixuLFAoUCh7fSxpKSxyKSksIlB1c2hQYXlsb2FkIiwibXV0YXRpb24iLG4pfSxQdXNoUGF5bG9hZENvbXByZXNzZWQobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoVHIsbixQKFAoe30saSkscikpLCJQdXNoUGF5bG9hZENvbXByZXNzZWQiLCJtdXRhdGlvbiIsbil9LGlkZW50aWZ5U2Vzc2lvbihuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChicixuLFAoUCh7fSxpKSxyKSksImlkZW50aWZ5U2Vzc2lvbiIsIm11dGF0aW9uIixuKX0sYWRkU2Vzc2lvblByb3BlcnRpZXMobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoTnIsbixQKFAoe30saSkscikpLCJhZGRTZXNzaW9uUHJvcGVydGllcyIsIm11dGF0aW9uIixuKX0scHVzaE1ldHJpY3MobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoeHIsbixQKFAoe30saSkscikpLCJwdXNoTWV0cmljcyIsIm11dGF0aW9uIixuKX0sYWRkU2Vzc2lvbkZlZWRiYWNrKG4saSl7cmV0dXJuIHQocj0+ZS5yZXF1ZXN0KEFyLG4sUChQKHt9LGkpLHIpKSwiYWRkU2Vzc2lvbkZlZWRiYWNrIiwibXV0YXRpb24iLG4pfSxpbml0aWFsaXplU2Vzc2lvbihuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChJcixuLFAoUCh7fSxpKSxyKSksImluaXRpYWxpemVTZXNzaW9uIiwibXV0YXRpb24iLG4pfSxJZ25vcmUobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoT3IsbixQKFAoe30saSkscikpLCJJZ25vcmUiLCJxdWVyeSIsbil9fX1jbGFzcyBEcntjb25zdHJ1Y3Rvcih0LG4pe2x0KHRoaXMsImRlYnVnIik7bHQodGhpcywibmFtZSIpO3RoaXMuZGVidWc9dCx0aGlzLm5hbWU9bn1sb2coLi4udCl7aWYodGhpcy5kZWJ1Zyl7bGV0IG49YFske0RhdGUubm93KCl9XWA7dGhpcy5uYW1lJiYobis9YCAtICR7dGhpcy5uYW1lfWApLGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsW24sLi4udF0pfX19dmFyIHN0OyhmdW5jdGlvbihlKXtlLkJpbGxpbmdRdW90YUV4Y2VlZGVkPSJCaWxsaW5nUXVvdGFFeGNlZWRlZCJ9KShzdHx8KHN0PXt9KSk7Y29uc3QgQ3I9MTAsa3I9MWUzLFJyPTUwMCxMcj1bc3QuQmlsbGluZ1F1b3RhRXhjZWVkZWQudG9TdHJpbmcoKV0sUHI9ZT0+e3ZhciBuO3JldHVybigobj1lLnJlc3BvbnNlLmVycm9ycyk9PW51bGw/dm9pZCAwOm4uZmluZChpPT5Mci5pbmNsdWRlcyhpLm1lc3NhZ2UpKSk9PT12b2lkIDB9LEZyPWU9Pntjb25zdCB0PShuLGkscixzLG89MCk9PlgodGhpcyxudWxsLGZ1bmN0aW9uKigpe3RyeXtyZXR1cm4geWllbGQgbigpfWNhdGNoKGMpe2lmKGMgaW5zdGFuY2VvZiBoZSYmIVByKGMpKXRocm93IGM7aWYobzxDcilyZXR1cm4geWllbGQgbmV3IFByb21pc2UoZj0+c2V0VGltZW91dChmLGtyK1JyKk1hdGgucG93KDIsbykpKSx5aWVsZCB0KG4saSxyLHMsbysxKTt0aHJvdyBjb25zb2xlLmVycm9yKGBoaWdobGlnaHQuaW86IFske2V8fGV9XSBkYXRhIHJlcXVlc3QgZmFpbGVkIGFmdGVyICR7b30gcmV0cmllc2ApLGN9fSk7cmV0dXJuIHR9LGp0PTUscXQ9MmUzLEJyPVsibnVtYmVyIiwic3RyaW5nIiwiYm9vbGVhbiJdO3ZhciBaOyhmdW5jdGlvbihlKXtlW2UuSW5pdGlhbGl6ZT0wXT0iSW5pdGlhbGl6ZSIsZVtlLkFzeW5jRXZlbnRzPTFdPSJBc3luY0V2ZW50cyIsZVtlLklkZW50aWZ5PTJdPSJJZGVudGlmeSIsZVtlLlByb3BlcnRpZXM9M109IlByb3BlcnRpZXMiLGVbZS5NZXRyaWNzPTRdPSJNZXRyaWNzIixlW2UuRmVlZGJhY2s9NV09IkZlZWRiYWNrIixlW2UuQ3VzdG9tRXZlbnQ9Nl09IkN1c3RvbUV2ZW50IixlW2UuU3RvcD03XT0iU3RvcCJ9KShafHwoWj17fSkpO2Z1bmN0aW9uICRyKGUpe3JldHVybiBYKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdCB0PXlpZWxkIG5ldyBQcm9taXNlKG49Pntjb25zdCBpPW5ldyBGaWxlUmVhZGVyO2kub25sb2FkPSgpPT5uKGkucmVzdWx0KSxpLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoW2VdKSl9KTtyZXR1cm4gdC5zbGljZSh0LmluZGV4T2YoIiwiKSsxKX0pfWNvbnN0ICRlPXNlbGY7ZnVuY3Rpb24gR3QoZSx0KXtjb25zdCBuPXt9LGk9W10scj1bXTtmb3IoY29uc3RbcyxvXW9mIE9iamVjdC5lbnRyaWVzKGUpKXtpZihvPT1udWxsKWNvbnRpbnVlO0JyLmluY2x1ZGVzKHR5cGVvZiBvKXx8aS5wdXNoKHtbc106b30pO2xldCBjO3R5cGVvZiBvPT0ic3RyaW5nIj9jPW86Yz1wZShvKSxjLmxlbmd0aD5xdCYmKHIucHVzaCh7W3NdOm99KSxjPWMuc3Vic3RyaW5nKDAscXQpKSxuW3NdPWN9cmV0dXJuIHQhPT0ic2Vzc2lvbiImJihpLmxlbmd0aD4wJiZjb25zb2xlLndhcm4oYEhpZ2hsaWdodCB3YXMgcGFzc2VkIG9uZSBvciBtb3JlICR7dH0gcHJvcGVydGllcyBub3Qgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbi5gLGkpLHIubGVuZ3RoPjAmJmNvbnNvbGUud2FybihgSGlnaGxpZ2h0IHdhcyBwYXNzZWQgb25lIG9yIG1vcmUgJHt0fSBwcm9wZXJ0aWVzIGV4Y2VlZGluZyAyMDAwIGNoYXJhY3RlcnMsIHdoaWNoIHdpbGwgYmUgdHJ1bmNhdGVkLmAscikpLG59e2xldCBlLHQsbixpPTAscj0wLHM9ITEsbz0wLGM9bmV3IERyKCExLCJbd29ya2VyXSIpO2NvbnN0IGY9W10sZD0oKT0+byE9PTAmJmk8anQmJiEhKG4hPW51bGwmJm4ubGVuZ3RoKSx1PSh2LEUpPT57JGUucG9zdE1lc3NhZ2Uoe3Jlc3BvbnNlOnt0eXBlOlouQ3VzdG9tRXZlbnQsdGFnOnYscGF5bG9hZDpFfX0pfSx5PXY9PlgodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0e2lkOkUsZXZlbnRzOmssbWVzc2FnZXM6dyxlcnJvcnM6TCxyZXNvdXJjZXNTdHJpbmc6JCx3ZWJTb2NrZXRFdmVudHNTdHJpbmc6cSxoYXNTZXNzaW9uVW5sb2FkZWQ6TSxoaWdobGlnaHRMb2dzOkl9PXYsTz1wZSh7bWVzc2FnZXM6d30pO2xldCBqPXtzZXNzaW9uX3NlY3VyZV9pZDpuLHBheWxvYWRfaWQ6RS50b1N0cmluZygpLGV2ZW50czp7ZXZlbnRzOmt9LG1lc3NhZ2VzOk8scmVzb3VyY2VzOiQsd2ViX3NvY2tldF9ldmVudHM6cSxlcnJvcnM6TCxpc19iZWFjb246ITEsaGFzX3Nlc3Npb25fdW5sb2FkZWQ6TX07SSYmKGouaGlnaGxpZ2h0X2xvZ3M9SSk7Y29uc3QgVT1mbihKU09OLnN0cmluZ2lmeShqKSksSD1jbihVKSxRPXlpZWxkICRyKEgpLGE9e3R5cGU6Wi5Bc3luY0V2ZW50cyxpZDpFLGV2ZW50c1NpemU6VS5sZW5ndGgsY29tcHJlc3NlZFNpemU6US5sZW5ndGh9O2MubG9nKGBQdXNoaW5nIHBheWxvYWQ6ICR7SlNPTi5zdHJpbmdpZnkoe3Nlc3Npb25TZWN1cmVJRDpuLGlkOkUsZmlyc3RTSUQ6TWF0aC5taW4oLi4uai5ldmVudHMuZXZlbnRzLm1hcCh4PT54PT1udWxsP3ZvaWQgMDp4Ll9zaWQpLmZpbHRlcih4PT4hIXgpKSxldmVudHNMZW5ndGg6ai5ldmVudHMuZXZlbnRzLmxlbmd0aCxtZXNzYWdlc0xlbmd0aDp3Lmxlbmd0aCxyZXNvdXJjZXNMZW5ndGg6JC5sZW5ndGgsd2ViU29ja2V0TGVuZ3RoOnEubGVuZ3RoLGVycm9yc0xlbmd0aDpMLmxlbmd0aCxidWZMZW5ndGg6VS5sZW5ndGgsY29tcHJlc3NlZExlbmd0aDpILmxlbmd0aCxjb21wcmVzc2VkQmFzZTY0TGVuZ3RoOlEubGVuZ3RofSx2b2lkIDAsMil9YCk7Y29uc3QgaD1lLlB1c2hQYXlsb2FkQ29tcHJlc3NlZCh7c2Vzc2lvbl9zZWN1cmVfaWQ6bixwYXlsb2FkX2lkOkUudG9TdHJpbmcoKSxkYXRhOlF9KTtsZXQgXz1Qcm9taXNlLnJlc29sdmUoKTtmLmxlbmd0aCYmKF89ZS5wdXNoTWV0cmljcyh7bWV0cmljczpmfSksZi5zcGxpY2UoMCkpO2xldCBBPXBlcmZvcm1hbmNlLm5vdygpO2NvbnN0IFI9c2V0SW50ZXJ2YWwoKCk9PntBJiZwZXJmb3JtYW5jZS5ub3coKS1BPiR0JiYoY29uc29sZS53YXJuKGBVcGxvYWRpbmcgcHVzaFBheWxvYWQgdG9vayB0b28gbG9uZywgZmFpbHVyZSBudW1iZXIgIyR7cn0uYCkscis9MSxjbGVhckludGVydmFsKFIpLHI+PWp0JiYoY29uc29sZS53YXJuKCJVcGxvYWRpbmcgcHVzaFBheWxvYWQgdG9vayB0b28gbG9uZywgc3RvcHBpbmcgcmVjb3JkaW5nIHRvIGF2b2lkIE9PTS4iKSwkZS5wb3N0TWVzc2FnZSh7cmVzcG9uc2U6e3R5cGU6Wi5TdG9wLHJlcXVlc3RTdGFydDpBLGFzeW5jRXZlbnRzUmVzcG9uc2U6YX19KSxiKHt0eXBlOlouUHJvcGVydGllcyxwcm9wZXJ0aWVzT2JqZWN0OntzdG9wUmVhc29uOiJQdXNoIFBheWxvYWQgVGltZW91dCJ9LHByb3BlcnR5VHlwZTp7dHlwZToidHJhY2sifX0pKSl9LDEwMCk7dHJ5e3lpZWxkIFByb21pc2UuYWxsKFtoLF9dKSxyJiZwZXJmb3JtYW5jZS5ub3coKS1BPD0kdCYmKGNvbnNvbGUud2FybihgcHVzaFBheWxvYWQgc3VjY2VlZGVkIGFmdGVyICMke3J9IGZhaWx1cmVzLCByZXNldHRpbmcgc3RvcCBzd2l0Y2guYCkscj0wKX1maW5hbGx5e0E9MCxjbGVhckludGVydmFsKFIpfSRlLnBvc3RNZXNzYWdlKHtyZXNwb25zZTphfSl9KSxnPXY9PlgodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0e3VzZXJPYmplY3Q6RSx1c2VySWRlbnRpZmllcjprLHNvdXJjZTp3fT12O3c9PT0ic2VnbWVudCI/dSgiU2VnbWVudCBJZGVudGlmeSIscGUoUCh7dXNlcklkZW50aWZpZXI6a30sRSkpKTp1KCJJZGVudGlmeSIscGUoUCh7dXNlcklkZW50aWZpZXI6a30sRSkpKSx5aWVsZCBlLmlkZW50aWZ5U2Vzc2lvbih7c2Vzc2lvbl9zZWN1cmVfaWQ6bix1c2VyX2lkZW50aWZpZXI6ayx1c2VyX29iamVjdDpHdChFLCJ1c2VyIil9KTtjb25zdCBMPXc9PT0ic2VnbWVudCI/dzoiZGVmYXVsdCI7Yy5sb2coYElkZW50aWZ5ICgke2t9LCBzb3VyY2U6ICR7TH0pIHcvIG9iajogJHtwZShFKX0gQCAke3R9YCl9KSxiPXY9PlgodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0e3Byb3BlcnRpZXNPYmplY3Q6RSxwcm9wZXJ0eVR5cGU6a309djtsZXQgdzsoaz09bnVsbD92b2lkIDA6ay50eXBlKT09PSJzZXNzaW9uIj8odz0iU2Vzc2lvbiIseWllbGQgZS5hZGRTZXNzaW9uUHJvcGVydGllcyh7c2Vzc2lvbl9zZWN1cmVfaWQ6bixwcm9wZXJ0aWVzX29iamVjdDpHdChFLCJzZXNzaW9uIil9KSk6KGs9PW51bGw/dm9pZCAwOmsuc291cmNlKT09PSJzZWdtZW50Ij93PSJTZWdtZW50Ijp3PSJUcmFjayIsdyE9PSJTZXNzaW9uIiYmdSh3LHBlKEUpKSxjLmxvZyhgQWRkaW5nICR7d30gUHJvcGVydGllcyB0byBzZXNzaW9uICgke259KSB3LyBvYmo6ICR7SlNPTi5zdHJpbmdpZnkoRSl9IEAgJHt0fWApfSksbT12PT5YKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtmLnB1c2goLi4udi5tZXRyaWNzLm1hcChFPT4oe25hbWU6RS5uYW1lLHZhbHVlOkUudmFsdWUsc2Vzc2lvbl9zZWN1cmVfaWQ6bixjYXRlZ29yeTpFLmNhdGVnb3J5LGdyb3VwOkUuZ3JvdXAsdGltZXN0YW1wOkUudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksdGFnczpFLnRhZ3N9KSkpfSksTj12PT5YKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdHt0aW1lc3RhbXA6RSx2ZXJiYXRpbTprLHVzZXJFbWFpbDp3LHVzZXJOYW1lOkx9PXY7eWllbGQgZS5hZGRTZXNzaW9uRmVlZGJhY2soe3Nlc3Npb25fc2VjdXJlX2lkOm4sdGltZXN0YW1wOkUsdmVyYmF0aW06ayx1c2VyX2VtYWlsOncsdXNlcl9uYW1lOkx9KX0pOyRlLm9ubWVzc2FnZT1mdW5jdGlvbih2KXtyZXR1cm4gWCh0aGlzLG51bGwsZnVuY3Rpb24qKCl7aWYodi5kYXRhLm1lc3NhZ2UudHlwZT09PVouSW5pdGlhbGl6ZSl7dD12LmRhdGEubWVzc2FnZS5iYWNrZW5kLG49di5kYXRhLm1lc3NhZ2Uuc2Vzc2lvblNlY3VyZUlELHM9di5kYXRhLm1lc3NhZ2UuZGVidWcsbz12LmRhdGEubWVzc2FnZS5yZWNvcmRpbmdTdGFydFRpbWUsYy5kZWJ1Zz1zLGU9d3IobmV3IGNyKHQse2hlYWRlcnM6e319KSxGcihuKSk7cmV0dXJufWlmKGQoKSl0cnl7di5kYXRhLm1lc3NhZ2UudHlwZT09PVouQXN5bmNFdmVudHM/eWllbGQgeSh2LmRhdGEubWVzc2FnZSk6di5kYXRhLm1lc3NhZ2UudHlwZT09PVouSWRlbnRpZnk/eWllbGQgZyh2LmRhdGEubWVzc2FnZSk6di5kYXRhLm1lc3NhZ2UudHlwZT09PVouUHJvcGVydGllcz95aWVsZCBiKHYuZGF0YS5tZXNzYWdlKTp2LmRhdGEubWVzc2FnZS50eXBlPT09Wi5NZXRyaWNzP3lpZWxkIG0odi5kYXRhLm1lc3NhZ2UpOnYuZGF0YS5tZXNzYWdlLnR5cGU9PT1aLkZlZWRiYWNrJiYoeWllbGQgTih2LmRhdGEubWVzc2FnZSkpLGk9MH1jYXRjaChFKXtzJiZjb25zb2xlLmVycm9yKEUpLGkrPTF9fSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZ2hsaWdodC1jbGllbnQtd29ya2VyLUJlTlRnNWxWLmpzLm1hcAo=", iy = (s) => Uint8Array.from(atob(s), (e) => e.charCodeAt(0)), qo = typeof self != "undefined" && self.Blob && new Blob([iy(bc)], { type: "text/javascript;charset=utf-8" });
function sy(s) {
  let e;
  try {
    if (e = qo && (self.URL || self.webkitURL).createObjectURL(qo), !e) throw "";
    const t = new Worker(e, {
      name: s == null ? void 0 : s.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch (t) {
    return new Worker(
      "data:text/javascript;base64," + bc,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
var Ie;
(function(s) {
  s[s.Initialize = 0] = "Initialize", s[s.AsyncEvents = 1] = "AsyncEvents", s[s.Identify = 2] = "Identify", s[s.Properties = 3] = "Properties", s[s.Metrics = 4] = "Metrics", s[s.Feedback = 5] = "Feedback", s[s.CustomEvent = 6] = "CustomEvent", s[s.Stop = 7] = "Stop";
})(Ie || (Ie = {}));
const Xt = (s, e) => {
  console.warn(`Highlight Warning: (${s}): `, { output: e });
};
var $i;
(function(s) {
  s.CLIENT_ID = "highlightClientID";
})($i || ($i = {}));
class yc {
  constructor(e, t) {
    Y(this, "options");
    /** Determines if the client is running on a Highlight property (e.g. frontend). */
    Y(this, "isRunningOnHighlight");
    /** Verbose project ID that is exposed to users. Legacy users may still be using ints. */
    Y(this, "organizationID");
    Y(this, "graphqlSDK");
    Y(this, "events");
    Y(this, "sessionData");
    Y(this, "ready");
    Y(this, "manualStopped");
    Y(this, "state");
    Y(this, "logger");
    Y(this, "enableSegmentIntegration");
    Y(this, "privacySetting");
    Y(this, "enableCanvasRecording");
    Y(this, "enablePerformanceRecording");
    Y(this, "samplingStrategy");
    Y(this, "inlineImages");
    Y(this, "inlineStylesheet");
    Y(this, "debugOptions");
    Y(this, "listeners");
    Y(this, "firstloadVersion");
    Y(this, "environment");
    Y(this, "sessionShortcut");
    /** The end-user's app version. This isn't Highlight's version. */
    Y(this, "appVersion");
    Y(this, "serviceName");
    Y(this, "_worker");
    Y(this, "_optionsInternal");
    Y(this, "_backendUrl");
    Y(this, "_recordingStartTime");
    Y(this, "_isOnLocalHost");
    Y(this, "_onToggleFeedbackFormVisibility");
    Y(this, "_firstLoadListeners");
    Y(this, "_isCrossOriginIframe");
    Y(this, "_eventBytesSinceSnapshot");
    Y(this, "_lastSnapshotTime");
    Y(this, "_lastVisibilityChangeTime");
    Y(this, "pushPayloadTimerId");
    Y(this, "hasSessionUnloaded");
    Y(this, "hasPushedData");
    Y(this, "reloaded");
    Y(this, "_hasPreviouslyInitialized");
    Y(this, "_recordStop");
    var r, n, l, a, o;
    e.sessionSecureID || (e.sessionSecureID = Is()), this.options = e, typeof ((r = this.options) == null ? void 0 : r.debug) == "boolean" ? this.debugOptions = this.options.debug ? { clientInteractions: !0 } : {} : this.debugOptions = (l = (n = this.options) == null ? void 0 : n.debug) != null ? l : {}, this.logger = new Qb(this.debugOptions.clientInteractions), e.storageMode && (this.logger.log(`initializing in ${e.storageMode} session mode`), Mc(e.storageMode)), zc(!(e != null && e.skipCookieSessionDataLoad)), this._worker = new sy(), this._worker.onmessage = (c) => {
      var u, d, h;
      ((u = c.data.response) == null ? void 0 : u.type) === Ie.AsyncEvents ? (this._eventBytesSinceSnapshot += c.data.response.eventsSize, this.logger.log(`Web worker sent payloadID ${c.data.response.id} size ${c.data.response.eventsSize} bytes, compression ratio ${c.data.response.eventsSize / c.data.response.compressedSize}.
                Total since snapshot: ${(this._eventBytesSinceSnapshot / 1e6).toFixed(1)}MB`)) : ((d = c.data.response) == null ? void 0 : d.type) === Ie.CustomEvent ? this.addCustomEvent(c.data.response.tag, c.data.response.payload) : ((h = c.data.response) == null ? void 0 : h.type) === Ie.Stop && (Xt("Stopping recording due to worker failure", c.data.response), this.stopRecording(!1));
    };
    let i = Gn();
    if (this.reloaded = !1, !((a = this.sessionData) != null && a.sessionSecureID) && (i != null && i.sessionSecureID))
      this.sessionData = i, this.options.sessionSecureID = i.sessionSecureID, this.reloaded = !0, this.logger.log(`Tab reloaded, continuing previous session: ${this.sessionData.sessionSecureID}`);
    else {
      for (const c of Object.values(Le))
        In(c);
      this.sessionData = {
        sessionSecureID: this.options.sessionSecureID,
        projectID: 0,
        payloadID: 1,
        sessionStartTime: Date.now()
      };
    }
    this._hasPreviouslyInitialized = !1, this._firstLoadListeners = t || new je(this.options);
    try {
      window.parent.document && (this._isCrossOriginIframe = !1);
    } catch (c) {
      this._isCrossOriginIframe = (o = this.options.recordCrossOriginIframe) != null ? o : !0;
    }
    this._initMembers(this.options);
  }
  static create(e) {
    return new yc(e);
  }
  // Start a new session
  _reset(t) {
    return ee(this, arguments, function* ({ forceNew: e }) {
      this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      let i, r;
      if (!e)
        try {
          i = xe(Le.USER_IDENTIFIER);
          const n = xe(Le.USER_OBJECT);
          n && (r = JSON.parse(n));
        } catch (n) {
        }
      for (const n of Object.values(Le))
        In(n);
      this.sessionData.sessionSecureID = Is(), this.sessionData.sessionStartTime = Date.now(), this.options.sessionSecureID = this.sessionData.sessionSecureID, this.stopRecording(), this._firstLoadListeners = new je(this.options), yield this.initialize(), i && r && this.identify(i, r);
    });
  }
  _initMembers(e) {
    var n, l, a, o, c, u, d, h, p, y, f;
    this.sessionShortcut = !1, this._recordingStartTime = 0, this._isOnLocalHost = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "", this.ready = !1, this.state = "NotRecording", this.manualStopped = !1, this.enableSegmentIntegration = !!e.enableSegmentIntegration, this.privacySetting = (n = e.privacySetting) != null ? n : "default", this.enableCanvasRecording = (l = e.enableCanvasRecording) != null ? l : !1, this.enablePerformanceRecording = (a = e.enablePerformanceRecording) != null ? a : !0, this.inlineImages = (o = e.inlineImages) != null ? o : this._isOnLocalHost, this.inlineStylesheet = (c = e.inlineStylesheet) != null ? c : !0, this.samplingStrategy = X({
      canvasFactor: 0.5,
      canvasMaxSnapshotDimension: 360,
      canvasClearWebGLBuffer: !0,
      dataUrlOptions: Tc()
    }, (u = e.samplingStrategy) != null ? u : {
      canvas: 2
    }), this._backendUrl = (d = e == null ? void 0 : e.backendUrl) != null ? d : "https://pub.highlight.io", this._backendUrl[0] === "/" && (this._backendUrl = new URL(this._backendUrl, document.baseURI).href);
    const t = new lu(`${this._backendUrl}`, {
      headers: {}
    });
    this.graphqlSDK = tb(t, Hc(((h = this.sessionData) == null ? void 0 : h.sessionSecureID) || ((p = this.options) == null ? void 0 : p.sessionSecureID))), this.environment = (y = e.environment) != null ? y : "production", this.appVersion = e.appVersion, this.serviceName = (f = e.serviceName) != null ? f : "", typeof e.organizationID == "string" ? this.organizationID = e.organizationID : this.organizationID = e.organizationID.toString(), this.isRunningOnHighlight = this.organizationID === "1" || this.organizationID === "1jdkoe52", this.firstloadVersion = e.firstloadVersion || "unknown", this.sessionShortcut = e.sessionShortcut || !1, this._onToggleFeedbackFormVisibility = () => {
    };
    const m = e, { firstloadVersion: i } = m, r = pe(m, ["firstloadVersion"]);
    this._optionsInternal = r, this.listeners = [], this.events = [], this.hasSessionUnloaded = !1, this.hasPushedData = !1, window.Intercom && window.Intercom("onShow", () => {
      window.Intercom("update", {
        highlightSessionURL: this.getCurrentSessionURLWithTimestamp()
      }), this.addProperties({ event: "Intercom onShow" });
    }), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime(), this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime();
  }
  identify(e, t = {}, i) {
    if (!e || e === "") {
      console.warn("Highlight's identify() call was passed an empty identifier.", { user_identifier: e, user_object: t });
      return;
    }
    this.sessionData.userIdentifier = e.toString(), this.sessionData.userObject = t, Pe(Le.USER_IDENTIFIER, e.toString()), Pe(Le.USER_OBJECT, JSON.stringify(t)), this._worker.postMessage({
      message: {
        type: Ie.Identify,
        userIdentifier: e,
        userObject: t,
        source: i
      }
    });
  }
  pushCustomError(e, t) {
    return this.consumeCustomError(new Error(e), void 0, t);
  }
  consumeCustomError(e, t, i) {
    let r = {};
    if (i)
      try {
        r = X(X({}, JSON.parse(i)), r);
      } catch (n) {
      }
    return this.consumeError(e, {
      message: t,
      payload: r
    });
  }
  consumeError(e, { message: t, payload: i, source: r, type: n }) {
    var o, c, u, d;
    e.cause && (i = se(X({}, i), { "exception.cause": e.cause }));
    let l = t ? t + ":" + e.message : e.message;
    n === "React.ErrorBoundary" && (l = "ErrorBoundary: " + l);
    const a = Jc.parse(e);
    this._firstLoadListeners.errors.push({
      event: l,
      type: n != null ? n : "custom",
      url: window.location.href,
      source: r != null ? r : "",
      lineNumber: (o = a[0]) != null && o.lineNumber ? (c = a[0]) == null ? void 0 : c.lineNumber : 0,
      columnNumber: (u = a[0]) != null && u.columnNumber ? (d = a[0]) == null ? void 0 : d.columnNumber : 0,
      stackTrace: a,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      payload: JSON.stringify(i)
    });
  }
  addProperties(e = {}, t) {
    const i = X({}, e);
    Object.entries(i).forEach(([r, n]) => {
      try {
        structuredClone(n);
      } catch (l) {
        delete i[r];
      }
    }), this._worker.postMessage({
      message: {
        type: Ie.Properties,
        propertiesObject: i,
        propertyType: t
      }
    });
  }
  initialize(e) {
    return ee(this, null, function* () {
      var t, i, r, n, l, a, o, c, u;
      if (navigator != null && navigator.webdriver && !window.Cypress || (t = navigator == null ? void 0 : navigator.userAgent) != null && t.includes("Googlebot") || (i = navigator == null ? void 0 : navigator.userAgent) != null && i.includes("AdsBot")) {
        (r = this._firstLoadListeners) == null || r.stopListening();
        return;
      }
      try {
        if (e != null && e.forceNew) {
          yield this._reset(e);
          return;
        }
        this.logger.log("Initializing...", e, this.sessionData, this.options), this.sessionData = (n = Gn(this.sessionData.sessionSecureID)) != null ? n : this.sessionData, (l = this.sessionData) != null && l.sessionStartTime ? this._recordingStartTime = (a = this.sessionData) == null ? void 0 : a.sessionStartTime : (this._recordingStartTime = (/* @__PURE__ */ new Date()).getTime(), this.sessionData.sessionStartTime = this._recordingStartTime), Ss(""), yt(this.sessionData);
        let d = xe($i.CLIENT_ID);
        d || (d = Is(), Pe($i.CLIENT_ID, d));
        let h;
        this.options.disableSessionRecording || this.options.disableNetworkRecording !== void 0 || typeof this.options.networkRecording == "boolean" ? h = !1 : h = ((o = this.options.networkRecording) == null ? void 0 : o.recordHeadersAndBody) || !1;
        let p = [];
        if (typeof this.options.networkRecording == "object" && ((c = this.options.networkRecording.destinationDomains) != null && c.length) && (p = this.options.networkRecording.destinationDomains), this._isCrossOriginIframe)
          yield this._setupCrossOriginIframe();
        else {
          const g = yield this.graphqlSDK.initializeSession({
            organization_verbose_id: this.organizationID,
            enable_strict_privacy: this.privacySetting === "strict",
            privacy_setting: this.privacySetting,
            enable_recording_network_contents: h,
            clientVersion: this.firstloadVersion,
            firstloadVersion: this.firstloadVersion,
            clientConfig: JSON.stringify(this._optionsInternal),
            environment: this.environment,
            id: d,
            appVersion: this.appVersion,
            serviceName: this.serviceName,
            session_secure_id: this.sessionData.sessionSecureID,
            client_id: d,
            network_recording_domains: p,
            disable_session_recording: this.options.disableSessionRecording
          });
          if (g.initializeSession.secure_id !== this.sessionData.sessionSecureID && this.logger.log(`Unexpected secure id returned by initializeSession: ${g.initializeSession.secure_id}, expected ${this.sessionData.sessionSecureID}`), this.sessionData.sessionSecureID = g.initializeSession.secure_id, this.sessionData.projectID = parseInt(((u = g == null ? void 0 : g.initializeSession) == null ? void 0 : u.project_id) || "0"), !this.sessionData.projectID || !this.sessionData.sessionSecureID) {
            console.error("Failed to initialize Highlight; an error occurred on our end.", this.sessionData);
            return;
          }
        }
        if (this.logger.log(`Loaded Highlight
Remote: ${this._backendUrl}
Project ID: ${this.sessionData.projectID}
SessionSecureID: ${this.sessionData.sessionSecureID}`), this.options.sessionSecureID = this.sessionData.sessionSecureID, this._worker.postMessage({
          message: {
            type: Ie.Initialize,
            sessionSecureID: this.sessionData.sessionSecureID,
            backend: this._backendUrl,
            debug: !!this.debugOptions.clientInteractions,
            recordingStartTime: this._recordingStartTime
          }
        }), this.sessionData.userIdentifier && this.identify(this.sessionData.userIdentifier, this.sessionData.userObject), this._firstLoadListeners.isListening() ? this._firstLoadListeners.hasNetworkRecording || je.setupNetworkListener(this._firstLoadListeners, this.options) : this._firstLoadListeners.startListening(), this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this._isCrossOriginIframe || (this.pushPayloadTimerId = setTimeout(() => {
          this._save();
        }, Sn)), this.options.disableSessionRecording) {
          this.logger.log("Highlight is NOT RECORDING a session replay per H.init setting."), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
          return;
        }
        const { getDeviceDetails: y } = ey();
        y && this.recordMetric([
          {
            name: Qe.DeviceMemory,
            value: y().deviceMemory,
            category: Xe.Device,
            group: window.location.href
          }
        ]);
        const f = (g, Z) => {
          Z && this.logger.log("received isCheckout emit", { event: g }), this.events.push(g);
        };
        f.bind(this);
        const m = !!this._recordStop;
        this._recordStop && (this._recordStop(), this._recordStop = void 0);
        const [W, S] = sb(this.privacySetting);
        this._recordStop = Ye({
          ignoreClass: "highlight-ignore",
          blockClass: "highlight-block",
          emit: f,
          recordCrossOriginIframes: this.options.recordCrossOriginIframe,
          privacySetting: this.privacySetting,
          maskAllInputs: W,
          maskInputOptions: S,
          recordCanvas: this.enableCanvasRecording,
          sampling: {
            canvas: {
              fps: this.samplingStrategy.canvas,
              fpsManual: this.samplingStrategy.canvasManualSnapshot,
              resizeFactor: this.samplingStrategy.canvasFactor,
              clearWebGLBuffer: this.samplingStrategy.canvasClearWebGLBuffer,
              initialSnapshotDelay: this.samplingStrategy.canvasInitialSnapshotDelay,
              dataURLOptions: this.samplingStrategy.dataUrlOptions,
              maxSnapshotDimension: this.samplingStrategy.canvasMaxSnapshotDimension
            }
          },
          keepIframeSrcFn: (g) => !this.options.recordCrossOriginIframe,
          inlineImages: this.inlineImages,
          collectFonts: this.inlineImages,
          inlineStylesheet: this.inlineStylesheet,
          plugins: [du()],
          logger: typeof this.options.debug == "boolean" && this.options.debug || typeof this.options.debug == "object" && this.options.debug.domRecording ? {
            debug: this.logger.log,
            warn: Xt
          } : void 0
        }), m || this.options.recordCrossOriginIframe && this._setupCrossOriginIframeParent(), document.referrer && (window && document.referrer.includes(window.location.origin) || (this.addCustomEvent("Referrer", document.referrer), this.addProperties({ referrer: document.referrer }, { type: "session" }))), this._setupWindowListeners(), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
      } catch (d) {
        this._isOnLocalHost && (console.error(d), Xt("initializeSession", d));
      }
    });
  }
  _visibilityHandler(e) {
    return ee(this, null, function* () {
      if (this.manualStopped) {
        this.logger.log("Ignoring visibility event due to manual stop.");
        return;
      }
      (/* @__PURE__ */ new Date()).getTime() - this._lastVisibilityChangeTime < Uc || (this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime(), this.logger.log(`Detected window ${e ? "hidden" : "visible"}.`), e ? (this.addCustomEvent("TabHidden", !0), this.options.disableBackgroundRecording && this.stopRecording()) : (this.options.disableBackgroundRecording && (yield this.initialize()), this.addCustomEvent("TabHidden", !1)));
    });
  }
  _setupCrossOriginIframe() {
    return ee(this, null, function* () {
      this.logger.log("highlight in cross-origin iframe is waiting "), yield new Promise((e) => {
        const t = (i) => {
          if (i.data.highlight === _o) {
            const r = i.data;
            this.logger.log("highlight got window message ", r), this.sessionData.projectID = r.projectID, this.sessionData.sessionSecureID = r.sessionSecureID, window.parent.postMessage({
              highlight: $o
            }, "*"), window.removeEventListener("message", t), e();
          }
        };
        window.addEventListener("message", t);
      });
    });
  }
  _setupCrossOriginIframeParent() {
    this.logger.log("highlight setting up cross origin iframe parent notification"), setInterval(() => {
      window.document.querySelectorAll("iframe").forEach((e) => {
        var t;
        (t = e.contentWindow) == null || t.postMessage({
          highlight: _o,
          projectID: this.sessionData.projectID,
          sessionSecureID: this.sessionData.sessionSecureID
        }, "*");
      });
    }, Sn), window.addEventListener("message", (e) => {
      e.data.highlight === $o && this.logger.log("highlight got response from initialized iframe");
    });
  }
  _setupWindowListeners() {
    var i;
    try {
      const r = this;
      this.enableSegmentIntegration && this.listeners.push(wb((l) => {
        if (l.type === "track") {
          const a = {};
          a["segment-event"] = l.event, r.addProperties(a, {
            type: "track",
            source: "segment"
          });
        } else if (l.type === "identify") {
          const a = l.userId.replace(/^"(.*)"$/, "$1");
          r.identify(a, l.traits, "segment");
        }
      })), this.listeners.push(ib((l) => {
        this.reloaded ? (this.addCustomEvent("Reload", l), this.reloaded = !1, r.addProperties({ reload: !0 }, { type: "session" })) : this.addCustomEvent("Navigate", l);
      })), this.listeners.push(Ub((l) => {
        this.addCustomEvent("Viewport", l), this.submitViewportMetrics(l);
      })), this.listeners.push(gb((l, a) => {
        let o = null, c = null;
        if (a && a.target) {
          const u = a.target;
          o = ic(u), c = u.textContent, c && c.length > 2e3 && (c = c.substring(0, 2e3));
        }
        this.addCustomEvent("Click", {
          clickTarget: l,
          clickTextContent: c,
          clickSelector: o
        });
      })), this.listeners.push(Zb((l) => {
        l && this.addCustomEvent("Focus", l);
      })), this.listeners.push(jb((l) => {
        const { name: a, value: o } = l;
        this.recordMetric([
          {
            name: a,
            value: o,
            group: window.location.href,
            category: Xe.WebVital
          }
        ]);
      })), this.sessionShortcut && vb(this.sessionShortcut, () => {
        window.open(this.getCurrentSessionURLWithTimestamp(), "_blank");
      }), this.enablePerformanceRecording && (this.listeners.push(Rb((l) => {
        this.addCustomEvent("Performance", Vs(l)), this.recordMetric(Object.entries(l).map(([a, o]) => o ? {
          name: a,
          value: o,
          category: Xe.Performance,
          group: window.location.href
        } : void 0).filter((a) => a));
      }, this._recordingStartTime)), this.listeners.push(Vb((l) => {
        this.addCustomEvent("Jank", Vs(l)), this.recordMetric([
          {
            name: "Jank",
            value: l.jankAmount,
            category: Xe.WebVital,
            group: l.querySelector
          }
        ]);
      }, this._recordingStartTime))), this._hasPreviouslyInitialized || ((i = window.electron) != null && i.ipcRenderer ? (window.electron.ipcRenderer.on("highlight.run", ({ visible: l }) => {
        this._visibilityHandler(!l);
      }), this.logger.log("Set up Electron highlight.run events.")) : (Wb((l) => this._visibilityHandler(l)), this.logger.log("Set up document visibility listener.")), this._hasPreviouslyInitialized = !0);
      const n = () => {
        this.hasSessionUnloaded = !0, this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      };
      window.addEventListener("beforeunload", n), this.listeners.push(() => window.removeEventListener("beforeunload", n));
    } catch (r) {
      this._isOnLocalHost && (console.error(r), Xt("initializeSession _setupWindowListeners", r));
    }
    const e = () => {
      this.addCustomEvent("Page Unload", ""), Ss(this.sessionData.sessionSecureID), yt(this.sessionData);
    };
    if (window.addEventListener("beforeunload", e), this.listeners.push(() => window.removeEventListener("beforeunload", e)), navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i)) {
      const r = () => {
        this.addCustomEvent("Page Unload", ""), Ss(this.sessionData.sessionSecureID), yt(this.sessionData);
      };
      window.addEventListener("pagehide", r), this.listeners.push(() => window.removeEventListener("beforeunload", r));
    }
  }
  submitViewportMetrics({ height: e, width: t, availHeight: i, availWidth: r }) {
    this.recordMetric([
      {
        name: Qe.ViewportHeight,
        value: e,
        category: Xe.Device,
        group: window.location.href
      },
      {
        name: Qe.ViewportWidth,
        value: t,
        category: Xe.Device,
        group: window.location.href
      },
      {
        name: Qe.ScreenHeight,
        value: i,
        category: Xe.Device,
        group: window.location.href
      },
      {
        name: Qe.ScreenWidth,
        value: r,
        category: Xe.Device,
        group: window.location.href
      },
      {
        name: Qe.ViewportArea,
        value: e * t,
        category: Xe.Device,
        group: window.location.href
      }
    ]);
  }
  recordMetric(e) {
    this._worker.postMessage({
      message: {
        type: Ie.Metrics,
        metrics: e.map((t) => se(X({}, t), {
          tags: t.tags || [],
          group: t.group || window.location.href,
          category: t.category || Xe.Frontend,
          timestamp: /* @__PURE__ */ new Date()
        }))
      }
    });
  }
  /**
   * Stops Highlight from recording.
   * @param manual The end user requested to stop recording.
   */
  stopRecording(e) {
    this.manualStopped = !!e, this.manualStopped && this.addCustomEvent("Stop", "H.stop() was called which stops Highlight from recording."), this.state = "NotRecording", e && this._recordStop && (this._recordStop(), this._recordStop = void 0), this.listeners.forEach((t) => t()), this.listeners = [];
  }
  getCurrentSessionTimestamp() {
    return this._recordingStartTime;
  }
  /**
   * Returns the current timestamp for the current session.
   */
  getCurrentSessionURLWithTimestamp() {
    const e = (/* @__PURE__ */ new Date()).getTime(), { projectID: t, sessionSecureID: i } = this.sessionData, r = (e - this._recordingStartTime) / 1e3;
    return `https://${Vn}/${t}/sessions/${i}?ts=${r}`;
  }
  getCurrentSessionURL() {
    const e = this.sessionData.projectID, t = this.sessionData.sessionSecureID;
    return e && t ? `https://${Vn}/${e}/sessions/${t}` : null;
  }
  snapshot(e) {
    return ee(this, null, function* () {
      yield Ye.snapshotCanvas(e);
    });
  }
  addSessionFeedback({ timestamp: e, verbatim: t, user_email: i, user_name: r }) {
    var n;
    this._worker.postMessage({
      message: {
        type: Ie.Feedback,
        verbatim: t,
        timestamp: e,
        userName: r || this.sessionData.userIdentifier,
        userEmail: i || ((n = this.sessionData.userObject) == null ? void 0 : n.name)
      }
    });
  }
  // Reset the events array and push to a backend.
  _save() {
    return ee(this, null, function* () {
      var e;
      try {
        this.state === "Recording" && this.listeners && this.sessionData.sessionStartTime && Date.now() - this.sessionData.sessionStartTime > Fc && (this.logger.log("Resetting session", {
          start: this.sessionData.sessionStartTime
        }), yield this._reset({}));
        let t;
        ((e = this.options) == null ? void 0 : e.sendMode) === "local" && (t = (i) => ee(this, null, function* () {
          let r = new Blob([
            JSON.stringify({
              query: tl(ec),
              variables: i
            })
          ], {
            type: "application/json"
          });
          return yield window.fetch(`${this._backendUrl}`, {
            method: "POST",
            body: r
          }), 0;
        })), yield this._sendPayload({ sendFn: t }), this.hasPushedData = !0, this.sessionData.lastPushTime = Date.now(), yt(this.sessionData);
      } catch (t) {
        this._isOnLocalHost && (console.error(t), Xt("_save", t));
      }
      this.state === "Recording" && (this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this.pushPayloadTimerId = setTimeout(() => {
        this._save();
      }, Kc));
    });
  }
  /**
   * This proxy should be used instead of rrweb's native addCustomEvent.
   * The proxy makes sure recording has started before emitting a custom event.
   */
  addCustomEvent(e, t) {
    if (this.state === "NotRecording") {
      let i;
      const r = () => {
        clearInterval(i), this.state === "Recording" && this.events.length > 0 ? Yo(e, t) : i = setTimeout(r, 500);
      };
      i = setTimeout(r, 500);
    } else this.state === "Recording" && (this.events.length > 0 || this.hasPushedData) && Yo(e, t);
  }
  _sendPayload(t) {
    return ee(this, arguments, function* ({ sendFn: e }) {
      const i = je.getRecordedNetworkResources(this._firstLoadListeners, this._recordingStartTime), r = je.getRecordedWebSocketEvents(this._firstLoadListeners), n = [...this.events], l = [...this._firstLoadListeners.messages], a = [...this._firstLoadListeners.errors], { bytes: o, time: c } = this.enableCanvasRecording ? Wn.canvas : Wn.normal;
      this._eventBytesSinceSnapshot >= o && (/* @__PURE__ */ new Date()).getTime() - this._lastSnapshotTime >= c && this.takeFullSnapshot(), this.logger.log(`Sending: ${n.length} events, ${l.length} messages, ${i.length} network resources, ${a.length} errors 
To: ${this._backendUrl}
Org: ${this.organizationID}
SessionSecureID: ${this.sessionData.sessionSecureID}`);
      const u = $b();
      e ? yield e({
        session_secure_id: this.sessionData.sessionSecureID,
        payload_id: this.sessionData.payloadID.toString(),
        events: { events: n },
        messages: Vs({ messages: l }),
        resources: JSON.stringify({ resources: i }),
        web_socket_events: JSON.stringify({
          webSocketEvents: r
        }),
        errors: a,
        is_beacon: !1,
        has_session_unloaded: this.hasSessionUnloaded
      }) : this._worker.postMessage({
        message: {
          type: Ie.AsyncEvents,
          id: this.sessionData.payloadID++,
          events: n,
          messages: l,
          errors: a,
          resourcesString: JSON.stringify({ resources: i }),
          webSocketEventsString: JSON.stringify({
            webSocketEvents: r
          }),
          hasSessionUnloaded: this.hasSessionUnloaded,
          highlightLogs: u
        }
      }), yt(this.sessionData), je.clearRecordedNetworkResources(this._firstLoadListeners), this.events = this.events.slice(n.length), this._firstLoadListeners.messages = this._firstLoadListeners.messages.slice(l.length), this._firstLoadListeners.errors = this._firstLoadListeners.errors.slice(a.length), qb(u);
    });
  }
  takeFullSnapshot() {
    if (!this._recordStop) {
      this.logger.log("skipping full snapshot as rrweb is not running");
      return;
    }
    this.logger.log("taking full snapshot", {
      bytesSinceSnapshot: this._eventBytesSinceSnapshot,
      lastSnapshotTime: this._lastSnapshotTime
    }), Ye.takeFullSnapshot(), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime();
  }
}
export {
  je as FirstLoadListeners,
  Is as GenerateSecureID,
  yc as Highlight,
  Xt as HighlightWarning,
  Xe as MetricCategory,
  Gn as getPreviousSessionData,
  Hy as getTracer,
  My as setupBrowserTracing
};
//# sourceMappingURL=index-BnP9Rknr.js.map
